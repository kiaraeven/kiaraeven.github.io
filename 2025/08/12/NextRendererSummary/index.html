

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. OpenGL 接口封装（项目 RHI） （1）GLBuffer（GLShader.h&#x2F;.cpp）：   封装对象: GL_BUFFER   作用: 最基础的封装，代表了 GPU 上的一块连续内存。它被用作所有类型数据（顶点、索引、统一变量 UBO、着色器存储 SSBO）的容器。   实现: 123456789101112131415161718192021class GLBuffer&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="Summary and review of My OpenGL-based renderer">
<meta property="og:url" content="http://example.com/2025/08/12/NextRendererSummary/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="1. OpenGL 接口封装（项目 RHI） （1）GLBuffer（GLShader.h&#x2F;.cpp）：   封装对象: GL_BUFFER   作用: 最基础的封装，代表了 GPU 上的一块连续内存。它被用作所有类型数据（顶点、索引、统一变量 UBO、着色器存储 SSBO）的容器。   实现: 123456789101112131415161718192021class GLBuffer&amp;#12">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-12T15:55:36.549Z">
<meta property="article:modified_time" content="2025-10-27T02:04:40.317Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="graphics">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Summary and review of My OpenGL-based renderer - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Summary and review of My OpenGL-based renderer"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-12 08:55" pubdate>
          August 12, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          210 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Summary and review of My OpenGL-based renderer</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-opengl-接口封装项目-rhi">1. OpenGL 接口封装（项目 RHI）</h1>
<h2 id="1glbufferglshaderhcpp">（1）GLBuffer（GLShader.h/.cpp）：</h2>
<ul>
<li>
<p>封装对象: GL_BUFFER</p>
</li>
<li>
<p>作用: 最基础的封装，代表了 GPU 上的一块连续内存。它被用作所有类型数据（顶点、索引、统一变量 UBO、着色器存储 SSBO）的容器。</p>
</li>
<li>
<p>实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLBuffer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GLBuffer</span>(GLsizeiptr size, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, GLbitfield flags);<br>  ~<span class="hljs-built_in">GLBuffer</span>();<br><br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br><span class="hljs-keyword">private</span>:<br>  GLuint handle_;<br>&#125;;<br><span class="hljs-comment">// 构造函数: 调用 glCreateBuffers() 创建一个缓冲区句柄，然后调用 glNamedBufferStorage() 为其分配指定大小和用途的、不可变的存储空间。</span><br>GLBuffer::<span class="hljs-built_in">GLBuffer</span>(GLsizeiptr size, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, GLbitfield flags)<br>&#123;<br>  <span class="hljs-built_in">glCreateBuffers</span>(<span class="hljs-number">1</span>, &amp;handle_);<br>  <span class="hljs-built_in">glNamedBufferStorage</span>(handle_, size, data, flags);<br>&#125;<br><br>GLBuffer::~<span class="hljs-built_in">GLBuffer</span>()<br>&#123;<br>  <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;handle_);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2gltexture纹理资源管理器gltexturehcpp">（2）GLTexture（纹理资源管理器）（GLTexture.h/.cpp）：</h2>
<ul>
<li>
<p>封装对象: GL_TEXTURE</p>
</li>
<li>
<p>作用: 管理 2D 纹理、立方体贴图和纹理数组。</p>
</li>
<li>
<p>实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLTexture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName);<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, GLenum clamp);<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, GLenum internalFormat);<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> layers, GLenum internalFormat);<br>  <span class="hljs-built_in">GLTexture</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* img);<br>  ~<span class="hljs-built_in">GLTexture</span>();<br>  <span class="hljs-built_in">GLTexture</span>(<span class="hljs-type">const</span> GLTexture&amp;) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-built_in">GLTexture</span>(GLTexture&amp;&amp;) <span class="hljs-keyword">noexcept</span>;<br>  <span class="hljs-function">GLenum <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> type_; &#125;<br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br>  <span class="hljs-function">GLuint64 <span class="hljs-title">getHandleBindless</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handleBindless_; &#125;<br><span class="hljs-keyword">private</span>:<br>  GLenum type_ = <span class="hljs-number">0</span>;<br>  GLuint handle_ = <span class="hljs-number">0</span>;<br>  GLuint64 handleBindless_ = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>构造函数: 被**重载 (overloaded)**以处理多种情况：
<ul>
<li>GLTexture(type, width, height, format): 创建一个空的纹理，主要用作帧缓冲的附件。</li>
<li>GLTexture(type, fileName): 从文件加载纹理。它内部会判断文件类型（.ktx, .hdr 或普通图片），并调用 stbi_load 或 gli::load_ktx 来加载像素数据。</li>
<li>GLTexture(type, width, height, layers, format): 创建一个 GL_TEXTURE_2D_ARRAY (for CSM)。</li>
</ul>
</li>
<li>核心逻辑: 构造函数内部使用 glCreateTextures()创建句柄，用 glGenerateTextureMipmap 生成 mipmaps，glTextureParameteri 设置采样参数，用 glTextureStorage2D/3D()分配内存，用 glTextureSubImage2D/3D()上传像素数据。</li>
<li>高级功能: 它还封装了**无绑定纹理 (Bindless Textures)**的逻辑，通过 glGetTextureHandleARB 和 glMakeTextureHandleResidentARB 获取并激活 64 位句柄 。无绑定纹理避免了频繁的纹理绑定/解绑操作，提升性能；着色器程序可以在运行时动态选择纹理，无需重新绑定；多个绘制调用可以使用不同的纹理而无需状态切换。常用于大规模场景渲染、动态纹理管理等。</li>
</ul>
</li>
</ul>
<p>PS：项目中的主渲染循环（阴影 pass、主场景 pass、后处理）、天空盒、UI 系统都是使用的绑定纹理，无绑定纹理主要是用于场景数据管理：材质纹理（GLSceneData.cpp 和 GLSceneDataLazy.cpp 中）、PBR 材质贴图（环境光遮蔽、自发光、反照率、金属粗糙度、法线贴图）、<br>
通过 getTextureHandleBindless() 函数获取无绑定句柄。GLTexture 类：自动生成无绑定句柄并使其常驻，材质系统将传统纹理索引转换为无绑定句柄。</p>
<h2 id="3glframebuffer渲染目标切换器glframebufferh">（3）GLFramebuffer（渲染目标切换器）（GLFramebuffer.h）：</h2>
<ul>
<li>封装对象: GL_FRAMEBUFFER</li>
<li>作用: 封装一个帧缓冲对象（FBO），用于实现离屏渲染 (Offscreen Rendering)。</li>
<li>实现:
<ul>
<li>构造函数: 它不直接存储像素数据，而是像一个“插座板”，接收一个或多个颜色/深度格式，然后在内部创建并拥有 GLTexture 对象作为其附件。重载构造函数以创建包含单个/多个颜色附件、只包含深度附件</li>
<li>核心逻辑: 使用 glCreateFramebuffers()创建 FBO 句柄，然后通过 glNamedFramebufferTexture()将内部的 GLTexture 句柄“挂载”到 GL_COLOR_ATTACHMENTn 或 GL_DEPTH_ATTACHMENT 等附件点上 。对于多渲染目标（MRT），还会调用 glNamedFramebufferDrawBuffers()来启用多个颜色输出。</li>
<li>接口: 提供了 bind()和 unbind()方法来方便地切换渲染目标。getTextureColor/Depth 来获取颜色/深度纹理。</li>
</ul>
</li>
</ul>
<h2 id="4glshader-和-glprogram着色器管线glshaderhcpp">（4）GLShader 和 GLProgram（着色器管线）（GLShader.h/.cpp）：</h2>
<ul>
<li>
<p>封装对象: GL_SHADER 和 GL_PROGRAM</p>
</li>
<li>
<p>作用: 将 GLSL 着色器的加载、编译和链接过程封装起来。</p>
</li>
<li>
<p>实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLShader</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Constructors take either a filename or a shader type and source code</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GLShader</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName)</span></span>;<br>  <span class="hljs-built_in">GLShader</span>(GLenum type, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* text, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* debugFileName = <span class="hljs-string">&quot;&quot;</span>);<br>  ~<span class="hljs-built_in">GLShader</span>();<br>  <span class="hljs-function">GLenum <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> type_; &#125;<br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  GLenum type_;<br>  GLuint handle_;<br>&#125;;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// Use compiled shaders in OpenGL by linking them to a shader program</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLProgram</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a);<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a, <span class="hljs-type">const</span> GLShader&amp; b);<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a, <span class="hljs-type">const</span> GLShader&amp; b, <span class="hljs-type">const</span> GLShader&amp; c);<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a, <span class="hljs-type">const</span> GLShader&amp; b, <span class="hljs-type">const</span> GLShader&amp; c, <span class="hljs-type">const</span> GLShader&amp; d, <span class="hljs-type">const</span> GLShader&amp; e);<br>  ~<span class="hljs-built_in">GLProgram</span>();<br><br>  <span class="hljs-comment">// To install a program object as part of the current rendering state.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useProgram</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  GLuint handle_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>GLShader: 它的构造函数接收一个文件名，然后调用一个自定义的 readShaderFile()辅助函数（这个函数手动处理了 GLSL 中的#include 指令 ）。读取源码后，它调用 glCreateShader, glShaderSource, glCompileShader 来完成编译，并包含了错误检查和日志打印。</li>
<li>GLProgram: 它的构造函数接收一个或多个<em>已编译</em>的 GLShader 对象，然后调用 glCreateProgram, glAttachShader, glLinkProgram 来将它们链接成一个可执行的 GPU 程序 。</li>
</ul>
</li>
</ul>
<h2 id="核心设计哲学raii-与直接状态访问-dsa">核心设计哲学：RAII 与直接状态访问 (DSA)</h2>
<h3 id="1-raii">(1) RAII</h3>
<ul>
<li>原始的 OpenGL 中需要手动调用 glGen*()来创建对象，然后在不再需要时手动调用 glDelete*()来销毁它，这极易导致资源泄漏。本项目将每一个 OpenGL 对象（如缓冲区、纹理、着色器程序）都封装在一个 C++类中。</li>
<li>构造函数: 负责调用 glCreate*()或 glGen*()来获取 OpenGL 资源。</li>
<li>析构函数: 负责调用 glDelete*()来释放 OpenGL 资源。</li>
<li>优势: 这种方法利用了 C++的栈语义和对象生命周期管理。当一个封装类的对象（例如 GLTexture tex(…)）被创建时，OpenGL 资源会自动被创建；当这个对象离开其作用域时（例如函数返回），它的析构函数会自动被调用，确保 OpenGL 资源被干净利落地释放，从而从根本上消除了资源泄漏的风险。</li>
</ul>
<h3 id="2-直接状态访问-direct-state-access-dsa">(2) 直接状态访问 (Direct State Access - DSA)</h3>
<ul>
<li>OpenGL 4.5 引入的一套现代 API。在旧的 OpenGL 中，要修改一个对象（比如一个纹理），必须先把它绑定到一个全局的目标上，然后才能调用 glTexParameter*()等函数进行修改。这种“先绑定再编辑”的模式会污染全局状态，代码也不够清晰。本项目中的封装类（如 GLTexture, GLFramebuffer, GLMesh）大量使用了 DSA 函数。如 glTextureStorage2D(), glNamedBufferStorage(), glNamedFramebufferTexture() 这样的函数调用。这些函数的第一个参数都是对象的句柄 (handle)，而不是一个目标。</li>
<li>优势: DSA 可以直接对一个对象进行操作，而无需先将其绑定到全局状态。这使得代码更清晰、更不容易出错，并且在某些情况下性能更高，因为它减少了驱动程序需要进行的状态检查。</li>
</ul>
<h1 id="2-阴影">2. 阴影</h1>
<h2 id="1shadow-map-pcf">（1）Shadow Map + PCF</h2>
<h3 id="核心思想两次渲染两种视角"><strong>核心思想：两次渲染，两种视角</strong></h3>
<ul>
<li><strong>第一次渲染</strong>: 从<strong>光源的位置</strong>看场景。“看”到的所有东西，都是被光直接照亮的。把看到的每个物体的深度信息，拍成一张“深度照片”，这张照片就是<strong>阴影贴图 (Shadow Map)</strong>。</li>
<li><strong>第二次渲染</strong>: 从<strong>摄像机的位置</strong>正常地渲染场景。但在为每个像素上色之前先做一个判断：这个像素在世界中的位置，如果从光源的视角来看，是比之前拍的那张阴影贴图上的点更远/更近？
<ul>
<li>如果<strong>更远</strong>，说明它被挡住了，它就在<strong>阴影</strong>里。</li>
<li>如果<strong>更近或距离相同</strong>，说明它没被挡住，它就在<strong>光照</strong>下。</li>
</ul>
</li>
</ul>
<h3 id="第一步shadow-generation-pass"><strong>第一步：Shadow Generation Pass</strong></h3>
<p>从<strong>光源的视角</strong>渲染整个不透明场景。</p>
<ul>
<li>
<p><strong>C++ 端：</strong></p>
<ul>
<li><strong>计算光源矩阵</strong>: 根据 <code>g_LightTheta</code>, <code>g_LightPhi</code> 计算出光源的方向 <code>lightDir</code>。然后，用 <code>glm::lookAt(eye, target, up)</code> 和 <code>glm::ortho</code> 创建了光源的<strong>视图矩阵 (<code>lightView</code>)</strong> 和<strong>正交投影矩阵 (<code>lightProj</code>)</strong>。其中投影矩阵是把整个场景的包围盒转换到光源空间下，然后<code>lightProj = glm::ortho(box.min_.x, box.max_.x, box.min_.y, box.max_.y, -box.max_.z, -box.min_.z)</code>。</li>
<li><strong>绑定帧缓冲</strong>: 程序调用 <code>shadowMap.bind()</code> ，将渲染目标从屏幕切换到一个离线的帧缓冲对象（FBO）上。这个 <code>shadowMap</code> FBO 包含一个高分辨率的<strong>深度纹理附件</strong>。</li>
<li><strong>上传矩阵</strong>: 程序将 <code>lightView</code> 和 <code>lightProj</code> 组合成 <code>lightMatrix</code>，并将其上传到 <code>PerFrameData</code> 这个统一变量缓冲区（UBO）中。</li>
<li><strong>激活着色器</strong>: C++ <code>progShadowMap.useProgram()</code>。</li>
</ul>
</li>
<li>
<p><strong>GPU 端：</strong></p>
<ul>
<li><strong>顶点着色器 (<code>shadow.vert</code>)</strong>:
<ul>
<li>获取物体的顶点位置，然后用<code>lightMatrix</code>对其进行变换，计算出顶点在<strong>光源裁剪空间</strong>中的最终位置 <code>gl_Position</code>。</li>
</ul>
</li>
<li><strong>片元着色器 (<code>shadow.frag</code>)</strong>:
<ul>
<li>这个着色器类似一个“占位符” 。在这一步，<strong>只关心深度</strong>。当 GPU 对三角形进行光栅化时，它会自动计算每个片元的深度值，并将其写入 <code>shadowMap</code> FBO 的<strong>深度纹理</strong>中。</li>
<li>这个着色器输出的颜色 <code>vec4(1.0, 0.0, 0.0, 1.0)</code> 实际上被丢弃了，因为它所绑定的 FBO 已经被配置为只关心深度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>此阶段结束时，<code>shadowMap</code> FBO 的深度纹理中，就存储了一张从光源视角看去的、完整的场景深度图。</strong></p>
<h3 id="第二步shadow-application-pass"><strong>第二步：Shadow Application Pass</strong></h3>
<p>主渲染通道，从<strong>摄像机的视角</strong>正常渲染场景，并利用上一步生成的阴影贴图来计算阴影。</p>
<ul>
<li>
<p><strong>C++ 端：</strong></p>
<ul>
<li><strong>绑定主帧缓冲</strong></li>
<li><strong>计算摄像机矩阵</strong>: 正常计算摄像机的 <code>view</code> 和 <code>proj</code> 矩阵。</li>
<li><strong>绑定阴影贴图</strong>: <code>glBindTextureUnit(4, shadowMap.getTextureDepth().getHandle())</code>，将上一阶段生成的<strong>深度纹理</strong>绑定到一个可供着色器采样的纹理单元（这里是 4 号）上。</li>
<li><strong>激活着色器</strong>: C++ 代码调用 <code>program.useProgram()</code>。</li>
</ul>
</li>
<li>
<p><strong>GPU 端：</strong></p>
<ul>
<li><strong>顶点着色器 (<code>scene_IBL_MTR.vert</code>)</strong>:
<ul>
<li>计算顶点在<strong>摄像机裁剪空间</strong>中的位置，并赋值给 <code>gl_Position</code>，用于正常渲染。</li>
<li>计算同一个顶点在<strong>光源裁剪空间</strong>中的位置，并将其乘以 <code>scaleBias</code> 矩阵（将 <code>[-1, 1]</code> 范围映射到 <code>[0, 1]</code>），然后将这个结果 <code>v_shadowCoord</code> 传递给片元着色器。</li>
</ul>
</li>
<li><strong>片元着色器 (<code>scene_IBL_MTR.frag</code>)</strong>:
<ul>
<li><strong>接收坐标</strong>: 它接收从顶点着色器传来的、经过插值的 <code>v_shadowCoord</code>。</li>
<li><strong>透视除法</strong>: 它首先对 <code>v_shadowCoord</code> 进行透视除法 <code>(v_shadowCoord.xyz / v_shadowCoord.w)</code>，得到一个 <code>vec3</code> 坐标。这个坐标的 <code>.xy</code> 是在阴影贴图上的采样位置，<code>.z</code> 则是当前片元<strong>距离光源的深度</strong>。</li>
<li><strong>PCF 采样</strong>: 着色器调用您编写的 <code>PCF()</code> 函数。这个函数会以 <code>shadowCoord.xy</code> 为中心，在阴影贴图上进行多次采样（例如 5x5 的网格）。在每一次采样中，<code>texture()</code> 函数（配合 <code>sampler2DShadow</code> 类型）会自动将当前片元的深度 <code>shadowCoord.z</code> 与阴影贴图中存储的深度进行<strong>硬件加速比较</strong>。这一步解决普通 shadow mapping 的边缘锯齿问题。</li>
<li><strong>计算阴影因子</strong>: <code>PCF()</code> 函数将所有比较结果进行平均，返回一个 <code>0.0</code> (完全在阴影中) 到 <code>1.0</code> (完全被照亮) 之间的<strong>阴影因子 <code>shadow</code></strong>。</li>
<li><strong>应用阴影</strong>: 最后，着色器将计算出的 PBR 颜色 <code>pbrColor</code>，与这个阴影因子 <code>shadow</code> 相乘 (<code>finalColor = pbrColor * shadow;</code>)，得到最终的、带有真实阴影的像素颜色。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2遇到哪些问题如何处理采样精度不足指的是精度如果用-float-表达其实已经够了">（2）遇到哪些问题？如何处理？采样精度不足指的是？精度如果用 float 表达其实已经够了</h2>
<h3 id="shadow-acne"><strong>Shadow Acne</strong></h3>
<ul>
<li><strong>现象</strong>: 物体表面（特别是被光斜着照射的表面）出现不规则的黑色条纹或斑点，看起来像是“暗疮”。</li>
<li><strong>原因</strong>: 这是由<strong>深度精度</strong>问题引起的。阴影贴图的分辨率是有限的，它存储的深度值是离散的。当片元着色器计算一个片元距离光源的深度时，这个计算结果可能因为浮点数精度误差，比存储在阴影贴图上<strong>几乎相同位置</strong>的深度值要大那么一点点。这导致这个片元在进行深度比较时，错误地判断自己“被自己挡住了”，从而将自己渲染进了阴影中。</li>
<li><strong>解决方案：深度偏移 (Depth Bias)</strong></li>
</ul>
<h3 id="彼得潘现象-peter-panning"><strong>彼得潘现象 (Peter Panning)</strong></h3>
<ul>
<li><strong>现象</strong>: “用力过猛”的深度偏移导致的副作用。阴影看起来与投射出它的物体<strong>分离</strong>了。</li>
<li><strong>原因</strong>: 如果设置的深度偏移量（<code>Depth Bias</code>）过大，会导致阴影的起始位置离物体的根部太远，看起来就像悬浮在空中。</li>
<li><strong>解决方案：斜率缩放偏移 (Slope-Scaled Depth Bias)</strong>
<ul>
<li>一个固定的偏移量对于所有表面都不是最优的。对于那些与光线方向几乎平行的陡峭表面，需要更大的偏移；而对于那些与光线垂直的平坦表面，一个很小的偏移就足够了。</li>
<li><code>glPolygonOffset(slope, constant)</code> 函数的第一个参数 <code>slope</code> 正是为此而生。它会根据多边形相对于光源方向的“斜率”，动态地调整偏移量的大小。</li>
<li>通过仔细地调节 <code>slope</code> 和 <code>constant</code> 这两个参数，您可以在有效消除暗疮的同时，最大限度地减少彼得潘现象。</li>
</ul>
</li>
</ul>
<h3 id="边缘锯齿-aliasing"><strong>边缘锯齿 (Aliasing)</strong></h3>
<ul>
<li><strong>现象</strong>: 阴影的边缘呈现出明显的、块状的锯齿。</li>
<li><strong>原因</strong>: 阴影贴图本质上是一张纹理，它的分辨率是有限的。一个像素要么完全在阴影内（返回 0.0），要么完全在阴影外（返回 1.0），这种二元的判断导致了硬朗的、带有锯齿的边缘。</li>
<li><strong>解决方案：百分比渐近滤波 (Percentage-Closer Filtering, PCF)</strong>
<ul>
<li>PCF 的核心思想是，不再只对阴影贴图进行一次采样。而是在当前片元阴影坐标的<strong>周围邻域</strong>内，进行多次采样（例如，在一个 5x5 的网格中采样 25 次）。</li>
<li>将这 25 次硬件深度比较的结果（<code>0.0</code> 或 <code>1.0</code>）进行<strong>平均</strong>。</li>
<li>最终得到的阴影因子就是一个在<code>0.0</code>到<code>1.0</code>之间平滑变化的<strong>百分比</strong>，它代表了“当前片元有多大比例处于阴影中”。这个平滑的过渡值，就产生了柔和的阴影边缘，有效地消除了锯齿。</li>
</ul>
</li>
</ul>
<h3 id="透视失真-perspective-aliasing"><strong>透视失真 (Perspective Aliasing)</strong></h3>
<ul>
<li><strong>现象</strong>: 近处的阴影质量极差，充满了巨大的块状锯齿，而远处的阴影看起来却还可以。</li>
<li><strong>原因</strong>: 这是透视投影和阴影贴图分辨率的根本矛盾。主摄像机使用<strong>透视投影</strong>，近处的物体在屏幕上占据大量像素。而定向光源为了覆盖整个场景使用<strong>正交投影</strong>，为空间中的每个区域都分配了相同的分辨率。
<ul>
<li>这就导致了离摄像机很近的一大片地面可能只对应了阴影贴图中非常少的几个像素。当这些像素被放大显示在屏幕上时就形成了巨大的块状阴影。</li>
</ul>
</li>
<li><strong>解决方案：级联阴影贴图 (Cascaded Shadow Maps, CSM)</strong>
<ul>
<li>CSM 通过将摄像机的视锥体分割成多个<strong>级联</strong>来完美地解决这个问题。</li>
<li>离摄像机最近的级联（Cascade 0）只覆盖一小块区域，但它会得到一张独立的、高分辨率的阴影贴图。</li>
<li>离得最远的级联覆盖范围巨大，但使用一张较低分辨率的贴图。</li>
<li>通过为不同距离的区域“量身定制”阴影贴图，CSM 确保了无论在近处还是远处，阴影都能获得足够的分辨率，从而从根本上解决了透视失真问题。</li>
</ul>
</li>
</ul>
<h2 id="3csm">（3）CSM</h2>
<h3 id="第一阶段cpu-端-while-循环中"><strong>第一阶段：CPU 端 (<code>while</code> 循环中)</strong></h3>
<ul>
<li>
<p><strong>纹理数组</strong>: 创建了一个 <code>GLTexture shadowMapTextureArray</code>，其类型为 <code>GL_TEXTURE_2D_ARRAY</code>，尺寸为 2048x2048，层数为 4。</p>
</li>
<li>
<p><strong>计算级联分割</strong>：</p>
<ul>
<li>根据摄像机的近、远裁剪面（0.1f, 1000.0f）和设定的 <code>g_CascadeLambda</code> 参数，采用一种混合了<strong>对数和线性</strong>的分割方案。这里让前一个级联的远平面和后一个级联的近平面有一点重合的部分。</li>
<li>这种方案能在近处提供更多的深度精度，同时又保证了远处级联的平滑过渡。</li>
<li>得到每个级联的远近平面在观察空间中的 z 值</li>
</ul>
</li>
<li>
<p><strong>为每个级联计算光源矩阵</strong></p>
<ul>
<li><strong>计算子视锥角点</strong>: 计算出当前级联所覆盖的那个<strong>子视锥体 (sub-frustum)</strong> 在世界空间中的 8 个角点。</li>
<li><strong>找到视锥中心</strong>: 计算这 8 个角点的平均值，得到子视锥体的几何中心。</li>
<li><strong>创建光源视图矩阵 (<code>lightView</code>)</strong>: 以子视锥体的中心为目标点，沿着光线方向的反方向设置光源的“摄像机”位置，并使用 <code>glm::lookAt</code> 创建一个能正好观察到这个子视锥体的视图矩阵。</li>
<li><strong>计算紧凑的正交投影 (<code>lightProj</code>)</strong>: 将子视锥体的 8 个角点变换到刚刚创建的光源空间中，然后计算这 8 个点的轴对齐包围盒 (AABB)并转换到光源空间。再根据整个场景在光源空间的总 AABB 的范围来拓展小 AABB 的 z 值，从而计算出光源的<strong>正交投影矩阵</strong>。</li>
</ul>
</li>
</ul>
<h3 id="第二阶段shadow-pass"><strong>第二阶段：shadow pass</strong></h3>
<ul>
<li>在一个 <code>for</code> 循环中，遍历 4 个级联。在每一次循环中：
<ul>
<li>通过 <code>glNamedFramebufferTextureLayer</code>，将 FBO 的渲染目标<strong>切换</strong>到 <code>shadowMapTextureArray</code> 的第 <code>i</code> 层。</li>
<li>让 GPU 从光源的视角，将所有不透明物体渲染一遍。</li>
<li>此阶段结束后，<code>shadowMapTextureArray</code> 纹理数组的 4 个层中，就分别存储了 4 张从光源视角看去的、覆盖不同距离范围的深度图。</li>
</ul>
</li>
</ul>
<h3 id="第三阶段gpu-端-main-scene-pass"><strong>第三阶段：GPU 端 Main Scene Pass</strong></h3>
<ul>
<li><strong>C++ 端</strong>:
<ul>
<li>将 <code>shadowMapTextureArray</code> 这张纹理数组，绑定到一个 <code>sampler2DArrayShadow</code> 类型的纹理单元上（例如 <code>binding = 4</code>）。</li>
</ul>
</li>
<li><strong>GPU 端 (PBR 片元着色器)</strong>:
<ul>
<li><strong>选择级联</strong>: 着色器首先获取当前正在着色的片元（像素）在<strong>观察空间</strong>中的深度 <code>viewDepth</code>，将之与每个级联的分割深度远近平面进行比较，从而快速地确定出当前片元属于哪个级联。</li>
<li><strong>计算阴影坐标</strong>: 确定了级联索引后，取出对应索引的 <code>cascadeMat</code> 矩阵，用它来将片元的世界坐标变换到光源的裁剪空间，得到 <code>shadowCoord</code>和其在光源空间的深度。</li>
<li>进行硬件加速的深度比较和 PCF。</li>
</ul>
</li>
</ul>
<h2 id="4其他阴影算法">（4）其他阴影算法</h2>
<p>pcss（原理、切比雪夫什么时候精确）</p>
<p>见 <a href="/2025/03/29/interview-review/"> 面试复习：8. 阴影技术</a></p>
<h1 id="3-透明渲染">3. 透明渲染</h1>
<h2 id="1oit-实现">（1）OIT 实现</h2>
<p>传统 Alpha 混合的难点在于，GPU 在光栅化时，同一个像素可能会被多个不同远近的透明片元覆盖，而 GPU 并不知道应该先画哪个。</p>
<p>本项目中 OIT 算法的思路是：不让 GPU 在渲染时直接混合。取而代之的是：</p>
<ul>
<li><strong>第一趟 (Opaque Pass)</strong>：先把所有不透明的物体都画好，得到背景颜色和一张完整的深度图。</li>
<li><strong>第二趟 (Transparent Pass)</strong>：再渲染所有透明物体。但这次，不把它们的颜色画到屏幕上，而是把每个透明片元的<strong>颜色</strong>和<strong>深度</strong>信息放在对应屏幕像素的一个<strong>链表</strong>里。</li>
<li><strong>第三趟 (Combination Pass)</strong>：最后，渲染一个覆盖全屏的四边形。对于屏幕上的每一个像素，独立地处理它的链表：先把这些片元按<strong>从远到近</strong>的顺序排好，然后再逐个地、正确地将它们混合到第一趟渲染好的背景上。</li>
</ul>
<h3 id="第一阶段渲染不透明物体-opaque-pass"><strong>第一阶段：渲染不透明物体 (Opaque Pass)</strong></h3>
<p>略</p>
<h3 id="第二阶段收集透明片元-transparent-pass"><strong>第二阶段：收集透明片元 (Transparent Pass)</strong></h3>
<ul>
<li><strong>C++ 端</strong>
<ul>
<li>创建三个 GPU 缓冲区：
<ul>
<li><code>GLTexture oitHeads</code>: 一张 <code>GL_R32UI</code> 格式的 2D 纹理。每个纹素是一个无符号 32 位整数，存储该像素对应链表的头指针。</li>
<li><code>GLBuffer oitAtomicCounter</code>: 一个只包含一个整数的缓冲区，用作<strong>原子计数器</strong>。确保每个新来的片元都能拿到一个独一无二的 ID。</li>
<li><code>GLBuffer oitTransparencyLists</code>: 一个巨大的 SSBO，用来存放所有透明片元（<code>TransparentFragment</code> 结构体）的实际数据。</li>
</ul>
</li>
<li>在渲染循环开始时，<code>clearTransparencyBuffers()</code> 函数会被调用，它将 <code>oitHeads</code> 的所有像素都重置为 <code>-1</code>（表示链表为空），并将原子计数器归零。</li>
<li><code>glDepthMask(GL_FALSE)</code>: <strong>深度写入被关闭</strong>。透明物体之间不应该互相遮挡深度。</li>
<li><code>glColorMask(GL_FALSE, ..., GL_FALSE)</code>: <strong>颜色写入被关闭</strong>。我们不希望这些片元直接被画到帧缓冲里。</li>
</ul>
</li>
<li><strong>GPU 端 (<code>OIT_transparent.frag</code>)</strong><br>
为每一个通过深度测试的透明片元执行以下操作：
<ul>
<li><strong>获取序列号</strong>: 调用 <code>atomicCounterIncrement(numFragments)</code>（OpenGL 4.2 内置函数），从全局原子计数器中安全地获取一个<strong>新的、唯一的</strong>索引 <code>index</code>。</li>
<li><strong>获取链表当前的头节点</strong>: 调用 <code>imageAtomicExchange(heads, ivec2(gl_FragCoord.xy), index)</code>。
<ul>
<li>将<strong>新的</strong>索引 <code>index</code> 写入到 <code>heads</code> 纹理中当前像素的位置，使其成为新的“头指针”。</li>
<li><strong>返回</strong>在写入之前，那个位置上<strong>旧的</strong>“头指针” <code>prevIndex</code>。</li>
</ul>
</li>
<li><strong>存放新的节点</strong>: 将当前片元的颜色、深度 (<code>gl_FragCoord.z</code>) 以及刚刚获取到的<strong>旧头节点 <code>prevIndex</code></strong>（作为 <code>next</code> 指针），作为一个 <code>TransparentFragment</code> 结构体，存入<code>oitTransparencyLists</code> SSBO 的 <code>index</code> 位置。</li>
</ul>
</li>
</ul>
<p><strong>此阶段结束后，GPU 显存中就已经构建起了一个包含所有可见透明片元信息的、复杂的每像素链表数据结构。</strong></p>
<h3 id="第三阶段排序与混合-combination-pass"><strong>第三阶段：排序与混合 (Combination Pass)</strong></h3>
<ul>
<li><strong>GPU 端 (<code>OIT_full.frag</code>)：整理并混合</strong><br>
为屏幕四边形上的每一个像素执行以下操作：
<ul>
<li><strong>遍历链表</strong>: 根据当前像素坐标，从 <code>heads</code> 纹理中找到链表的头指针，然后顺着 <code>next</code> 指针遍历整个链表，将所有属于这个像素的 <code>TransparentFragment</code> 节点复制到一个小型的本地数组。</li>
<li><strong>排序</strong>: 对这个本地数组进行一次简单的<strong>插入排序</strong>，根据每个节点的 <code>depth</code> 值，将它们<strong>从后往前</strong>（从深度值大的到小的）排列好。</li>
<li><strong>混合</strong>: 首先读取第一趟渲染好的不透明背景色。然后从这个本地数组的<strong>末尾</strong>（现在是<strong>最远的片元</strong>）开始，按照刚刚排好的顺序，将数组中的片元颜色<strong>逐个地</strong>进行标准的 Alpha 混合 (<code>mix</code> 函数)。</li>
<li><strong>输出</strong>: 最终混合完成的颜色，就是这个像素最终应该呈现的、包含了正确透明效果的颜色，被写入到最终的帧缓冲中。</li>
</ul>
</li>
</ul>
<h2 id="2常见的-oit-算法比链表式更节省时间的">（2）常见的 OIT 算法？比链表式更节省时间的？</h2>
<p>另参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368065919">https://zhuanlan.zhihu.com/p/368065919</a></p>
<ul>
<li>精确 OIT</li>
</ul>
<p>这类算法<strong>保证像素颜色和深度混合结果与逐片元严格排序一致</strong>。但代价是<strong>存储和排序所有片元</strong>，计算量和显存需求很大。</p>
<ul>
<li>
<p>深度剥离 (Depth Peeling)</p>
<ul>
<li>逐次渲染场景，剥离最前面的片元层，直到把所有透明层处理完。</li>
<li>优点：结果准确。</li>
<li>缺点：需要多次 pass（=透明层数），效率低。</li>
<li>常见变种：
<ul>
<li>Dual Depth Peeling：每次剥离前后两层，提高效率。</li>
<li>Adaptive Depth Peeling：减少不必要的 pass。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>A-Buffer / Per-Pixel Linked List (PPLL)</p>
<ul>
<li>每个像素存储一个链表，链表里记录该像素下的所有片元（颜色、深度、透明度等）。之后在 fragment 处理结束后对链表排序并混合。</li>
<li>优点：结果精确，不依赖多 pass。</li>
<li>缺点：需要 GPU 上复杂的内存管理（原子操作、链表构建），显存消耗大。由于渲染某一场景所需内存无法提前知道，所以可能会因为没有分配足够内存而导致渲染错误。</li>
</ul>
</li>
<li>
<p>近似 OIT</p>
</li>
</ul>
<p>牺牲一定精度，换取性能。常用于实时渲染和游戏。</p>
<ul>
<li>Weighted Blended OIT (WBOIT)
<ul>
<li>每个片元根据深度给一个权重，把颜色和透明度累加到一个 buffer 中，最后归一化合成。不需要排序，也不需要存储所有片元。</li>
<li>优点：性能极高，单 pass 实现。</li>
<li>缺点：只是近似，可能在交叠复杂时与真实结果差距大。</li>
<li>常见扩展：Weighted Blended with Moment Transparency（结合更高阶统计信息）。</li>
</ul>
</li>
<li>Stencil Routed A-Buffer
<ul>
<li>用 stencil buffer 管理像素内的多个片元存储位置。</li>
<li>每个像素存储有限个片元（类似 k-buffer）。</li>
<li>缺点：硬件依赖强，受片元数限制。</li>
</ul>
</li>
<li>k-Buffer
<ul>
<li>每个像素存储最多 k 个片元（深度+颜色），最后做排序与混合。介于精确和近似之间：当片元数 &lt;= k 时精确，否则裁剪或近似。</li>
</ul>
</li>
<li>Moment-Based OIT
<ul>
<li>借鉴方差阴影贴图的思路，存储片元深度的统计量（前几阶矩），再进行透明度估算。</li>
<li>性能较高，但近似误差明显。</li>
</ul>
</li>
</ul>
<h2 id="3深度剥离意义-流程">（3）深度剥离（意义、流程）</h2>
<ul>
<li>传统渲染流程问题：
<ul>
<li>GPU 默认是 不保证片元顺序的（可能乱序写入）。</li>
<li>如果强行在 CPU 对所有三角形排序:复杂场景开销大、无法解决多层交叠的问题。</li>
</ul>
</li>
<li>深度剥离的意义：
<ul>
<li>提供了一种完全在 GPU 上进行 逐层排序 的方法。</li>
<li>最终结果与逐片元严格排序一致，属于 精确 OIT。</li>
</ul>
</li>
<li>深度剥离的核心思想：从前往后逐层合并
<ul>
<li>第一次 pass 渲染出每个像素最近的透明片元；</li>
<li>第二次 pass 剔除已处理的片元，找到每个像素第二近的片元；</li>
<li>依次类推，直到所有片元都被处理完。</li>
</ul>
</li>
<li>深度剥离的流程
<ul>
<li>Step 1：第一次渲染 (最近一层)
<ul>
<li>打开深度测试和深度写入。</li>
<li>渲染场景，得到每个像素最前的透明片元（最小深度值）。</li>
<li>把它的 颜色、α 和深度 存到缓冲区。</li>
</ul>
</li>
<li>Step 2：第二次渲染 (第二层)
<ul>
<li>使用 上一次 pass 得到的深度图，作为“剥离条件”：</li>
<li>只通过深度测试 z &gt; z_previous_layer 的片元。</li>
<li>这样，每个像素得到的就是比第一层更远的片元。</li>
<li>存储颜色、α、深度。</li>
</ul>
</li>
<li>Step 3：重复剥离
<ul>
<li>依次迭代，直到达到场景的最大透明层数，或者迭代到没有新的片元为止。</li>
</ul>
</li>
<li>Step 4：前到后混合
<ul>
<li>现在有了每一层的颜色和深度信息。</li>
<li>在最后一个 pass，把它们按顺序（前到后）做标准的 α 混合，得到最终结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-pbr">4. PBR</h1>
<p>见<br>
<a href="/2025/09/16/GAMES202-L1011-PBR/"> GAMES202 PBR</a><br>
<a href="/2025/09/02/GAMES202-L0405-EnvMapping/"> GAMES202 Environment Mapping</a></p>
<h2 id="1pbr-实现">（1）PBR 实现</h2>
<ul>
<li>
<p>pbr 基于物理的相机、材质、环境光分别是什么</p>
</li>
<li>
<p>NFG 各项</p>
</li>
<li>
<p>pbr 中如何区分不同材质？</p>
</li>
</ul>
<h2 id="2ibl-与-pbr-结合">（2）ibl 与 PBR 结合</h2>
<ul>
<li>
<p>天空盒先被渲染，然后渲染场景中的物体，这样物体就能正确地接收 IBL 光照。</p>
</li>
<li>
<p>GLSkyboxRenderer 完成天空盒资源初始化和绘制</p>
<ul>
<li>
<p>环境贴图 (envMap_): HDR 立方体贴图，用于反射计算（.hdr,高动态范围图像格式，能存储超过<code>[0,1]</code>的颜色值，存储方式：通常是 RGBE 编码（R,G,B 每通道 8 bit + 共享指数 E 8 bit））。用于计算 PBR 中的镜面反射部分。它存储了经过不同粗糙度级别预滤波的环境贴图。</p>
</li>
<li>
<p>辐照度贴图 (envMapIrradiance_): 预计算的辐照度立方体贴图，用于漫反射光照（.hdr）。它存储了场景中每个方向上入射的平均光照颜色（辐照度）。用于计算 PBR 中的漫反射部分。过对原始的环境立方体贴图进行卷积（Convolution）生成 。这个过程模拟了光线在粗糙表面上的散射，本质上是对环境贴图进行模糊处理 。</p>
</li>
<li>
<p>BRDF 查找表 (brdfLUT_): 双向反射分布函数的预计算查找表（.ktx，容器格式，用来在磁盘上存储 GPU 纹理）。用于计算镜面反射方程中的菲涅尔项（Fresnel Term）的缩放和偏移。存储了在不同视角和粗糙度下的镜面反射积分结果。其 X 轴通常表示法线与视线夹角的余弦值（NdotV），Y 轴表示粗糙度 。每个纹素存储两个值：菲涅尔项的缩放（scale）和偏移（bias） 。</p>
<ul>
<li>.ktx 支持存储 原始纹理数据（RGBA8、RGB16F、RGBA32F…）；支持存储 压缩纹理（BCn / ASTC / ETC2 / PVRTC 等）；可以包含 Mipmap 层级、立方体贴图、3D 纹理。</li>
<li>设计目标就是 直接加载到 GPU，省去运行时转码。</li>
<li>优点：加载快（直接 GPU 原生格式）、支持压缩节省显存。</li>
<li>缺点：是容器，不是图像编辑格式；不适合美术直接使用。</li>
</ul>
</li>
<li>
<p>天空盒构造函数将 PBR 所需的三个关键纹理绑定到着色器（cube.vert, cube.frag）：绑定点 5: 环境贴图、绑定点 6: 辐照度贴图、绑定点 7: BRDF 查找表。注意这里 GLSkyboxRenderer 的三个纹理成员类型是自封装的 GLTexture，输入参数是目标纹理格式和文件名，内部会自动调用 glCreateTextures 创建纹理，并设置参数。这里特别说明一下对 GL_TEXTURE_CUBE_MAP 这种格式的处理。如果输入的图像 w=2h 则认为输入的是等距柱状投影。先把其转为 vertical cross 的十字图，再切成六个面。</p>
<ul>
<li>转为 vertical cross 的流程：
<ul>
<li>计算立方体每个面的边长 faceSize，以及目标“十字”图的尺寸。等距图横向相当于立方体 4 个侧面拼接，所以 faceSize = 宽度 / 4，目标图是 3 列 ×4 行的面排布。</li>
<li>预先定义六个面的左上角在“十字图”中的位置（想象二维平铺的十字图）（offset）。</li>
<li>逐个面、逐个像素遍历目标图：</li>
<li>把目标面内的像素坐标(i, j)转成该面对应的“立方体表面上的方向向量 P”（辅助函数 faceCoordsToXYZ，按面别和上下翻转做不同的轴映射）。</li>
<li>把三维方向 P 换成球面坐标，“经纬度”角度(theta 经度、phi 纬度)。</li>
<li>用等距柱状投影公式把(theta, phi)映射回源图像上的浮点坐标(Uf, Vf)。</li>
<li>在源图像上对(Uf, Vf)做双线性插值（取四邻像素加权平均），得到颜色。</li>
<li>把这颜色写到目标“十字图”对应的像素位置（考虑该面的 offset）。</li>
</ul>
</li>
<li>把十字图切成六个面的流程就是简单的找到每个面的角点坐标然后复制粘贴这个面的内容到目标图的某一层。</li>
</ul>
</li>
<li>
<p>构造函数<code>glCreateVertexArrays(1, &amp;dummyVAO_);</code>，析构函数<code>glDeleteVertexArrays(1, &amp;dummyVAO_);</code>。</p>
</li>
<li>
<p>GLSkyboxRenderer.draw()绑定 vao，禁止深度写入，渲染天空盒。</p>
</li>
<li>
<p>cube.vert: 两个数组，一个定义世界空间立方体的八个角点坐标，另一个定义了构成立方体的 36 个点（6 个面共 12 个三角形）的序号。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-type">int</span> idx = indices[<span class="hljs-built_in">gl_VertexID</span>];<br>  <span class="hljs-comment">// scale by 500.0 to make the cube visible</span><br>  <span class="hljs-built_in">gl_Position</span> = proj * view * <span class="hljs-type">vec4</span>(<span class="hljs-number">500.0</span> * pos[idx], <span class="hljs-number">1.0</span>);<br>  dir = pos[idx].xyz; <span class="hljs-comment">// 将立方体局部坐标作为方向向量输出到片段着色器(世界空间里的)</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>cube.frag</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> dir;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> out_FragColor;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span>=<span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">samplerCube</span> texture1; <span class="hljs-comment">// envMap_</span><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-comment">// 立方体贴图采样以向量方向作为查找键，硬件会按方向选择对应面并进行双线性过滤（向量是否单位化都可，采样器会处理）。</span><br>  <span class="hljs-comment">// 因为几何体本身经过 view 旋转，屏幕上每个像素对应到的插值 dir 会随相机旋转而改变，从而实现“天空随相机旋转”的效果，即便 dir 本身没乘以 view。</span><br>  out_FragColor = <span class="hljs-built_in">texture</span>(texture1, dir);<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>IBL 如何处理镜面和非镜面？</p>
<ul>
<li>漫反射（非镜面）IBL：用“辐照度立方体贴图”<strong>按世界法线 n 采样</strong>，得到环境的漫反射入射光，再乘以基底漫反射颜色 diffuseColor。</li>
<li>镜面反射 IBL：用“环境立方体贴图”<strong>按反射向量 reflection 与粗糙度选取 LOD 采样</strong>，得到环境高光，再<strong>乘以预积分 BRDF LUT</strong>（由 NdotV 和粗糙度索引），并按 specularColor 着色。</li>
<li>金属度-粗糙度模型：金属度越高，漫反射越小、镜面颜色越接近基底色；粗糙度越高，使用更低分辨率的 mip（更模糊）。</li>
</ul>
</li>
<li>
<p><strong>IBL 中加速的 trick</strong>？</p>
<ul>
<li>
<p>项目中已使用的 IBL 加速技巧</p>
<ul>
<li>预计算优化
<ul>
<li><strong>辐照度贴图预计算</strong>: 避免实时积分</li>
<li><strong>BRDF 查找表</strong>: 预计算 BRDF 积分，运行时只需 2D 纹理查找</li>
<li><strong>预滤波环境贴图</strong>: 根据粗糙度预计算不同 LOD 级别的环境贴图</li>
</ul>
</li>
<li>粗糙度感知 LOD 选择：根据材质粗糙度动态选择 mip 级别，粗糙表面使用低分辨率贴图。</li>
<li>启用立方体贴图无缝采样，避免面与面之间的接缝问题。</li>
</ul>
</li>
<li>
<p>其他常用的 IBL 加速技巧</p>
<ul>
<li>
<p>球谐函数 (Spherical Harmonics)</p>
<ul>
<li><strong>原理</strong>: 将环境光照分解为球谐函数系数，运行时重建</li>
<li><strong>优势</strong>: 内存占用小，计算快速，适合低频光照</li>
<li><strong>适用</strong>: 漫反射 IBL，移动端优化</li>
</ul>
</li>
<li>
<p>重要性采样 (Importance Sampling)</p>
<ul>
<li><strong>原理</strong>: 根据 BRDF 分布函数进行重要性采样，减少噪声</li>
<li><strong>优势</strong>: 提高收敛速度，减少采样数量</li>
<li><strong>实现</strong>: 在预计算阶段使用，运行时受益</li>
</ul>
</li>
<li>
<p>多级重要性采样 (MIS)</p>
<ul>
<li><strong>原理</strong>: 结合多种采样策略，平衡效率和准确性</li>
<li><strong>优势</strong>: 在预计算和运行时都能提高质量</li>
<li><strong>适用</strong>: 高质量渲染，离线烘焙</li>
</ul>
</li>
<li>
<p>压缩技术</p>
<ul>
<li><strong>BC6H/BC7</strong>: 压缩 HDR 立方体贴图</li>
<li><strong>ASTC</strong>: 移动端友好的压缩格式</li>
<li><strong>优势</strong>: 减少内存占用和带宽</li>
</ul>
</li>
<li>
<p>自适应采样</p>
<ul>
<li><strong>原理</strong>: 根据视角和材质特性动态调整采样质量</li>
<li><strong>优势</strong>: 在重要区域保持高质量，其他区域降低质量</li>
<li><strong>实现</strong>: 基于屏幕空间重要性或材质复杂度</li>
</ul>
</li>
<li>
<p>缓存和复用</p>
<ul>
<li><strong>原理</strong>: 缓存已计算的 IBL 结果，避免重复计算</li>
<li><strong>优势</strong>: 减少 GPU 计算负担</li>
<li><strong>实现</strong>: 帧间缓存，材质级缓存</li>
</ul>
</li>
<li>
<p>近似方法</p>
<ul>
<li><strong>原理</strong>: 使用数学近似简化复杂计算</li>
<li><strong>优势</strong>: 显著提高性能，质量损失可控</li>
<li><strong>示例</strong>: 使用简化的 Fresnel 函数，近似 BRDF</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3为什么-pbr-中的输入不能是-gamma-校正过的为什么要最后校正">（3）为什么 pbr 中的输入不能是 gamma 校正过的？为什么要最后校正？</h2>
<ul>
<li>显示器是非线性的：如果直接把线性空间颜色写入显示器，会显得灰蒙蒙的。解决办法是：在存储/显示时，对颜色做一个 gamma 压缩（通常是 1/2.2），保证在显示器上能正确显示。因此，显示/存储用 gamma 空间（sRGB）。计算/物理模拟 必须在线性空间。</li>
<li>PBR 本质上在做能量守恒的物理计算，这些运算必须是线性代数意义上的加减乘除，才能符合物理。如果把 gamma 校正过的输入（非线性值）拿来算，加法/乘法结果会被严重扭曲。</li>
</ul>
<h1 id="5-纹理">5. 纹理</h1>
<h2 id="1三维纹理">（1）三维纹理</h2>
<p>本质上是一个立体像素数组（Volume Texture），存储的是三维空间中的体素 (Voxel) 数据。采样坐标是 (u, v, w)，可以理解成在一个立方体里取点采样纹理。</p>
<h2 id="2mipmap-原理会增加开销吗">（2）mipmap 原理？会增加开销吗？</h2>
<ul>
<li>问题背景：
<ul>
<li>2D 纹理在缩小显示时（比如一个 1024×1024 贴图的物体在屏幕上只有 50×50 像素大）。</li>
<li>如果直接采样原图，会出现 摩尔纹、闪烁、aliasing。</li>
</ul>
</li>
<li>原理：
<ul>
<li>Mipmap = 多级纹理</li>
<li>在载入纹理时，GPU 自动生成一系列逐级缩小的版本。渲染时，如果一个像素在屏幕上对应很多 texel，GPU 会选择合适的 mipmap 层来采样。这样避免 aliasing，并提升缓存效率。</li>
</ul>
</li>
<li>会不会增加开销？
<ul>
<li>存储开销：一张纹理 + 所有 mipmap 的总大小 ≈ 原图的 4/3 左右。（因为：1+1/4+1/16+…≈4/3）。也就是说，显存占用多了 ~33%。</li>
<li>渲染性能：
<ul>
<li>采样更快：GPU 不必在渲染时从大纹理里跨越性采样（Cache 命中率提高）。</li>
<li>减少 aliasing（画质更稳定）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3mipmap-有哪些缺点如何精准采样">（3）mipmap 有哪些缺点？如何精准采样？</h2>
<ul>
<li>内存开销增加</li>
<li>Mipmap 在缩小纹理时，会预先做滤波（通常是 box filter / Gaussian-like）。所以远处物体纹理可能看起来 过于模糊，细节丢失。这种模糊在 斜视角 (grazing angle) 下尤其明显。</li>
<li>Mipmap 只能按“尺度”来存储，不考虑方向。例如，当一个矩形很斜着面对屏幕时，它在屏幕上投影是一个长条状，但 mipmap 只能 isotropic 缩小，无法针对长条优化。</li>
<li>GPU 在选择 mipmap 层时，不一定刚好对应某一层，可能在层与层之间。
<ul>
<li>Nearest Mipmap（直接选最近的一层，容易跳变）。</li>
<li>Trilinear Filtering（在两层之间插值，平滑过渡）。</li>
<li>Anisotropic Filtering（针对倾斜角度的采样优化，解决斜向模糊）。</li>
</ul>
</li>
<li>精确控制 LOD
<ul>
<li>默认 LOD 是 GPU 根据屏幕导数（dFdx/dFdy）计算的。</li>
<li>但在某些效果里（比如环境贴图、特殊材质），可能需要手动控制：
<ul>
<li>textureLod()：指定 mipmap 层级，不插值。</li>
<li>textureGrad()：传入自定义导数，精准控制采样范围。</li>
<li>textureBias()：在自动计算的 LOD 上加偏移（常用于调节锐度）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="410241000-的-rgba8-在显存存储占用的内存">（4）1024*1000 的 rgba8 在显存存储占用的内存</h2>
<p>RGBA8 = 8 bits/chan × 4 chans = 4 bytes/像素<br>
尺寸 1024 × 1000 -&gt; 像素数 1,024,000<br>
显存占用（不含 mipmap）：<br>
字节：1,024,000 × 4 = 4,096,000 B<br>
MB（十进制）：4.096 MB<br>
MiB（二进制）：3.90625 MiB<br>
如果开 mipmap，约为总大小 4/3。</p>
<h2 id="5导入一张很大的-png-需要在-cpu-gpu-做哪些操作">（5）导入一张很大的 png 需要在 cpu、gpu 做哪些操作</h2>
<h3 id="cpu-端"><strong>CPU 端</strong></h3>
<ul>
<li>
<p>PNG 是压缩格式（基于 DEFLATE + 滤波），不能直接上传给 GPU。</p>
</li>
<li>
<p>CPU 需要用库（如 libpng、stb_image）解码 -&gt; 得到 <strong>原始像素数据</strong>（比如 RGBA8）。</p>
</li>
<li>
<p><strong>可能的处理</strong></p>
<ul>
<li>转换颜色空间（sRGB → Linear）。</li>
<li>重新打包像素格式（比如 GPU 需要 BGRA8、DXT 压缩）。</li>
<li>生成 mipmap（有些引擎在 CPU 上生成，有些在 GPU 上生成）。</li>
</ul>
</li>
<li>
<p><strong>传输准备</strong></p>
<ul>
<li>把像素数据放到一块连续内存（通常对齐到 4/8/16 字节），方便 DMA 上传。</li>
</ul>
</li>
</ul>
<h3 id="gpu-端"><strong>GPU 端</strong></h3>
<ul>
<li>
<p><strong>创建纹理对象</strong></p>
<ul>
<li>在显存里分配一块区域，存储解码后的像素数据。</li>
<li>格式通常是 RGBA8、BC 压缩、或浮点格式（HDR）。</li>
</ul>
</li>
<li>
<p><strong>数据上传</strong></p>
<ul>
<li>CPU -&gt; GPU：通过显卡驱动调用（<code>glTexImage2D</code> / <code>vkCmdCopyBufferToImage</code> / <code>ID3D12Resource::UpdateSubresource</code>）。</li>
<li>一般走 PCIe，总线带宽有限（比如 PCIe 4.0 ×16 ≈ 32 GB/s），所以大纹理传输是个瓶颈。</li>
</ul>
</li>
<li>
<p><strong>GPU 处理</strong></p>
<ul>
<li>如果 CPU 没生成 mipmap，就可能在 GPU 上生成（如 OpenGL 的 <code>glGenerateMipmap</code>）。</li>
<li>有时 GPU 会做 <strong>tile-based re-layout</strong>（分块存储），优化缓存访问。</li>
</ul>
</li>
</ul>
<h3 id="大-png-的性能挑战">大 PNG 的性能挑战</h3>
<ul>
<li><strong>解码开销</strong>（CPU-bound）：PNG 解码比较慢，因为它是无损压缩，适合存储，不适合直接 runtime。</li>
<li><strong>上传带宽</strong>（PCIe-bound）：大图要搬很多数据到 GPU，可能卡加载。</li>
<li><strong>显存占用</strong>：比如 8192×8192 RGBA8 -&gt; 256 MB + mipmap。</li>
</ul>
<h2 id="6对于不透明-png-的导入有什么优化cpu-gpu">（6）对于不透明 png 的导入有什么优化？（cpu、gpu）</h2>
<p>很多 PNG 都是 <strong>RGBA8</strong>，但如果 alpha 通道其实没用（完全不透明），会带来冗余。</p>
<h3 id="cpu-端优化"><strong>CPU 端优化</strong></h3>
<ul>
<li>
<p><strong>检测 alpha 是否恒为 255</strong></p>
<ul>
<li>解码后扫描一遍，如果全是 255，就说明完全不透明。</li>
<li>可以只上传 <strong>RGB 格式</strong>，节省带宽和显存。</li>
</ul>
</li>
<li>
<p><strong>存储优化</strong></p>
<ul>
<li>不透明图可以转为更高效的格式，比如：
<ul>
<li><strong>RGB8 / BGR8</strong>（少 1/4 内存和带宽）。</li>
<li><strong>压缩格式</strong>：BC1 (DXT1)，不透明版本比 BC3 小一半。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="gpu-端优化"><strong>GPU 端优化</strong></h3>
<ul>
<li>
<p><strong>减少显存占用</strong></p>
<ul>
<li>用 24-bit RGB 纹理或压缩格式（BC1/DXT1、ETC1/ETC2-RGB、ASTC RGB）。</li>
<li>比 RGBA 节省 25%～ 50% 显存。</li>
</ul>
</li>
<li>
<p><strong>渲染优化</strong></p>
<ul>
<li>不透明纹理 -&gt; 可以直接用 <strong>不透明渲染管线</strong>：
<ul>
<li>关闭 alpha blend（少一次片段混合计算）。</li>
<li>Early-Z 测试更高效（可以提前丢弃被遮挡片元）。</li>
</ul>
</li>
<li>对 GPU 而言，不透明物体渲染比半透明快很多。</li>
</ul>
</li>
</ul>
<h2 id="7给一张纹理接下来的流程是怎样的封装了哪些接口">（7）给一张纹理接下来的流程是怎样的？封装了哪些接口？</h2>
<p>创建纹理时传递的数据格式是什么？</p>
<p>给一张纹理：GLTexture 加载/创建并生成 bindless 句柄 -&gt; 写入 MaterialDescription 为 MaterialData（句柄替换）-&gt; 上传材质 SSBO 到 GPU -&gt; 绘制时由实例的 matIdx 选择对应 MaterialData -&gt; 片元用 bindless 句柄直接取样 -&gt; PBR 合成输出。</p>
<p>PS:<br>
懒加载版本：先用白色 dummyTexture_占位 -&gt; updateMaterials()写入句柄 -&gt; 后台 stbi_load 读原图 -&gt; 主线程调用 uploadLoadedTextures()创建 GLTexture(w,h,img) -&gt; 再 updateMaterials()更新句柄并上传 SSBO</p>
<h1 id="6-场景结构">6. 场景结构</h1>
<h2 id="1序列化与反序列化">（1）序列化与反序列化</h2>
<h3 id="为什么需要序列化动机">为什么需要序列化？（动机）</h3>
<p>直接在运行时加载和解析 .obj 等格式虽然可行，但对于大型复杂场景存在明显缺点。</p>
<ul>
<li>加载速度：相比于解析复杂的文本或 JSON 格式，直接从<strong>二进制文件</strong>读取预处理好的数据块要快得多。</li>
<li>数据优化：序列化过程不仅仅是格式转换，更是一个重要的优化环节。在 SceneConverter 工具中，执行了多项针对引擎渲染流程的优化：
<ul>
<li>数据结构转换：将传统的、基于指针的场景图转换为对 GPU 更友好的数据导向设计结构（如“长子-右兄弟”层级表示）。</li>
<li>网格优化：使用 MeshOptimizer 等库来优化顶点缓存、减少过度绘制，并生成 LOD（Level of Detail）。</li>
<li>数据合并：将多个使用相同材质的小网格合并成一个大的单一网格，以减少运行时的绘制调用（Draw Calls）次数 。</li>
<li>材质与纹理处理：转换和降采样纹理，并将材质参数打包成紧凑的 GPU 友好结构 。</li>
</ul>
</li>
</ul>
<h3 id="总览">总览</h3>
<ul>
<li>网格 <code>.meshes</code>：几何体数据（Mesh 描述表 + 包围盒 + 索引块 + 顶点块）</li>
<li>材质 <code>.materials</code>：<code>MaterialDescription</code> 数组 + 纹理文件名字符串表</li>
<li>场景 <code>.scene</code>：节点变换数组 + 层级表 + 节点到网格/材质映射 + 可选名称块</li>
</ul>
<h3 id="网格-mesh-数据">网格 Mesh 数据</h3>
<p><strong>See src/scene/VtxData(.h/.cpp)</strong></p>
<ul>
<li>
<p>关键结构</p>
<ul>
<li><code>MeshFileHeader</code>：记录 mesh 数量、数据块偏移、索引与顶点块字节大小</li>
<li><code>Mesh</code>：每个网格的 LOD 与流偏移、索引偏移、顶点偏移、顶点数等</li>
<li><code>MeshData</code>：承载 <code>meshes_</code>、<code>boxes_</code>、<code>indexData_</code>(uint32)、<code>vertexData_</code>(float)</li>
</ul>
</li>
<li>
<p>序列化顺序（写）</p>
<ul>
<li>文件头 <code>MeshFileHeader</code></li>
<li><code>Mesh</code> 数组</li>
<li><code>BoundingBox</code> 数组</li>
<li>索引数据块（按字节）</li>
<li>顶点数据块（按字节）</li>
</ul>
</li>
<li>
<p>反序列化顺序（读）</p>
<ul>
<li>首先读取 MeshFileHeader，了解文件概况。</li>
<li>接着读取 meshCount 个 Mesh 结构体，得到所有网格的“目录”。</li>
<li>然后一次性地将 indexDataSize 字节的数据读入 indexData 向量，并将 vertexDataSize 字节的数据读入 vertexData 向量。</li>
<li>当需要渲染某个具体的网格（例如 <code>meshes_[i]</code>）时，程序会：查看它的 lodOffset 和 streamOffset。使用这些偏移量作为“指针”，从巨大的 indexData 和 vertexData 向量中找到只属于这个网格的数据的起始位置。将这部分数据上传到 GPU 或进行其他处理。</li>
</ul>
</li>
</ul>
<h3 id="材质-materials">材质 Materials</h3>
<p><strong>See src/scene/Material(.h/.cpp)</strong></p>
<ul>
<li>数据内容：<code>MaterialDescription</code> 定长数组 + 纹理文件名字符串表</li>
<li>序列化（写）
<ul>
<li>先写材质数量 + 素材数组；再写字符串表：字符串数、每条长度、内容（含结尾 ‘\0’）</li>
</ul>
</li>
<li>反序列化（读）
<ul>
<li>读数量、数组，再读字符串表（按长度+1 读取到缓冲区构造字符串）</li>
</ul>
</li>
</ul>
<h3 id="场景-scene节点层级映射名字">场景 Scene（节点/层级/映射/名字）</h3>
<p><strong>See src/scene/(Scene.h/.cpp)</strong></p>
<ul>
<li>数据内容：
<ul>
<li>节点数 <code>sz</code></li>
<li><code>localTransform_</code> 数组（sz 个 mat4）</li>
<li><code>globalTransform_</code> 数组（sz 个 mat4）</li>
<li><code>hierarchy_</code> 数组（sz 个 <code>Hierarchy</code>）</li>
<li>映射表：<code>materialForNode_</code>、<code>meshes_</code>（键值对序列化）</li>
<li>可选：<code>nameForNode_</code> + <code>names_</code> 字符串表 + <code>materialNames_</code> 字符串表</li>
</ul>
</li>
<li>映射表格式：先写 uint32 计数（注意是“uint32 个数”，等于键值对数量 ×2），随后写 [k0, v0, k1, v1, …]</li>
</ul>
<h3 id="运行时装载与绑定">运行时装载与绑定</h3>
<p><strong>See src/core/(GLSceneDataLazy.h/.cpp)</strong></p>
<ul>
<li>加载顺序：先 <code>loadMeshData</code> -&gt; 再 <code>loadScene</code> -&gt; 再 <code>loadMaterials</code></li>
<li>关联：根据场景中的 <code>meshes_</code>、<code>materialForNode_</code> 生成绘制条目 <code>shapes_</code>，并把材质纹理索引替换为 GPU bindless 句柄</li>
</ul>
<h3 id="注意点与局限">注意点与局限</h3>
<ul>
<li>二进制直接按本机端序/对齐写入，跨平台兼容性与版本演进需自行管理（目前未存版本号，<code>magicValue</code>未校验）</li>
<li><code>MaterialDescription</code> 对齐按 16 字节检查，需保持编译器一致的打包策略</li>
<li><code>saveMap/loadMap</code> 的大小字段是“uint32 数量”而非“键值对数量”</li>
<li>错误处理多用 <code>assert/exit</code>，生产工具链需补充健壮性与文件校验</li>
</ul>
<h2 id="2场景树结构">（2）场景树结构</h2>
<ul>
<li>场景加载与转换:
<ul>
<li>当项目从文件（如 .obj 或 .gltf）加载 3D 模型时，会使用像 Assimp 这样的库来解析原始数据。</li>
<li>SceneConverter 工具中的 traverse 函数 会遍历 Assimp 加载的节点层级，并构建项目自定义的“长子-右兄弟”树结构，将其存储在 Hierarchy 数组中。这是场景树结构的创建阶段。</li>
</ul>
</li>
<li>计算全局变换矩阵:
<ul>
<li>场景中的每个物体都有一个相对于父节点的局部变换矩阵（localTransform*）。为了在世界空间中正确地渲染物体，必须计算出每个节点的全局变换矩阵（globalTransform*）。</li>
<li>recalculateGlobalTransforms 函数利用这个树结构来高效地完成计算。它从根节点开始，逐层向下遍历。对于每一层的节点，它可以通过 parent_ 索引轻松找到其父节点的、已经计算好的全局变换矩阵，然后乘以自身的局部变换矩阵，得到自己的全局变换矩阵。</li>
</ul>
</li>
<li>生成渲染列表:
<ul>
<li>GPU 渲染时，最高效的方式是处理一个扁平、线性的数据列表，而不是一个复杂的树。</li>
<li>因此，CPU 会遍历这个树结构，将所有带有网格（Mesh）和材质（Material）的可渲染节点提取出来，生成一个线性的**“形状列表”**（即 DrawData 数组）。</li>
<li>这个形状列表中的每一项都包含了渲染一个物体所需的所有信息索引（网格索引、材质索引、变换矩阵索引等），可以直接用于驱动 GPU 的间接绘制 (Indirect Drawing)。</li>
</ul>
</li>
<li>场景编辑与动态修改:
<ul>
<li>当需要对场景进行修改时，例如删除一个节点，项目中的 deleteSceneNodes 函数会直接操作这个 Hierarchy 数组。它会通过修改节点的 firstChild* 和 nextSibling* 链接来断开并移除节点及其所有子节点。</li>
<li>同样，在合并场景（如合并 Bistro 的内部和外部场景）时，mergeScenes 函数 也是通过操纵这个树结构，将一个场景的根节点作为另一个场景的子节点来连接它们。</li>
</ul>
</li>
<li>场景树结构是在 CPU 端 使用的、用于管理和预处理场景的工具，它的主要作用是：
<ul>
<li>管理层级关系：清晰地表示谁是谁的父节点/子节点。</li>
<li>计算变换：高效地计算出每个物体的最终世界位置。</li>
<li>生成渲染数据：作为中间表示，用于生成最终提交给 GPU 的、扁平化的渲染指令列表。</li>
<li>GPU 和着色器最终处理的是这个树结构经过 CPU 运算后得到的结果（例如，全局变换矩阵数组和形状列表），而不是树结构本身。</li>
</ul>
</li>
</ul>
<h2 id="2渲染场景是怎么组织的有哪些节点">（2）渲染场景是怎么组织的？有哪些节点？</h2>
<h3 id="场景图组织">场景图组织</h3>
<p>这部分负责维护节点之间的层级关系和变换。</p>
<ul>
<li>
<p>层级 (Hierarchy)</p>
<ul>
<li>
<p>场景的层级关系通过一种**“长子-右兄弟”（First Child – Next Sibling）**的表示法来存储，它将任意树结构转换为二叉树形式，从而避免了在每个节点中存储一个动态大小的子节点列表。</p>
</li>
<li>
<p>每个节点的层级信息存储在一个 Hierarchy 结构体数组中，包含以下字段：</p>
<ul>
<li><code>parent_</code>: 父节点的索引 。</li>
<li><code>firstChild_</code>: 第一个子节点的索引 。</li>
<li><code>nextSibling_</code>: 同级的下一个兄弟节点的索引 。</li>
<li><code>level_</code>: 节点在层级中的深度 。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变换 (Transforms)</p>
<ul>
<li>节点的空间位置和方向由变换矩阵表示，并存储在两个独立的数组中：
<ul>
<li><code>localTransforms_</code>: 存储每个节点相对于其父节点的局部变换矩阵 。</li>
<li><code>globalTransforms_</code>: 存储每个节点计算后的全局（世界空间）变换矩阵 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="渲染数据组织">渲染数据组织</h3>
<p>这部分负责将场景中的可渲染对象组织成 GPU 可以高效处理的形式。</p>
<ul>
<li>
<p>节点与数据的映射</p>
<ul>
<li>场景中的节点并不直接包含网格或材质数据。相反，它们通过映射表（unordered_map）来关联这些资源：
<ul>
<li><code>meshes_</code>: 一个将节点索引映射到网格索引的哈希表。</li>
<li><code>materialForNode_</code>: 一个将节点索引映射到材质索引的哈希表。</li>
</ul>
</li>
<li>这种方式使得没有几何体或材质的节点（例如，仅用于组织层级的空节点）不会占用不必要的内存。</li>
</ul>
</li>
<li>
<p>形状列表 (Shape List / DrawData)</p>
<ul>
<li>场景图本身不直接用于驱动 GPU 渲染。为了实现高效的渲染（特别是间接绘制），项目会遍历场景图并生成一个扁平化的**“形状列表”** 。</li>
<li>这个列表中的每一项都是一个 DrawData 结构体，它聚合了渲染一个独立物体所需的所有信息索引 ：
<ul>
<li>meshIndex: 网格索引</li>
<li>materialIndex: 材质索引</li>
<li>LOD: 使用的细节层次（Level of Detail）索引</li>
<li>indexOffset 和 vertexOffset: 在全局顶点和索引缓冲区中的偏移量</li>
<li>transformIndex: 在全局变换矩阵数组中的索引</li>
</ul>
</li>
<li>这个形状列表是最终驱动渲染的核心，GPU 可以高效地处理这个紧凑、线性的数据结构。</li>
</ul>
</li>
<li>
<p>调试节点</p>
<ul>
<li>为了方便调试，场景还可以包含与节点名称相关的组件 ：
<ul>
<li><code>names_</code>: 存储所有节点名称字符串的数组 。</li>
<li><code>nameForNode_</code>: 将节点索引映射到其名称索引的哈希表 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<p>总的来说，场景组织分为两个层次：</p>
<ul>
<li>逻辑层：一个数据导向的场景图，通过多个平行的数组和哈希表来高效地管理节点的层级、变换和与网格/材质的关联。</li>
<li>渲染层：一个扁平化的 Shape List，它是从场景图中派生出来的，专门为 GPU 的高效渲染（如间接绘制）而设计。</li>
</ul>
<h2 id="3大型场景中如何避免循环引用不是加-weakptr-这么简单">（3）大型场景中如何避免循环引用？不是加 weakptr 这么简单</h2>
<h1 id="7-hdr">7. hdr</h1>
<p>主要解决 LDR 无法直接展示真实世界光照强度的问题。通过以下步骤实现：</p>
<ul>
<li><strong>在高动态范围下渲染场景</strong>：首先将场景渲染到一个能存储超出 [0, 1] 范围颜色值的浮点格式纹理中。</li>
<li><strong>分析并处理图像</strong>：计算场景的平均亮度，并提取高光区域用于辉光（Bloom）效果。</li>
<li><strong>光照适应</strong>：模拟人眼从亮处到暗处或反之的适应过程，平滑地调整曝光。</li>
<li><strong>色调映射</strong>：最后，将 HDR 图像根据计算出的曝光值和辉光效果，智能地压缩回显示器可以正常显示的 LDR 范围。</li>
</ul>
<h3 id="第-1-趟-场景渲染到-hdr-帧缓冲">第 1 趟: 场景渲染到 HDR 帧缓冲</h3>
<ul>
<li><strong>目标</strong>：生成一张包含完整光照信息、颜色值可能远超 1.0 的 HDR 图像。</li>
<li><strong>实现</strong>：
<ul>
<li>创建一个离屏的帧缓冲对象（<code>GLFramebuffer</code>）。</li>
<li>这个 FBO 的颜色附件（Color Attachment）使用一个浮点纹理格式，具体为 <code>GL_RGBA16F</code>。这使得渲染结果可以保留场景中极亮区域（如太阳、灯光）的真实强度信息，而不会像普通 8 位纹理那样被截断在 1.0。</li>
<li>将整个 3D 场景正常渲染到这个 HDR FBO 中。</li>
</ul>
</li>
</ul>
<h3 id="第-2-趟-辉光效果生成">第 2 趟: 辉光效果生成</h3>
<p>辉光效果模拟了强光在摄像机镜头中产生的弥散光晕。由两个子步骤完成：</p>
<ul>
<li>
<p><strong>2a. 提取高光区域 (Bright Pass)</strong></p>
<ul>
<li>渲染一个全屏四边形，输入是第 1 趟生成的 HDR 场景纹理。</li>
<li>运行一个片段着色器（<code>BrightPass.frag</code>），计算每个像素的亮度。</li>
<li><strong>只保留亮度超过某个阈值（例如 1.0）的像素</strong>，其余像素变为黑色。结果输出到一个新的“高光”纹理中。</li>
</ul>
</li>
<li>
<p><strong>2b. 模糊高光 (Blur Passes)</strong></p>
<ul>
<li>为了让高光区域产生柔和的光晕效果，对其进行模糊处理。</li>
<li>采用<strong>可分离高斯模糊</strong>，通过<strong>乒乓操作（ping-pong）<strong>在两个临时的<code>bloom</code> FBO 之间交替进行</strong>水平模糊</strong>和<strong>垂直模糊</strong>，迭代多次（4 次）以获得更大范围的模糊效果。</li>
<li>水平模糊为例：</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> gaussFilter[<span class="hljs-number">11</span>] = <span class="hljs-type">vec2</span>[](<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-5.0</span>,  <span class="hljs-number">3.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-4.0</span>,  <span class="hljs-number">6.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-3.0</span>, <span class="hljs-number">10.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-2.0</span>, <span class="hljs-number">15.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-1.0</span>, <span class="hljs-number">20.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.0</span>, <span class="hljs-number">25.0</span>/<span class="hljs-number">133.0</span>),  <span class="hljs-comment">// 中心权重最大</span><br>    <span class="hljs-type">vec2</span>( <span class="hljs-number">1.0</span>, <span class="hljs-number">20.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>( <span class="hljs-number">2.0</span>, <span class="hljs-number">15.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>( <span class="hljs-number">3.0</span>, <span class="hljs-number">10.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>( <span class="hljs-number">4.0</span>,  <span class="hljs-number">6.0</span>/<span class="hljs-number">133.0</span>),<br>    <span class="hljs-type">vec2</span>( <span class="hljs-number">5.0</span>,  <span class="hljs-number">3.0</span>/<span class="hljs-number">133.0</span>)<br>);<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> scale = <span class="hljs-number">1.0</span> / <span class="hljs-built_in">textureSize</span>(texSSAO, <span class="hljs-number">0</span>).x; <span class="hljs-comment">// X方向像素大小</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">// 只在X方向偏移，Y方向保持不变</span><br>        <span class="hljs-type">vec2</span> coord = <span class="hljs-type">vec2</span>(uv.x + gaussFilter[i].x * scale, uv.y);<br>        color += <span class="hljs-built_in">textureLod</span>(texSSAO, coord, <span class="hljs-number">0</span>).rgb * gaussFilter[i].y;<br>    &#125;<br><br>    outColor = <span class="hljs-type">vec4</span>(color, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第-3-趟-平均亮度计算与光照适应">第 3 趟: 平均亮度计算与光照适应</h3>
<p>模拟人眼根据环境亮度自动调整“曝光”的生理现象。</p>
<ul>
<li>
<p><strong>3a. 计算当前帧平均亮度</strong></p>
<ul>
<li>将第 1 趟的 HDR 场景图渲染到一个非常小的（例如 64x64 像素）、<strong>单通道</strong>浮点格式（<code>GL_R16F</code>）的<code>luminance</code>纹理中（GPU 硬件自动处理降采样）。在渲染时，着色器（<code>ToLuminance.frag</code>）将 RGB 颜色转换为亮度值。</li>
<li>为这张小亮度图<strong>生成完整的 Mipmap 链</strong>。由于每一级 Mipmap 都是上一级的降采样，最终<strong>1x1 大小的顶层 Mipmap</strong>就近似存储了整个场景的<strong>平均亮度值</strong>。</li>
</ul>
</li>
<li>
<p><strong>3b. 光照适应 (Light Adaptation)</strong></p>
<ul>
<li>如果亮度变化是瞬时的，会显得不自然。为了模拟人眼逐渐适应的过程，项目使用了一个<strong>计算着色器 (Compute Shader)</strong> (<code>Adaptation.comp</code>)。</li>
<li>该着色器使用两个 1x1 的“乒乓”纹理，一个存储<strong>上一帧</strong>的适应后亮度，一个用于写入<strong>当前帧</strong>的适应后亮度。</li>
<li>它读取上一帧的亮度和当前帧的平均亮度，并根据一个<code>adaptationSpeed_</code>参数，平滑地在这两者之间进行插值，模拟出亮度逐渐变化的效果。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">local_size_y</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">local_size_z</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span>;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">rgba16f</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">readonly</span>  <span class="hljs-type">image2D</span> imgLuminancePrev;  <span class="hljs-comment">// 上一帧亮度</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">rgba16f</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">readonly</span>  <span class="hljs-type">image2D</span> imgLuminanceCurr;  <span class="hljs-comment">// 当前帧亮度</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">rgba16f</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">writeonly</span> <span class="hljs-type">image2D</span> imgLuminanceAdapted; <span class="hljs-comment">// 输出适应亮度</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">float</span> lumPrev = <span class="hljs-built_in">imageLoad</span>(imgLuminancePrev, <span class="hljs-type">ivec2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).x;<br>    <span class="hljs-type">float</span> lumCurr = <span class="hljs-built_in">imageLoad</span>(imgLuminanceCurr, <span class="hljs-type">ivec2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).x;<br><br>    <span class="hljs-comment">// 指数平滑算法，模拟人眼适应</span><br>    <span class="hljs-type">float</span> newAdaptation = lumPrev + (lumCurr - lumPrev) * (<span class="hljs-number">1.0</span> - <span class="hljs-built_in">pow</span>(<span class="hljs-number">0.98</span>, <span class="hljs-number">30.0</span> * adaptationSpeed));<br><br>    <span class="hljs-comment">// 输出到1x1像素</span><br>    <span class="hljs-built_in">imageStore</span>(imgLuminanceAdapted, <span class="hljs-type">ivec2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(newAdaptation), <span class="hljs-number">1.0</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第-4-趟-最终合成与色调映射">第 4 趟: 最终合成与色调映射</h3>
<p>最后将所有中间结果合并，并转换成显示器可以输出的最终图像。</p>
<ul>
<li><strong>目标</strong>：将 HDR 图像转换为 LDR 图像。</li>
<li><strong>实现</strong>：
<ul>
<li>渲染一个全屏四边形到默认的屏幕帧缓冲。</li>
<li>片段着色器（<code>HDR.frag</code>）接收多个输入：
<ul>
<li>第 1 趟的<strong>原始 HDR 场景纹理</strong>。</li>
<li>第 2 趟的<strong>最终模糊后的辉光纹理</strong>。</li>
<li>第 3 趟的<strong>经过光照适应后的 1x1 平均亮度纹理</strong>。</li>
</ul>
</li>
<li>着色器内部执行：
<ul>
<li><strong>曝光调整</strong>：根据适应后的平均亮度和一个可调的<code>exposure</code>参数，对 HDR 场景颜色进行缩放。</li>
<li><strong>色调映射</strong>：使用 <strong>Extended Reinhard</strong> 色调映射算子，将经过曝光调整的、范围极广的 HDR 颜色值，非线性地压缩到[0, 1]的 LDR 范围内。<code>maxWhite</code>参数控制白点位置。</li>
<li><strong>效果合成</strong>：将经过色调映射的场景颜色与辉光纹理的颜色（按<code>bloomStrength</code>缩放）相加，得到最终的输出颜色。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>PS: 常见色调映射算法</strong></p>
<ul>
<li>全局算子（Global Operators）<br>
对图像中的所有像素应用完全相同的变换函数，不考虑像素的邻域信息。它们计算速度快，实现简单，是实时应用（如游戏）中的主流选择。
<ul>
<li>a. Reinhard Operator
<ul>
<li>最经典和基础的色调映射算子之一。它通过一个简单的非线性公式，模拟人眼对光线的非线性响应，将 HDR 值映射到[0, 1]的 LDR 范围。</li>
<li>核心思想: 简单地将颜色值除以 1 + 颜色值。</li>
<li>特点: 实现非常简单，效果自然，能够有效防止高光区域的过度饱和与。但缺点是可能会导致图像整体对比度下降，画面显得有些“灰”。后续有引入“白点”参数的改进版，以更好地控制最亮区域的映射。</li>
</ul>
</li>
<li>b. Filmic Tone Mapping (电影质感色调映射)
<ul>
<li>模仿胶片电影的色彩和光线响应曲线，通常能产生更具艺术感和视觉吸引力的效果。</li>
<li>核心思想: 使用“S”形曲线（Sigmoid curve）进行映射。这种曲线的特点是在两端（极暗和极亮区域）斜率平缓，能够柔和地压缩高光和暗部细节，而在中间调区域保持较好的对比度。</li>
<li>著名实现:
<ul>
<li>Uncharted 2: “Hejl &amp; Burgess-Dawson”: 由《神秘海域 2》的开发团队提出，在游戏界非常流行。它提供了一个效果出色且性能高效的电影质感映射曲线，能够很好地处理高光部分的细节，并带来鲜明的色彩观感。</li>
<li>ACES (Academy Color Encoding System): 由美国电影艺术与科学学院推出的色彩管理系统，旨在标准化影视制作流程中的色彩。ACES 提供了一套标准的色调映射变换（RRT 和 ODT），其效果被认为是行业“黄金标准”。它的色彩还原非常精确，对比度自然，能够产生极其逼真的电影级画面。在高端游戏和影视渲染中被广泛采用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>局部算子（Local Operators）
<ul>
<li>局部算子在处理每个像素时，会考虑其周围邻域像素的信息。这类算法通常能保留更多的局部细节和对比度，效果更出色，但计算成本也更高。</li>
<li>a. Photographic Tone Reproduction (摄影色调再现)
<ul>
<li>由 Reinhard 等人在 2002 年提出的另一著名算法，它模拟了传统摄影师在暗房中通过“加光”（Dodging）和“减光”（Burning）技术来调整照片局部明暗的技巧。</li>
<li>核心思想: 算法会估算每个像素点的局部亮度，并根据这个局部亮度来调整该像素的映射方式。例如，一个暗部区域中的亮像素会被保留，而一个亮部区域中的暗像素也会被保留，从而极大地提升了画面的局部对比度和细节。</li>
<li>特点: 效果非常出色，细节保留完好。主要缺点是计算量大，需要对图像进行高斯模糊等操作来估算局部亮度，在实时渲染中应用较少，更多用于离线渲染和图像处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="8-glsl">8. glsl</h1>
<h2 id="1手写判断一个点在正方形内外">（1）手写判断一个点在正方形内/外</h2>
<ul>
<li>在 GLSL 里，把正方形想成 <strong>轴对齐、中心在原点、边长为 2</strong> 的最简单情况：</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">bool</span> inside = <span class="hljs-built_in">all</span>(<span class="hljs-built_in">lessThan</span>(<span class="hljs-built_in">abs</span>(P), <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>)));<br></code></pre></td></tr></table></figure>
<p>解释</p>
<ul>
<li>
<p><code>abs(P)</code> 把坐标取绝对值。</p>
</li>
<li>
<p><code>vec2(1.0)</code> 定义半边长 1（总边长 2）。</p>
</li>
<li>
<p><code>lessThan</code> 逐分量返回 bvec2，<code>all</code> 把两个分量 AND 起来。</p>
</li>
<li>
<p><code>inside</code> = true 表示点在正方形内，false 表示在外。</p>
</li>
<li>
<p>如果正方形 <strong>中心在 center、边长为 size</strong>，则：</p>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">bool</span> inside = <span class="hljs-built_in">all</span>(<span class="hljs-built_in">lessThan</span>(<span class="hljs-built_in">abs</span>(P - center), <span class="hljs-type">vec2</span>(size * <span class="hljs-number">0.5</span>)));<br></code></pre></td></tr></table></figure>
<ul>
<li>旋转/任意矩形<br>
用两条局部基向量 <code>e1</code>, <code>e2</code> 和中心 <code>c</code>：</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> d = P - c;<br><span class="hljs-type">float</span> u = <span class="hljs-built_in">dot</span>(d, e1) / <span class="hljs-built_in">dot</span>(e1, e1);<br><span class="hljs-type">float</span> v = <span class="hljs-built_in">dot</span>(d, e2) / <span class="hljs-built_in">dot</span>(e2, e2);<br><span class="hljs-type">bool</span> inside = (<span class="hljs-built_in">abs</span>(u) &lt;= <span class="hljs-number">1.0</span>) &amp;&amp; (<span class="hljs-built_in">abs</span>(v) &lt;= <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>
<h1 id="9-剔除技术">9. 剔除技术</h1>
<h2 id="1视锥体剔除cpugpu">（1）视锥体剔除（cpu/gpu）</h2>
<p>视锥体剔除的目的是确定场景中的哪些部分位于摄像机的可见区域（即视锥体）内，从而避免将视锥体外的不可见物体提交给 GPU 进行渲染，以节省性能。</p>
<h3 id="cpu-视锥体剔除的做法">CPU 视锥体剔除的做法</h3>
<ul>
<li>
<p>提取视锥体信息：</p>
<ul>
<li>
<p>首先，从摄像机的视图-投影矩阵中提取出视锥体的 6 个平面（左、右、上、下、近、远）和 8 个角点。</p>
<ul>
<li>
<p>提取视锥体的 6 个平面</p>
<ul>
<li>核心原理：一个点如果在视锥体内，那么它在经过视图-投影矩阵变换后得到的<strong>裁剪空间坐标 (Clip Space Coordinates)</strong> <code>(x_c, y_c, z_c, w_c)</code> 必须满足以下条件：
<ul>
<li><code>-w_c &lt;= x_c &lt;= w_c</code></li>
<li><code>-w_c &lt;= y_c &lt;= w_c</code></li>
<li><code>-w_c &lt;= z_c &lt;= w_c</code></li>
</ul>
</li>
<li>这六个不等式实际上就定义了视锥体的六个边界平面。例如，<code>w_c + x_c &gt;= 0</code> 定义了左平面，<code>w_c - x_c &gt;= 0</code> 定义了右平面，以此类推。一个世界空间中的点 <code>P_w = (x_w, y_w, z_w, 1)</code> 变换到裁剪空间是通过乘以视图-投影矩阵 <code>VP</code> 完成的： <code>P_c = VP * P_w</code>。如果我们把 <code>VP</code> 矩阵按行展开，那么 <code>x_c</code> 就是 <code>P_w</code> 与 <code>VP</code> 矩阵第一行的点积，<code>w_c</code> 就是 <code>P_w</code> 与第四行的点积。所以，左平面的方程 <code>w_c + x_c &gt;= 0</code> 就可以写成 <code>dot(row_4, P_w) + dot(row_1, P_w) &gt;= 0</code>，即 <code>dot(row_4 + row_1, P_w) &gt;= 0</code>。向量 <code>row_4 + row_1</code> 就定义了这个平面。</li>
<li><code>getFrustumPlanes</code> 函数正是基于这个原理实现的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getFrustumPlanes</span><span class="hljs-params">(glm::mat4 vp, glm::vec4* planes)</span> </span>&#123;<br>    <span class="hljs-comment">// 将矩阵转置，以便按列访问原始的行</span><br>    vp = glm::<span class="hljs-built_in">transpose</span>(vp);<br>    <span class="hljs-comment">// 左平面: vp[3] (w分量) + vp[0] (x分量)</span><br>    planes[<span class="hljs-number">0</span>] = <span class="hljs-built_in">vec4</span>(vp[<span class="hljs-number">3</span>] + vp[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 右平面: vp[3] (w分量) - vp[0] (x分量)</span><br>    planes[<span class="hljs-number">1</span>] = <span class="hljs-built_in">vec4</span>(vp[<span class="hljs-number">3</span>] - vp[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 底平面: vp[3] (w分量) + vp[1] (y分量)</span><br>    planes[<span class="hljs-number">2</span>] = <span class="hljs-built_in">vec4</span>(vp[<span class="hljs-number">3</span>] + vp[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 顶平面: vp[3] (w分量) - vp[1] (y分量)</span><br>    planes[<span class="hljs-number">3</span>] = <span class="hljs-built_in">vec4</span>(vp[<span class="hljs-number">3</span>] - vp[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 近平面: vp[3] (w分量) + vp[2] (z分量)</span><br>    planes[<span class="hljs-number">4</span>] = <span class="hljs-built_in">vec4</span>(vp[<span class="hljs-number">3</span>] + vp[<span class="hljs-number">2</span>]);<br>    <span class="hljs-comment">// 远平面: vp[3] (w分量) - vp[2] (z分量)</span><br>    planes[<span class="hljs-number">5</span>] = <span class="hljs-built_in">vec4</span>(vp[<span class="hljs-number">3</span>] - vp[<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终得到的 <code>planes</code> 数组中的每个 <code>vec4</code> 都代表一个平面方程 <code>Ax + By + Cz + D = 0</code>，可以直接用于判断点是否在平面的内侧。</p>
</li>
<li>
<p>提取视锥体的 8 个角点</p>
<ul>
<li>核心原理：视锥体在<strong>规范化设备坐标 (Normalized Device Coordinates - NDC)</strong> 空间中是一个标准的立方体，其 8 个角点的坐标范围是从 <code>(-1, -1, -1)</code> 到 <code>(1, 1, 1)</code>。那么，只要将这 8 个 NDC 空间中的角点坐标<strong>反向变换</strong>回世界空间，就能得到视锥体在世界空间中的 8 个角点。这个反向变换正是通过乘以<strong>视图-投影矩阵的逆矩阵 (Inverse View-Projection Matrix)</strong> 来实现的。</li>
<li><code>getFrustumCorners</code> 基于这一原理实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getFrustumCorners</span><span class="hljs-params">(glm::mat4 vp, glm::vec4* points)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 定义NDC空间中的8个角点</span><br>    <span class="hljs-type">const</span> vec4 corners[] = &#123;<br>        <span class="hljs-built_in">vec4</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">vec4</span>( <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>),<br>        <span class="hljs-built_in">vec4</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">vec4</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>),<br>        <span class="hljs-built_in">vec4</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">vec4</span>( <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>        <span class="hljs-built_in">vec4</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">vec4</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    &#125;;<br><br>    <span class="hljs-comment">// 2. 计算视图-投影矩阵的逆矩阵</span><br>    <span class="hljs-type">const</span> glm::mat4 invVP = glm::<span class="hljs-built_in">inverse</span>(vp);<br><br>    <span class="hljs-comment">// 3. 遍历每个NDC角点，将其变换回世界空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-type">const</span> vec4 q = invVP * corners[i];<br>        <span class="hljs-comment">// 4. 进行透视除法 (w分量归一化)，得到最终的世界坐标</span><br>        points[i] = q / q.w;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>执行两阶段剔除测试：</p>
<ul>
<li>遍历场景中每一个需要渲染的物体（在书中是通过遍历间接绘制命令列表来实现的）。</li>
<li>对于每一个物体，获取其预先计算好的、经过世界变换的轴对齐包围盒 (AABB)。</li>
<li>执行 isBoxInFrustum 函数进行测试 ，该函数包含两个阶段：
<ul>
<li>阶段一（盒在视锥体外？）：检查包围盒的 8 个顶点是否完全位于视锥体任意一个平面的外侧。如果是，则该包围盒不可见 。</li>
<li>阶段二（视锥体在盒外？）：检查视锥体的 8 个角点是否完全位于包围盒任意一个平面的外侧。如果是，则该包围盒也不可见 。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>只有当一个包围盒通过了这两个阶段的测试，才被认为是可见的。</p>
</li>
</ul>
</li>
<li>
<p>更新绘制命令：</p>
<ul>
<li>CPU 维护一个间接绘制命令的数组（drawCommands_）。</li>
<li>根据剔除测试的结果，CPU 会直接修改这个数组中的内容。如果一个物体被判断为不可见，其对应的 DrawElementsIndirectCommand 结构体中的 instanceCount_（实例数量）字段会被设置为 0；如果可见，则设置为 1 。</li>
<li>完成所有物体的剔除测试后，将这个修改过的、包含可见性信息的命令数组通过 uploadIndirectBuffer() 上传到 GPU 的间接绘制缓冲区中 。</li>
</ul>
</li>
<li>
<p>渲染：</p>
<ul>
<li>GPU 执行 glMultiDrawElementsIndirect() 命令，它会读取间接绘制缓冲区。对于那些 instanceCount 为 0 的命令，GPU 会自动跳过，从而实现了剔除。</li>
</ul>
</li>
<li>
<p>总结 CPU 做法：剔除逻辑在 CPU 上循环执行，CPU 直接修改一个内存中的绘制命令列表来标记物体的可见性，然后将这个列表上传到 GPU 供其渲染。</p>
</li>
</ul>
<h3 id="gpu-视锥体剔除的做法">GPU 视锥体剔除的做法</h3>
<p>通过一个计算着色器（Compute Shader）来并行处理.</p>
<ul>
<li>
<p>数据准备（CPU 端）：</p>
<ul>
<li>CPU 仍然需要计算视锥体的 6 个平面和 8 个角点。但这次，CPU 不进行剔除计算，而是将这些视锥体信息连同所有物体的包围盒数据，以及原始的间接绘制命令，全部上传到 GPU 的特定缓冲区中（如 Uniform Buffer 和 Shader Storage Buffer Objects - SSBO）。</li>
</ul>
</li>
<li>
<p>在 GPU 上执行剔除（Compute Shader）：</p>
<ul>
<li>启动一个计算着色器（FrustumCulling.comp）
<ul>
<li>计算着色器的每个工作项（worker）负责处理一个或多个物体。它会读取传递进来的视锥体信息和对应物体的包围盒信息。</li>
<li>在着色器内部，执行与 CPU 版本完全相同的 isAABBinFrustum 两阶段剔除逻辑 。</li>
<li>与 CPU 不同的是，计算着色器直接修改存储在 GPU 显存中的间接绘制命令缓冲区。如果一个物体被剔除，它会将其对应命令的 instanceCount 字段直接在显存中设置为 0 。</li>
</ul>
</li>
<li>同步 (Synchronization)：
<ul>
<li>这是一个关键步骤。因为计算着色器修改了渲染管线将要使用的数据，所以在执行渲染命令之前，必须确保计算着色器的工作已经全部完成。</li>
<li>CPU 会插入一个内存屏障 (Memory Barrier)，具体使用的是 glMemoryBarrier，并带有 GL_COMMAND_BARRIER_BIT 和 GL_SHADER_STORAGE_BARRIER_BIT 标志。这个屏障确保了后续的渲染绘制调用能够“看到”计算着色器对间接绘制缓冲区的修改。</li>
</ul>
</li>
<li>渲染：
<ul>
<li>渲染管线像往常一样执行 glMultiDrawElementsIndirect() 命令，但此时它读取的是已经被计算着色器“净化”过的、包含了正确可见性信息的间接绘制缓冲区。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>总结 GPU 做法：剔除逻辑被并行化，在 GPU 的计算着色器中执行。它直接在 GPU 显存中修改绘制命令，省去了 CPU 的循环计算和数据上传的开销，但需要在计算和渲染两个阶段之间进行显式的同步。</p>
</li>
</ul>
<h2 id="2背面剔除back-face-culling">（2）背面剔除（Back-face Culling）</h2>
<p>背面剔除就是在 <strong>光栅化之前</strong> 把<strong>背向摄像机</strong>的三角形直接扔掉，省掉后面的光栅化、深度测试、片元着色等所有开销。</p>
<ul>
<li>
<p>判定方法<br>
一个三角形在<strong>裁剪空间</strong>（或 NDC）里，如果它的 <strong>有向面积</strong>（叉积 z 分量）为负，就说明是背面。</p>
<ul>
<li>顺时针（CW）通常算背面</li>
<li>逆时针（CCW）通常算正面</li>
</ul>
</li>
<li>
<p>在 OpenGL 里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">glEnable</span>(GL_CULL_FACE);        <span class="hljs-comment">// 开启剔除</span><br><span class="hljs-built_in">glCullFace</span>(GL_BACK);           <span class="hljs-comment">// 剔除背面（可选 GL_FRONT）</span><br><span class="hljs-built_in">glFrontFace</span>(GL_CCW);           <span class="hljs-comment">// 定义正面为逆时针（默认）</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>效果</p>
<ul>
<li>对封闭模型可立即减少约 50 % 的三角形处理。</li>
<li>仅在 <strong>双面关闭</strong> 时有效；若需要双面材质，记得 <code>glDisable(GL_CULL_FACE)</code> 或 <code>glCullFace(GL_FRONT_AND_BACK)</code>。</li>
</ul>
</li>
</ul>
<h2 id="3顶点命中率">（3）顶点命中率</h2>
<ul>
<li>顶点命中率是用来衡量 顶点着色器执行效率 的一个经验指标。值越高，说明剔除和索引复用做得越好。</li>
<li>顶点命中率 = 被光栅化后真正进入片元阶段的顶点数 / 顶点着色器实际执行次数</li>
<li>为什么不是 100 %
<ul>
<li>视锥剔除、背面剔除、Early-Z/Screen-Space Culling 会让某些三角形在光栅化前就被扔掉。</li>
<li>重复顶点（索引缓存命中失败、分块渲染、GPU wave 粒度）会让同一个顶点被多次执行 VS。</li>
<li>细分/几何着色器放大 会额外产生顶点。</li>
</ul>
</li>
<li>典型场景
<ul>
<li>静态网格 + 良好索引 → 95 %–99 %</li>
<li>粒子系统（大量屏幕外）→ 20 %–60 %</li>
<li>细分曲面 + 高放大 → 10 %–30 %</li>
</ul>
</li>
<li>如何查看
<ul>
<li>Pix / RenderDoc：统计 VS Invocations vs. VS Output Vertices。</li>
<li>Unreal Engine：stat gpu 里有 Vertex Hit Rate 列。</li>
<li>Unity SRP：Frame Debugger 里看 VS wave occupancy 与 culled vertices。</li>
</ul>
</li>
</ul>
<h1 id="10-ao-算法">10. AO 算法</h1>
<h2 id="1-ssao">(1) SSAO</h2>
<p>项目中的 SSAO 是作为一个多趟后处理效果来实现的。核心思路是不直接在三维空间中计算光线遮挡，而是在渲染完成后的二维屏幕空间中，利用<strong>深度缓冲</strong>的信息来近似计算。</p>
<p>整个实现流程可以分为以下四个主要步骤：</p>
<h3 id="scene-rendering-pass">Scene Rendering Pass</h3>
<ul>
<li>目标：获取后续计算所需的全屏几何信息。</li>
<li>过程：正常将整个场景渲染到一个离屏的帧缓冲对象 FBO 中。这个 FBO 至少包含两个附件：
<ul>
<li>颜色纹理：存储场景的原始渲染颜色。</li>
<li>深度纹理：存储场景中每个像素的深度值。这是 SSAO 计算最关键的输入数据。</li>
</ul>
</li>
</ul>
<h3 id="ssao-pass">SSAO Pass</h3>
<ul>
<li>目标：利用深度图生成一张包含 SSAO 遮蔽值的纹理。</li>
<li>过程：<br>
这一步会渲染一个全屏四边形，并运行一个专门的 SSAO 片段着色器（SSAO.frag）。这个着色器为屏幕上的每一个像素执行以下操作：
<ul>
<li>读取中心点深度：从深度纹理中读取当前像素的深度值 Z，并将其从屏幕空间转换到观察空间。</li>
<li>定义采样核心：着色器内部预定义了一个包含 8 个采样点偏移量（offsets）的数组，这些点构成一个采样核心。</li>
<li>随机旋转采样核心：为了避免采样图案重复导致条纹等瑕疵，项目采用了一种源于 Crytek 的技术。它使用一张小的、平铺的随机旋转纹理（4x4 像素的 rot_texture.bmp，对应着色器里的<code>texRotation</code>）。这个小纹理纹理的每一个像素存储的不是颜色，而是一个随机的三维向量。这个向量的 X, Y, Z 分量分别存储在像素的 R, G, B 通道中。像素的颜色值范围是 [0, 1]，在使用时需要被映射到 [-1, 1] 的向量范围，以便表示空间中任意方向的向量。着色器从这张纹理中为当前像素采样一个随机向量，并把这个向量视为一个随机平面的法向量。然后，通过将预定义的 8 个采样点相对于该平面进行反射，为每个像素都生成了一组独特的、随机分布的采样方向。</li>
<li>邻域深度比较：对旋转后的 8 个采样点，执行以下操作：
<ul>
<li>将采样点投影回屏幕空间，并在深度纹理中对该位置进行采样，得到邻域深度 zSample。</li>
<li>计算邻域深度 zSample 与中心点深度 Z 之间的差值 dist。</li>
<li>根据这个差值计算一个遮蔽因子 occl。这里只考虑 dist &lt;= 0 的情况，也即采样点是遮挡物的情况</li>
<li>累加与平均：将 8 个采样点的遮蔽因子进行累加和平均，最终得到当前像素的环境光遮蔽值（一个 0 到 1 之间的灰度值），并输出到 SSAO 纹理中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ssao-blur-pass">SSAO Blur Pass</h3>
<ul>
<li>目标：平滑 SSAO 计算趟产生的噪点，使遮蔽效果更柔和、自然。</li>
<li>过程：由于随机采样会产生大量噪点，需要对生成的 SSAO 纹理进行模糊处理。项目中采用了一种高效的**可分离高斯模糊（Separable Gaussian Blur）**算法（GS_BlurX.frag 和 GS_BlurY.frag）标准的高斯模糊需要用一个二维的核心（例如 11x11）去对图像进行卷积，这意味着每个像素都需要采样 <code>11 * 11 = 121</code> 次，计算量非常大。而可分离的技巧在于，一个二维高斯模糊可以被拆分成两个独立的一维高斯模糊。这样，每个像素只需要采样 11 + 11 = 22 次，大大降低了计算量，但能达到和二维模糊几乎完全相同的效果。分两步完成：
<ul>
<li>水平模糊：渲染一个全屏四边形，对 SSAO 纹理进行水平方向的模糊，并将结果输出到一张临时的模糊纹理中。</li>
<li>垂直模糊：再次渲染一个全屏四边形，对上一步生成的临时纹理进行垂直方向的模糊，并将最终结果写回到原始的 SSAO 纹理中。<br>
这个过程使用了两张 FBO 进行“ping-pong”(一个是原始的 SSAO 结果 FBO，另一个是临时的 blur FBO)，以避免在同一次渲染中同时读写一张纹理。</li>
</ul>
</li>
</ul>
<h3 id="combine-pass">Combine Pass</h3>
<ul>
<li>目标：将计算出的环境光遮蔽效果应用到原始的场景图像上。</li>
<li>过程：最后一次渲染一个全屏四边形，并运行一个组合着色器（SSAO_combine.frag）。该着色器同时采样原始场景的颜色纹理和经过模糊的 SSAO 纹理。使用 mix 函数，根据 SSAO 纹理中的遮蔽值（ssao）来调整原始颜色（color），公式类似于 <code>color * ssao</code>。遮蔽值越接近 0（表示遮蔽越强），最终颜色就越暗。最终将合成后的图像输出到屏幕上。</li>
</ul>
<h2 id="2-其他-ao-算法">(2) 其他 AO 算法</h2>
<p>见 <a href="/2025/09/14/GAMES202-L070809-GI/"> GI - AO</a></p>
<ul>
<li>
<p>SSAO (Screen Space Ambient Occlusion)</p>
<ul>
<li>核心思想：在屏幕空间（深度缓冲）采样邻域像素，估计周围几何体对环境光的遮挡。</li>
<li>优点：实现简单，完全在屏幕空间计算，不依赖场景复杂度。</li>
<li>缺点：只能基于可见片元的深度，遮挡信息不完整（屏幕后物体缺失）。粗糙，噪点多，需要 blur 滤波。</li>
</ul>
</li>
<li>
<p>HBAO (Horizon Based AO)</p>
<ul>
<li>核心思想：NVIDIA 提出的改进 SSAO，基于“地平线”思想：对每个方向找到最近的遮挡点，计算遮蔽角度。</li>
<li>优点：比 SSAO 更物理化，能得到更锐利的 AO 轮廓。</li>
<li>缺点：比 SSAO 更耗时，需要更多方向采样。</li>
</ul>
</li>
<li>
<p>HBAO+</p>
<ul>
<li>核心思想：NVIDIA 优化版 HBAO，用更少的采样方向（4–8）加上噪声旋转与过滤实现高质量 AO。</li>
<li>优点：性能更好，图像质量更高；已经广泛用于游戏引擎。</li>
<li>缺点：依旧是屏幕空间，缺少全局场景信息。</li>
</ul>
</li>
<li>
<p>GTAO (Ground Truth AO)</p>
<ul>
<li>核心思想：Epic Games 提出的 SSAO 改进方案，基于几何投影，从像素位置向多个方向投射，直接估计“可见天空比例”。</li>
<li>优点：比 HBAO 更接近真实光照理论，AO 阴影更自然。</li>
<li>缺点：计算量大，需要优化（通常结合 temporal filter）。</li>
</ul>
</li>
<li>
<p>VXAO (Voxel AO)</p>
<ul>
<li>核心思想：将场景体素化（voxelization），在体素数据上计算全局 AO。</li>
<li>优点：能捕捉屏幕后几何体的遮挡，更“全局”。</li>
<li>缺点：内存和预处理开销大，实时性能较差（但在大场景或高端 GPU 上有应用）。</li>
</ul>
</li>
<li>
<p>RTAO (Ray Traced AO)</p>
<ul>
<li>核心思想：基于光线追踪（DXR / RTX）直接从像素出发向半球方向采样，统计是否被遮挡。</li>
<li>优点：最接近物理真实的 AO，遮挡信息完整，支持全局。</li>
<li>缺点：性能消耗极大（需要加速结构 BVH，通常结合去噪器）。</li>
</ul>
</li>
<li>
<p>Multi-Scale AO (MSAO)</p>
<ul>
<li>核心思想：在多个半径尺度上计算 AO，叠加结果，同时捕捉细节与大范围遮挡。</li>
<li>优点：能表现小缝隙的 AO（例如砖块缝）和大结构的 AO（例如墙角）。</li>
<li>缺点：比单一 SSAO 更耗时。</li>
</ul>
</li>
</ul>
<h1 id="11-aa-算法">11. AA 算法</h1>
<h2 id="1fxaa-fast-approximate-anti-aliasing">（1）FXAA (Fast Approximate Anti-Aliasing)</h2>
<p>See assets/shaders/FXAA.frag</p>
<p>FXAA 是一种由 NVIDIA 开发的快速近似抗锯齿技术。它是一种后处理抗锯齿方法，不需要额外的几何信息，只基于最终渲染的图像进行抗锯齿处理。项目中 FXAA 在 HDR pipeline 色调映射之后进行，输入的是处理后的 LDR 图像，输出是抗锯齿过的图像。</p>
<ul>
<li>核心思想：
<ul>
<li>检测边缘：识别图像中的锯齿边缘</li>
<li>计算方向：确定边缘的主要方向</li>
<li>智能采样：沿着边缘方向进行采样</li>
<li>混合亮度：计算采样结果的平均亮度</li>
</ul>
</li>
<li>优势：
<ul>
<li>性能高效：单次全屏渲染，计算量小</li>
<li>无需几何信息：纯后处理，易于集成</li>
<li>质量可控：通过参数调节抗锯齿强度</li>
</ul>
</li>
<li>局限性：
<ul>
<li>丢失细节：只要是对比度高的像素，它都视作边缘像素进行处理。这可能会使图像丢失一些局部高频信息，使得画面不够锐利。解决这一问题的方法是加一个参数相对阈值比例（项目中的 FXAA_LUMA_THRESHOLD），最终阈值 = max(绝对阈值, lumaMax * 相对阈值比例)。这样明亮的地方需要更高的周边对比度才能被判定为边缘。</li>
<li>参数敏感：需要根据具体场景调整参数</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-comment">// --- INPUTS ---</span><br><span class="hljs-comment">// texture</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> u_colorTexture;<br><span class="hljs-comment">// 屏幕 texel(像素) 的尺寸, 即 vec2(1.0/screenWidth, 1.0/screenHeight)</span><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> u_texelStep;<br><span class="hljs-comment">// 从顶点着色器传入的纹理坐标</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> v_texCoord;<br><br><span class="hljs-comment">// --- OUTPUT ---</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor;<br><br><span class="hljs-comment">// --- FXAA 常量 (硬编码的推荐值) ---</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> FXAA_LUMA_THRESHOLD = <span class="hljs-number">0.125</span>; <span class="hljs-comment">// 边缘检测的亮度对比度阈值（值越小，检测到的边缘越多）</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> FXAA_MUL_REDUCE = <span class="hljs-number">1.0</span> / <span class="hljs-number">8.0</span>;   <span class="hljs-comment">// 用于减少采样步长的乘数（值越大，采样步长越短，质量越高）</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> FXAA_MIN_REDUCE = <span class="hljs-number">1.0</span> / <span class="hljs-number">128.0</span>; <span class="hljs-comment">// 最小的采样步长</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> FXAA_MAX_SPAN = <span class="hljs-number">8.0</span>;         <span class="hljs-comment">// 最大采样跨度（像素）（值越大，采样范围越大，模糊效果越明显）</span><br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-comment">// 1. 采样中心像素</span><br>    <span class="hljs-type">vec3</span> rgbM = <span class="hljs-built_in">texture</span>(u_colorTexture, v_texCoord).rgb;<br><br>    <span class="hljs-comment">// 2. 采样周围四个 texel (上/下/左/右)</span><br>    <span class="hljs-comment">// textureOffset 是一个高效的函数，它使用整数偏移量进行采样</span><br>    <span class="hljs-type">vec3</span> rgbN = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbW = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbE = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbS = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)).rgb;<br><br>    <span class="hljs-comment">// 3. 将 RGB 转换为亮度 (Luma)，用于边缘检测</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">vec3</span> toLuma = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.299</span>, <span class="hljs-number">0.587</span>, <span class="hljs-number">0.114</span>);<br>    <span class="hljs-type">float</span> lumaN = <span class="hljs-built_in">dot</span>(rgbN, toLuma);<br>    <span class="hljs-type">float</span> lumaW = <span class="hljs-built_in">dot</span>(rgbW, toLuma);<br>    <span class="hljs-type">float</span> lumaE = <span class="hljs-built_in">dot</span>(rgbE, toLuma);<br>    <span class="hljs-type">float</span> lumaS = <span class="hljs-built_in">dot</span>(rgbS, toLuma);<br>    <span class="hljs-type">float</span> lumaM = <span class="hljs-built_in">dot</span>(rgbM, toLuma);<br><br>    <span class="hljs-comment">// 4. 计算局部对比度（计算周围上下左右4个Texel和当前Texel的亮度值中的最小和最大，最大减最小获得对比度）</span><br>    <span class="hljs-type">float</span> lumaMin = <span class="hljs-built_in">min</span>(lumaM, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(lumaN, lumaW), <span class="hljs-built_in">min</span>(lumaS, lumaE)));<br>    <span class="hljs-type">float</span> lumaMax = <span class="hljs-built_in">max</span>(lumaM, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(lumaN, lumaW), <span class="hljs-built_in">max</span>(lumaS, lumaE)));<br>    <span class="hljs-type">float</span> contrast = lumaMax - lumaMin;<br><br>    <span class="hljs-comment">// 5. 如果对比度低于阈值，说明不是边缘，直接返回原颜色，不做AA</span><br>    <span class="hljs-keyword">if</span> (contrast &lt;= lumaMax * FXAA_LUMA_THRESHOLD)<br>    &#123;<br>        fragColor = <span class="hljs-type">vec4</span>(rgbM, <span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 采样四个角点的 texel并计算其亮度值</span><br>    <span class="hljs-type">vec3</span> rgbNW = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbNE = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbSW = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbSE = <span class="hljs-built_in">textureOffset</span>(u_colorTexture, v_texCoord, <span class="hljs-type">ivec2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)).rgb;<br><br>    <span class="hljs-type">float</span> lumaNW = <span class="hljs-built_in">dot</span>(rgbNW, toLuma);<br>    <span class="hljs-type">float</span> lumaNE = <span class="hljs-built_in">dot</span>(rgbNE, toLuma);<br>    <span class="hljs-type">float</span> lumaSW = <span class="hljs-built_in">dot</span>(rgbSW, toLuma);<br>    <span class="hljs-type">float</span> lumaSE = <span class="hljs-built_in">dot</span>(rgbSE, toLuma);<br><br>    <span class="hljs-comment">// 7. 计算边缘方向</span><br>    <span class="hljs-type">vec2</span> samplingDirection; <span class="hljs-comment">// 指向边缘的方向</span><br>    samplingDirection.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE)); <span class="hljs-comment">// 上排比下排亮，说明有水平边缘</span><br>    samplingDirection.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE)); <span class="hljs-comment">// 左列比右列亮，说明有垂直边缘</span><br><br>    <span class="hljs-comment">// 8. 根据亮度计算采样步长并沿着边缘方向进行最终采样</span><br>    <span class="hljs-comment">// The brighter the sampled texels, the smaller the final sampling step direction.</span><br>    <span class="hljs-comment">// This results, that brighter areas are less blurred/more sharper than dark areas.</span><br>    <span class="hljs-comment">// samplingDirectionReduce 是亮度调整因子，(lumaNW + lumaNE + lumaSW + lumaSE) * 0.25计算四个角的平均亮度，平均亮度越大，这个因子越大</span><br>    <span class="hljs-type">float</span> samplingDirectionReduce = <span class="hljs-built_in">max</span>((lumaNW + lumaNE + lumaSW + lumaSE) * <span class="hljs-number">0.25</span> * FXAA_MUL_REDUCE, FXAA_MIN_REDUCE);<br>    <span class="hljs-comment">// minSamplingDirectionFactor 是方向因子，计算方法是（绝对值较小的方向分量 + 亮度调整因子）取倒数</span><br>    <span class="hljs-type">float</span> minSamplingDirectionFactor = <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(samplingDirection.x), <span class="hljs-built_in">abs</span>(samplingDirection.y)) + samplingDirectionReduce);<br>    <span class="hljs-comment">// Calculate final sampling direction vector by reducing, clamping to a range and finally adapting to the texture size.</span><br>    <span class="hljs-comment">// samplingDirection 是最终采样方向。这里为其应用方向因子，限制最大跨度，并转为纹理坐标</span><br>    samplingDirection = <span class="hljs-built_in">clamp</span>(samplingDirection * minSamplingDirectionFactor, <span class="hljs-type">vec2</span>(-FXAA_MAX_SPAN), <span class="hljs-type">vec2</span>(FXAA_MAX_SPAN)) * u_texelStep;<br><br>    <span class="hljs-comment">// 在边缘方向的两边各取一个采样，求平均；再远一点的两个点采样，再求平均。</span><br>    <span class="hljs-comment">// 这样做是为了在“模糊程度”上有两个候选解。</span><br>    <span class="hljs-comment">// Inner samples on the tab.</span><br>    <span class="hljs-type">vec3</span> rgbSampleNeg = <span class="hljs-built_in">texture</span>(u_colorTexture, v_texCoord + samplingDirection * (<span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span> - <span class="hljs-number">0.5</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbSamplePos = <span class="hljs-built_in">texture</span>(u_colorTexture, v_texCoord + samplingDirection * (<span class="hljs-number">2.0</span>/<span class="hljs-number">3.0</span> - <span class="hljs-number">0.5</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbTwoTab = (rgbSamplePos + rgbSampleNeg) * <span class="hljs-number">0.5</span>;<br><br>    <span class="hljs-comment">// Outer samples on the tab.</span><br>    <span class="hljs-type">vec3</span> rgbSampleNegOuter = <span class="hljs-built_in">texture</span>(u_colorTexture, v_texCoord + samplingDirection * (<span class="hljs-number">0.0</span> - <span class="hljs-number">0.5</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbSamplePosOuter = <span class="hljs-built_in">texture</span>(u_colorTexture, v_texCoord + samplingDirection * (<span class="hljs-number">1.0</span> - <span class="hljs-number">0.5</span>)).rgb;<br>    <span class="hljs-type">vec3</span> rgbFourTab = (rgbSamplePosOuter + rgbSampleNegOuter) * <span class="hljs-number">0.25</span> + rgbTwoTab * <span class="hljs-number">0.5</span>;<br><br>    <span class="hljs-comment">// calculate luma for checking against the min and max luma values</span><br>    <span class="hljs-type">float</span> lumaFourTab = <span class="hljs-built_in">dot</span>(rgbFourTab, toLuma);<br><br>    <span class="hljs-comment">// 9. 最终选择是使用两个采样点的平均值还是四个采样点的平均值</span><br>    <span class="hljs-comment">// 通过亮度判断：如果第个采样点的平均亮度跑出了边界范围，就认为它太模糊了，退回用两个采样点的平均亮度，否则用四个点的平均亮度。</span><br>    <span class="hljs-keyword">if</span> (lumaFourTab &lt; lumaMin || lumaFourTab &gt; lumaMax)<br>    &#123;<br>        fragColor = <span class="hljs-type">vec4</span>(rgbTwoTab, <span class="hljs-number">1.0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        fragColor = <span class="hljs-type">vec4</span>(rgbFourTab, <span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2taatemporal-anti-aliasing">（2）TAA（Temporal Anti-Aliasing）</h2>
<p>See assets/shaders/TAA.frag (Especailly the references and comments in it).</p>
<p>TAA 在管线中的位置是在渲染完成后进行的</p>
<ul>
<li>如果在 ToneMap 前 TAA，那么输入到 TAA 环节的将会是 HDR 数据，抗锯齿效果不好。因为经过 ToneMap 之后，HDR 变为 LDR 数据，频谱上的尖刺会被抹除，减少闪烁的问题。</li>
<li>如果在 ToneMap 后 TAA，那么会影响到后续需要 HDR 的特效的计算（比如 Bloom）</li>
<li>虚幻采用的方法是：在 TAA 之前进行一次简单的 ToneMap，在 TAA 之后进行 ToneMap 的逆变换，再进行后续的后处理和正式的 ToneMap</li>
<li>项目中的实现是在 TAA.frag 中做了简单的 ToneMapping 及其逆运算。</li>
</ul>
<h3 id="g-buffer"><strong>G-Buffer</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">GLFramebuffer <span class="hljs-title">Gbuffer</span><span class="hljs-params">(width, height, &#123; GL_RGBA16F, GL_RG16F &#125;, GL_DEPTH_COMPONENT24)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>颜色缓冲区 0</strong> (<code>GL_RGBA16F</code>): 存储当前帧的渲染结果</li>
<li><strong>颜色缓冲区 1</strong> (<code>GL_RG16F</code>): 存储运动矢量（velocity buffer）</li>
<li><strong>深度缓冲区</strong>: 存储深度信息</li>
</ul>
<h3 id="抖动采样jitter-sampling"><strong>抖动采样（Jitter Sampling）</strong></h3>
<p>在顶点着色器中实现 Halton 序列抖动：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// Halton序列用于TAA抖动</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> haltonSequence_2_3[<span class="hljs-number">8</span>] = &#123;<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>f, <span class="hljs-number">-1.0</span>f / <span class="hljs-number">3.0</span>f),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-1.0</span>f / <span class="hljs-number">2.0</span>f, <span class="hljs-number">1.0</span>f / <span class="hljs-number">3.0</span>f),<br>    <span class="hljs-comment">// ... 8个预计算的Halton序列点</span><br>&#125;;<br><br><span class="hljs-comment">// 应用抖动到投影矩阵</span><br><span class="hljs-type">vec2</span> jitter = haltonSequence_2_3[offsetIdx % <span class="hljs-number">8</span>] * u_invScreenSize;<br><span class="hljs-type">mat4</span> jitterMat = proj;<br>jitterMat[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] += jitter.x;  <span class="hljs-comment">// 修改投影矩阵的X轴偏移</span><br>jitterMat[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] += jitter.y;  <span class="hljs-comment">// 修改投影矩阵的Y轴偏移</span><br></code></pre></td></tr></table></figure>
<h3 id="运动矢量计算"><strong>运动矢量计算</strong></h3>
<p>在顶点着色器中计算当前帧和上一帧的<strong>裁剪空间</strong>坐标：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl">v_prevClipPos = preProj * mv * <span class="hljs-type">vec4</span>(in_Vertex, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 上一帧位置</span><br>v_currClipPos = proj * mv * <span class="hljs-type">vec4</span>(in_Vertex, <span class="hljs-number">1.0</span>);    <span class="hljs-comment">// 当前帧位置</span><br></code></pre></td></tr></table></figure>
<p>在片段着色器中计算运动矢量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> newPos = ((v_currClipPos.xy / v_currClipPos.w) * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>);<br><span class="hljs-type">vec2</span> prePos = ((v_prevClipPos.xy / v_prevClipPos.w) * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>);<br>out_Velocity = newPos - prePos; <span class="hljs-comment">// 运动矢量 = 当前UV - 上一帧UV</span><br></code></pre></td></tr></table></figure>
<h3 id="taa-核心算法"><strong>TAA 核心算法</strong></h3>
<p>TAA.frag 实现了完整的时域抗锯齿算法：</p>
<h4 id="历史帧采样"><strong>历史帧采样</strong></h4>
<p>采样 velocity 时，因为物体轮廓周围的 velocity 也可能是有锯齿的，所以物体轮廓边缘可能会失去抗锯齿的效果。可以比较该像素周边 3x3 像素的深度，选用深度最小的那一个的 velocity。（虚幻是选择在 5×5 的范围内选取四个拐角和中心五个点来比较）。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 使用深度信息选择最接近的运动矢量</span><br><span class="hljs-type">vec2</span> velocity = <span class="hljs-built_in">texture</span>(texVelocity, getClosestOffset()).xy;<br><span class="hljs-type">vec2</span> offsetUV = <span class="hljs-built_in">clamp</span>(v_texCoord - velocity, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-type">vec3</span> preColor = <span class="hljs-built_in">texture</span>(texHistoryFrame, offsetUV).rgb;<br></code></pre></td></tr></table></figure>
<h4 id="色彩空间转换"><strong>色彩空间转换</strong></h4>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 转换到YCgCo色彩空间以减少闪烁</span><br>curColor = RGB2YCoCgR(ToneMap(curColor));<br>preColor = RGB2YCoCgR(ToneMap(preColor));<br></code></pre></td></tr></table></figure>
<h4 id="aabb-裁剪variance-clipping"><strong>AABB 裁剪（Variance Clipping）</strong></h4>
<p>根据当前帧当前像素周围的 5 个或 9 个像素的颜色作为依据，来截断采样到的历史帧颜色，用以缓解 TAA ghosting 问题。将颜色的 RGB 三个通道当做 AABB 的三维，可以求出这 9 个像素的颜色的 AABB。</p>
<p>采样周围九个像素的色彩值，计算从相邻像素采样的颜色值 C 的平均值 (mu) 和标准差 (sigma)。然后，通过从平均值中减去/加上标准差的倍数 (VarianceClipGamma) 来计算 aabbMin 和 aabbMax 值。这有助于减少采样数据中极端颜色变化（异常值）的影响，从而产生更稳定和视觉上更令人愉悦的结果。这也可以避免最终图像中出现闪烁伪影。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 使用3x3邻域计算颜色统计信息</span><br><span class="hljs-type">vec3</span> mu = m1 / N;  <span class="hljs-comment">// 均值</span><br><span class="hljs-type">vec3</span> sigma = <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(m2 / N - mu * mu));  <span class="hljs-comment">// 标准差</span><br>aabbMin = mu - VarianceClipGamma * sigma;<br>aabbMax = mu + VarianceClipGamma * sigma;<br><br><span class="hljs-comment">// 将历史颜色裁剪到AABB范围内减少 ghosting 现象</span><br>preColor = clipAABB(curColor, preColor);<br></code></pre></td></tr></table></figure>
<h4 id="时域混合"><strong>时域混合</strong></h4>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> c = <span class="hljs-number">0.05</span>; <span class="hljs-comment">// 历史帧权重</span><br>out_FragColor = <span class="hljs-type">vec4</span>(c * curColor.rgb + (<span class="hljs-number">1</span>-c) * preColor, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>
<h3 id="渲染管线集成"><strong>渲染管线集成</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (g_EnableTAA) &#123;<br>    taa.<span class="hljs-built_in">bind</span>();<br>    programTAA.<span class="hljs-built_in">useProgram</span>();<br>    <span class="hljs-built_in">glUniform1i</span>(frameIndexLoc, frameIndex);<br>    <span class="hljs-built_in">glUniform2f</span>(invScreenSizeLoc_TAA, <span class="hljs-number">1.0f</span> / width, <span class="hljs-number">1.0f</span> / height);<br><br>    <span class="hljs-comment">// 绑定纹理</span><br>    <span class="hljs-built_in">glBindTextureUnit</span>(<span class="hljs-number">0</span>, Gbuffer.<span class="hljs-built_in">getTextureColor</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">getHandle</span>()); <span class="hljs-comment">// 当前帧</span><br>    <span class="hljs-built_in">glBindTextureUnit</span>(<span class="hljs-number">1</span>, history_taa.<span class="hljs-built_in">getTextureColor</span>().<span class="hljs-built_in">getHandle</span>()); <span class="hljs-comment">// 历史帧</span><br>    <span class="hljs-built_in">glBindTextureUnit</span>(<span class="hljs-number">2</span>, Gbuffer.<span class="hljs-built_in">getTextureColor</span>(<span class="hljs-number">1</span>).<span class="hljs-built_in">getHandle</span>()); <span class="hljs-comment">// 运动矢量</span><br>    <span class="hljs-built_in">glBindTextureUnit</span>(<span class="hljs-number">3</span>, Gbuffer.<span class="hljs-built_in">getTextureDepth</span>().<span class="hljs-built_in">getHandle</span>()); <span class="hljs-comment">// 深度</span><br><br>    <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>    taa.<span class="hljs-built_in">unbind</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="历史帧管理"><strong>历史帧管理</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为下一帧准备历史帧</span><br><span class="hljs-keyword">if</span> (g_EnableTAA) &#123;<br>    <span class="hljs-built_in">glBlitNamedFramebuffer</span>(taa.<span class="hljs-built_in">getHandle</span>(), history_taa.<span class="hljs-built_in">getHandle</span>(),<br>                           <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height,<br>                           GL_COLOR_BUFFER_BIT, GL_LINEAR);<br>&#125;<br>prevView = view; <span class="hljs-comment">// 保存当前帧的VP矩阵</span><br>prevProj = proj;<br></code></pre></td></tr></table></figure>
<h1 id="12-减少-draw-call">12. 减少 Draw Call</h1>
<h2 id="1动态合批">（1）动态合批</h2>
<h3 id="为什么需要合批">为什么需要合批？</h3>
<ul>
<li>在渲染管线中，<strong>每一次 Draw Call</strong>（绘制调用）都需要 CPU -&gt; GPU 的状态切换、数据提交。</li>
<li>当场景里有成千上万个小物体时，Draw Call 成本可能比真正的 GPU 绘制还要大。</li>
<li>解决办法：<strong>把多个小物体的渲染合并成一次提交（Batching）</strong>。</li>
</ul>
<h3 id="动态合批dynamic-batching的原理">动态合批（Dynamic Batching）的原理</h3>
<ul>
<li>引擎在运行时（CPU 端），检测多个物体是否可以合并。</li>
<li>如果条件满足，把这些物体的 <strong>顶点数据拼接成一个大顶点缓冲 VAO</strong>，然后用一次 Draw Call 提交。</li>
<li>GPU 看到的就是一大块连续的几何数据，不需要多次切换状态。CPU 负责“拼接”，GPU 还是照常用传统 VAO + glDrawElements 来取顶点。</li>
</ul>
<h3 id="动态合批的条件">动态合批的条件</h3>
<p>并不是所有物体都能随便合并，通常需要满足：</p>
<ul>
<li><strong>相同的材质 / Shader</strong>（否则 GPU 还是要切换 pipeline）。</li>
<li><strong>相同的渲染状态</strong>（比如混合模式、深度测试模式）。</li>
<li><strong>顶点数量不要太大</strong>（拼接开销太高就得不偿失）。</li>
<li><strong>没有复杂的顶点动画</strong>（因为 CPU 要预处理合并顶点）。</li>
</ul>
<h3 id="动态合批-vs-静态合批">动态合批 vs 静态合批</h3>
<ul>
<li>
<p><strong>静态合批 (Static Batching)</strong>：</p>
<ul>
<li>在场景导入或 Build 时就提前把物体几何合并。</li>
<li>适合不会动的物体（地面、建筑）。</li>
<li>性能更好，因为合并只做一次。</li>
</ul>
</li>
<li>
<p><strong>动态合批 (Dynamic Batching)</strong>：</p>
<ul>
<li>运行时临时拼接。</li>
<li>适合小而多的动态物体（比如粒子、小道具）。</li>
<li>但 CPU 有额外开销。</li>
</ul>
</li>
</ul>
<h3 id="动态合批的缺点">动态合批的缺点：</h3>
<ul>
<li>CPU 要在每帧做顶点拼接，带来额外开销。</li>
<li>对复杂几何体反而可能更慢。</li>
<li>对内存带宽要求更高（需要复制顶点数据）。</li>
<li>限制条件较多（材质、状态必须相同）。</li>
</ul>
<h2 id="2programmable-vertex-pulling-pvp">（2）Programmable Vertex Pulling (PVP)</h2>
<p>传统的模式中，CPU 通过设置顶点数组对象（VAO）来详细定义顶点数据的内存布局（如位置、法线、纹理坐标等属性的偏移和步长）。然后，GPU 的固定功能硬件根据 VAO 的配置，自动“推送”这些属性给顶点着色器。而在 PVP“顶点拉取”模式中，这个过程被反过来了：不再为 VAO 配置详细的顶点属性布局。取而代之的是，将所有的顶点数据存放在一个或多个大的通用缓冲区中，例如着色器存储缓冲区（SSBO）。顶点着色器利用内置变量（如 gl_VertexID）作为索引，主动地从这些大缓冲区中“拉取”它所需要的顶点数据。通过 PVP，开发者可以将成百上千个小网格（mesh）合并到单个巨大的缓冲区中，然后用一次绘制调用就将它们全部渲染出来，极大地提升了批处理效率 。</p>
<h2 id="3多重间接绘制-multi-draw-indirect-mdi">（3）多重间接绘制 (Multi-Draw Indirect - MDI)</h2>
<p>传统渲染模式下，CPU 需要为每一个（或每一批）物体单独调用一次绘制命令（如 glDrawElements）。而在 MDI 模式下，CPU 预先将成百上千个独立的绘制命令所需的所有参数（如顶点数量、实例数量、索引偏移量、顶点偏移量等）打包成一个结构体数组，并存入一个 GPU 缓冲区中。然后，CPU 只需向 GPU 发送一次 API 调用（例如 glMultiDrawElementsIndirect），GPU 就会自己去读取那个缓冲区，并依次执行里面的所有绘制命令。在项目中的应用如下：</p>
<ul>
<li>
<p>高效渲染大规模场景：项目首先将复杂的场景图处理成一个扁平化的“形状列表”。然后，这个列表被转换成一个包含 DrawElementsIndirectCommand 结构体的间接绘制缓冲区。DrawElementsIndirectCommand 结构体包含了单次绘制所需的所有参数：</p>
<ul>
<li>count_: 索引数量</li>
<li>instanceCount_: 实例数量</li>
<li>firstIndex_: 索引缓冲区中的起始偏移</li>
<li>baseVertex_: 顶点缓冲区中的起始偏移</li>
<li>baseInstance_: 实例的起始 ID，用于在着色器中索引材质或变换矩阵<br>
准备好这个缓冲区后，整个拥有数万个物体的 Bistro 场景就可以通过一次 glMultiDrawElementsIndirect 调用来渲染，而不是数万次 。</li>
</ul>
</li>
<li>
<p>实现视锥体剔除：项目中的 CPU 和 GPU 剔除都利用了 MDI。</p>
<ul>
<li>CPU 剔除的应用：在 CPU 剔除的例子中，CPU 首先在内存中对所有物体的包围盒进行视锥体测试。对于被剔除的物体，它并不会从间接绘制命令数组中移除该命令，而是简单地将该命令对应的 <code>instanceCount_</code> 字段设置为 0。之后，这个修改过的命令缓冲区被上传到 GPU。当 GPU 执行 glMultiDrawElementsIndirect 时，它会读取到这些命令，但对于 instanceCount 为 0 的命令，它会自动跳过，不进行任何绘制。</li>
<li>GPU 剔除的应用：CPU 将所有绘制命令和物体的包围盒数据一次性上传到 GPU。CPU 派发一个计算着色器，这个计算着色器在 GPU 上并行地对所有物体的包围盒进行视锥体测试。如果一个物体被剔除，计算着色器直接在 GPU 显存中修改间接绘制缓冲区，将对应命令的 instanceCount 设置为 0。CPU 插入一个内存屏障（glMemoryBarrier）来确保计算着色器的工作完成。最后，CPU 调用 glMultiDrawElementsIndirect。此时，渲染管线读取到的是已经被 GPU 自己“净化”过的命令列表，从而只渲染可见的物体。</li>
</ul>
</li>
</ul>
<h2 id="4static-batching-and-dynamic-batching-in-unity-ue">（4）static batching and dynamic batching in Unity / UE</h2>
<p>references:</p>
<p>百人计划作业：图形 5800 合批原理讲解 - 北京 TA 吴强的文章 - 知乎<br>
<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/688223935">https://zhuanlan.zhihu.com/p/688223935</a></p>
<p>合批（Batching）在 UE 中的实现汇总 - SSSShark 的文章 - 知乎<br>
<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26832019957">https://zhuanlan.zhihu.com/p/26832019957</a></p>
<h1 id="杂项">杂项</h1>
<h2 id="1项目坐标系">（1）项目坐标系</h2>
<h2 id="2场景里的-grids-怎么绘制的">（2）场景里的 grids 怎么绘制的</h2>
<h2 id="3几何着色器和曲面细分着色器的使用">（3）几何着色器和曲面细分着色器的使用</h2>
<p>各类着色器在渲染管线中的位置：vs -&gt; tcs -&gt; tes -&gt; geom -&gt; fs</p>
<p>其中 tcs 以一组顶点（Patch）为单位进行操作，主要任务是计算并设置细分级别，即告诉后续的硬件曲面细分器应该将这个面片细分成多少个更小的图元。tes 为硬件生成的每一个新顶点计算其最终的属性值（如位置、纹理坐标等），通过对原始面片顶点的属性进行重心坐标插值来完成计算。geom 以完整的图元（点、线、三角形）为单位进行操作。它可以创建新的图元或丢弃现有的图元。</p>
<p>最终项目代码里没用到几何着色器和曲面细分着色器，但前期使用过，以下是使用场景。</p>
<h3 id="曲面细分着色器">曲面细分着色器</h3>
<p>曲面细分着色器在项目中用于实现动态的、基于距离的 LOD（Level of Detail）。目标是让靠近摄像机的物体表面被细分成更多的三角形，展现更多细节；而远离摄像机的物体则使用较少的三角形，以节省性能。下面是实现：</p>
<ul>
<li>
<p>阶段一：曲面细分控制着色器 (Tessellation Control Shader - .tesc)</p>
<ul>
<li>作用：接收一个图元“面片”（Patch），并决定这个面片应该被细分到什么程度。</li>
<li>实现：着色器计算输入三角形的每个顶点到摄像机的距离。根据这个距离，getTessLevel 函数会返回一个细分级别（例如 5.0, 3.0, 或 1.0）。距离越近，级别越高。最后，它设置内置变量 gl_TessLevelOuter（外边缘细分级别）和 gl_TessLevelInner（内部细分级别），将这些信息传递给硬件曲面细分器。具体代码如下：</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">vertices</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">out</span>; <span class="hljs-comment">// 定义输出 patch 的控制点数量为 3，表示每个 patch 是三角形（三角形有 3 个顶点/控制点）</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> uv_in[];<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> worldPos_in[];<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std140</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> PerFrameData<br>&#123;<br>  <span class="hljs-type">mat4</span> view;<br>  <span class="hljs-type">mat4</span> proj;<br>  <span class="hljs-type">vec4</span> cameraPos;<br>  <span class="hljs-type">float</span> tesselationScale;<br>&#125;;<br><br><span class="hljs-keyword">in</span> gl_PerVertex <span class="hljs-comment">// 内置的输入顶点数据块，包含每个控制点的位置 gl_Position。gl_in[] 是数组，每个元素对应一个控制点。</span><br>&#123;<br>  <span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>&#125; <span class="hljs-built_in">gl_in</span>[];<br><br><span class="hljs-keyword">out</span> gl_PerVertex <span class="hljs-comment">// 内置的输出顶点数据块，将传递给下一个着色器阶段（细分计算着色器）</span><br>&#123;<br>  <span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>&#125; <span class="hljs-built_in">gl_out</span>[];<br><br>struct vertex<br>&#123;<br>  <span class="hljs-type">vec2</span> uv;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> vertex Out[]; <span class="hljs-comment">// 元素为自定义输出数据结构 vertex的数组，vertex中只包含纹理坐标 uv，location = 0 指定输出位置，传递到tese着色器</span><br><br><span class="hljs-comment">// 基于两个相邻vertices距离相机的平均距离计算tessellation level，tessellationScale 是一个外部参数。</span><br><span class="hljs-type">float</span> getTessLevel(<span class="hljs-type">float</span> distance0, <span class="hljs-type">float</span> distance1)<br>&#123;<br>  <span class="hljs-comment">// 根据平均距离返回细分级别（距离越远细分级别越低）：</span><br>  <span class="hljs-comment">// 距离 &lt;= 7.0 * 缩放因子：返回 5（高细分级别）</span><br>  <span class="hljs-comment">// 距离 &lt;= 10.0 * 缩放因子：返回 3（中等细分级别）</span><br>  <span class="hljs-comment">// 距离 &gt; 10.0 * 缩放因子：返回 1（最低细分级别）</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> distanceScale1 = <span class="hljs-number">7.0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> distanceScale2 = <span class="hljs-number">10.0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> avgDistance = (distance0 + distance1) / <span class="hljs-number">2.0</span>;<br><br>  <span class="hljs-keyword">if</span> (avgDistance &lt;= distanceScale1 * tesselationScale)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5.0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (avgDistance &lt;= distanceScale2 * tesselationScale)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-comment">// gl_InvocationID 是 OpenGL Tessellation Control Shader (TCS) 阶段里的一个内建变量。TCS 会对一个 patch（一组控制点，比如三角形 3 点，四边形 4 点，或更多）进行处理。gl_InvocationID 表示当前 TCS invocation（调用）的编号。一个 patch 有多少控制点，就会有多少次 TCS 调用。对三角形 patch：取值范围是 0,1,2。</span><br>  <span class="hljs-comment">// PS: gl_VertexID的适用阶段是顶点着色器，指当前顶点的全局索引，取值范围：0 到 顶点总数 - 1。</span><br>  <span class="hljs-built_in">gl_out</span>[<span class="hljs-built_in">gl_InvocationID</span>].<span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-built_in">gl_InvocationID</span>].<span class="hljs-built_in">gl_Position</span>;<br>  Out[<span class="hljs-built_in">gl_InvocationID</span>].uv = uv_in[<span class="hljs-built_in">gl_InvocationID</span>];<br>  <span class="hljs-type">vec3</span> c = cameraPos.xyz;<br><br>  <span class="hljs-type">float</span> eyeToVertexDistance0 = <span class="hljs-built_in">distance</span>(c, worldPos_in[<span class="hljs-number">0</span>]);<br>  <span class="hljs-type">float</span> eyeToVertexDistance1 = <span class="hljs-built_in">distance</span>(c, worldPos_in[<span class="hljs-number">1</span>]);<br>  <span class="hljs-type">float</span> eyeToVertexDistance2 = <span class="hljs-built_in">distance</span>(c, worldPos_in[<span class="hljs-number">2</span>]);<br><br>  <span class="hljs-comment">// Calculate the tessellation levels</span><br>  <span class="hljs-built_in">gl_TessLevelOuter</span>[<span class="hljs-number">0</span>] = getTessLevel(eyeToVertexDistance1, eyeToVertexDistance2);<br>  <span class="hljs-built_in">gl_TessLevelOuter</span>[<span class="hljs-number">1</span>] = getTessLevel(eyeToVertexDistance2, eyeToVertexDistance0);<br>  <span class="hljs-built_in">gl_TessLevelOuter</span>[<span class="hljs-number">2</span>] = getTessLevel(eyeToVertexDistance0, eyeToVertexDistance1);<br>  <span class="hljs-built_in">gl_TessLevelInner</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">gl_TessLevelOuter</span>[<span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>PS：</p>
<ul>
<li>gl_TessLevelOuter（外边缘细分级别）：gl_TessLevelOuter 是一个数组，它定义了输入面片外部边缘的细分程度。对于一个三角形面片，它有 3 条外边缘，因此这个数组有 3 个元素。
<ul>
<li><code>gl_TessLevelOuter[0]</code>：控制顶点 1 和顶点 2 之间的边的细分级别（即顶点 0 的对边）。</li>
<li><code>gl_TessLevelOuter[1]</code>：控制顶点 2 和顶点 0 之间的边的细分级别（即顶点 1 的对边）。</li>
<li><code>gl_TessLevelOuter[2]</code>：控制顶点 0 和顶点 1 之间的边的细分级别（即顶点 2 的对边）。<br>
一个为 N 的细分级别值意味着对应的边将被分割成 N 个更小的段。例如，如果 <code>gl_TessLevelOuter[0]</code> 被设置为 5.0，那么顶点 1 和 2 之间的边将被分割成 5 段。如果值为 1.0，则该边不进行任何细分。</li>
</ul>
</li>
<li>gl_TessLevelInner（内部细分级别）：gl_TessLevelInner 也是一个数组，它定义了面片内部区域的细分程度。对于一个三角形面片，只有一个内部细分级别（<code>gl_TessLevelInner[0]</code>）。这个值决定了从三角形中心向外辐射的同心三角形“环”的数量。例如，如果被设置为 5.0，硬件就会在内部生成 5 层同心环状的三角形来填充内部区域。上面代码中，内部细分级别被设置为与其中一个外边缘的级别相同，这是一种常见做法，可以确保整个面片的细分密度大致均匀。</li>
</ul>
</li>
<li>
<p>阶段二：曲面细分评估着色器 (Tessellation Evaluation Shader - .tese)</p>
<ul>
<li>作用：在硬件根据控制着色器提供的级别生成了新的顶点后，这个着色器会为每一个新生成的顶点计算其最终属性（如位置、纹理坐标等）。</li>
<li>实现：评估着色器接收到新顶点在原始面片内的重心坐标（gl_TessCoord）。它使用这个重心坐标，对原始面片的顶点属性（由控制着色器传入）进行插值，从而计算出新顶点的最终位置和纹理坐标。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-comment">// equal_spacing mode告诉OpenGL 对于tessellation level n, n 应该被限制在0-64范围内且取整到最近的整数（round），然后对应的边被切成n段。</span><br><span class="hljs-comment">// ccw用来指定图元生成器生成的三角形的朝向。</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">triangles</span>, <span class="hljs-keyword">equal_spacing</span>, <span class="hljs-keyword">ccw</span>) <span class="hljs-keyword">in</span>;<br><br>struct vertex<br>&#123;<br>  <span class="hljs-type">vec2</span> uv;<br>&#125;;<br><br><span class="hljs-keyword">in</span> gl_PerVertex<br>&#123;<br>  <span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>&#125; <span class="hljs-built_in">gl_in</span>[];<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> vertex In[];<br><br><span class="hljs-keyword">out</span> gl_PerVertex<br>&#123;<br>  <span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> uv;<br><br><span class="hljs-type">vec2</span> interpolate2(<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> v0, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> v1, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> v2)<br>&#123;<br>  <span class="hljs-keyword">return</span> v0 * <span class="hljs-built_in">gl_TessCoord</span>.x + v1 * <span class="hljs-built_in">gl_TessCoord</span>.y + v2 * <span class="hljs-built_in">gl_TessCoord</span>.z;<br>&#125;<br><br><span class="hljs-type">vec4</span> interpolate4(<span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> v0, <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> v1, <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> v2)<br>&#123;<br>  <span class="hljs-keyword">return</span> v0 * <span class="hljs-built_in">gl_TessCoord</span>.x + v1 * <span class="hljs-built_in">gl_TessCoord</span>.y + v2 * <span class="hljs-built_in">gl_TessCoord</span>.z;<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-built_in">gl_Position</span> = interpolate4(<span class="hljs-built_in">gl_in</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">gl_Position</span>,	<span class="hljs-built_in">gl_in</span>[<span class="hljs-number">1</span>].<span class="hljs-built_in">gl_Position</span>, <span class="hljs-built_in">gl_in</span>[<span class="hljs-number">2</span>].<span class="hljs-built_in">gl_Position</span>);<br>  uv = interpolate2(In[<span class="hljs-number">0</span>].uv, In[<span class="hljs-number">1</span>].uv, In[<span class="hljs-number">2</span>].uv);<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="几何着色器">几何着色器</h3>
<p>在实现线框绘制效果的时候为网格生成重心坐标（Barycentric Coordinates）来识别使用重心坐标来识别每个三角形内部三角形边缘的接近程度，并相应地改变颜色。下面是为每个三角形 mesh 生成重心坐标的 geometry shader 示例.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-keyword">layout</span>( <span class="hljs-keyword">triangles</span> ) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span>( <span class="hljs-keyword">triangle_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">3</span> ) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> uv[];<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> uvs;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> barycoords;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-type">vec3</span> bc[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[]<br>	(<br>		<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>		<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>		<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>	);<br>	<span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ )<br>	&#123;<br>		<span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[i].<span class="hljs-built_in">gl_Position</span>;<br>		uvs = uv[i];<br>		barycoords = bc[i];<br>		<span class="hljs-built_in">EmitVertex</span>();<br>	&#125;<br>	<span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后在 fragment shader 中利用计算出的重心坐标来区分颜色：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460 core</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> uvs;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> barycoords;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span>=<span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> out_FragColor;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">float</span> edgeFactor(<span class="hljs-type">float</span> thickness)<br>&#123;<br>	<span class="hljs-type">vec3</span> a3 = <span class="hljs-built_in">smoothstep</span>( <span class="hljs-type">vec3</span>( <span class="hljs-number">0.0</span> ), <span class="hljs-built_in">fwidth</span>(barycoords) * thickness, barycoords);<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>( <span class="hljs-built_in">min</span>( a3.x, a3.y ), a3.z );<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-type">vec4</span> color = <span class="hljs-built_in">texture</span>(texture0, uvs);<br>	out_FragColor = <span class="hljs-built_in">mix</span>( color * <span class="hljs-type">vec4</span>(<span class="hljs-number">0.8</span>), color, edgeFactor(<span class="hljs-number">1.0</span>) );<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>其中，fwidth 函数用于计算 x/y 屏幕坐标的导数的绝对值之和（fwidth(p) = abs(dFdx(p)) + abs(dFdy(p))），即 fwidth(barycoords)计算重心坐标在屏幕空间中的变化率，在边缘附近变化率大，在三角形内部变化率小。</p>
</li>
<li>
<p>smoothstep 函数用于抗锯齿。smoothstep(edge0, edge1, x)作为平滑过渡函数：当 x &lt; edge0 时返回 0；x &gt; edge1 时返回 1；在两者之间平滑过渡。公式：<code>t = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0); return t*t*(3.0 - 2.0*t)</code>。</p>
</li>
<li>
<p>计算过程:</p>
<ul>
<li>计算边缘阈值：<code>fwidth(barycoords) * thickness</code></li>
<li>对每个重心坐标分量应用 smoothstep：
<ul>
<li>当分量值 &lt; 0：返回 0（边缘外）；</li>
<li>当分量值 &gt; 阈值：返回 1（内部）；</li>
<li>在 0 和阈值之间：平滑过渡（边缘区域）</li>
</ul>
</li>
<li>取三个分量的最小值 <code>min(a3.x, a3.y, a3.z)</code></li>
</ul>
</li>
<li>
<p>输出颜色时，mix(a, b, factor)进行线性插值：<code>a * (1-factor) + b * factor</code></p>
<ul>
<li>当 edgeFactor=1（内部）：输出 colors</li>
<li>当 edgeFactor=0（边缘）：输出黑色(0,0,0)</li>
<li>在过渡区：平滑混合黑色和物体颜色</li>
</ul>
</li>
</ul>
<h2 id="4opengl-渲染管线">（4）OpenGL 渲染管线</h2>
<h2 id="5ndc-到屏幕坐标的变换">（5）ndc 到屏幕坐标的变换</h2>
<h2 id="6opengl-对图像旋转缩放">（6）opengl 对图像旋转缩放</h2>
<h2 id="7取-a-的前-4-个字节和-b-的后-4-个字节然后组成一个新的字节如何操作">（7）取 a 的前 4 个字节和 b 的后 4 个字节，然后组成一个新的字节，如何操作？</h2>
<p>如果 a、b 都是 <strong>64-bit（8 字节）整数</strong>（uint64_t），而想把</p>
<ul>
<li>a 的 <strong>高 4 字节</strong>（最高有效 32 位）</li>
<li>b 的 <strong>低 4 字节</strong>（最低有效 32 位）</li>
</ul>
<p>拼成一个 <strong>新的 64-bit 值</strong>，可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint64_t</span> c = ((a &gt;&gt; <span class="hljs-number">32</span>) &lt;&lt; <span class="hljs-number">32</span>) | (b &amp; <span class="hljs-number">0xFFFFFFFFULL</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>解释
<ul>
<li><code>a &gt;&gt; 32</code>  把 a 右移 32 位 -&gt; 高 4 字节落到低 32 位。</li>
<li><code>&lt;&lt; 32</code>  再左移回去 -&gt; 放到新的高 32 位。</li>
<li><code>b &amp; 0xFFFFFFFFULL</code>  掩出 b 的低 4 字节。0xFFFFFFFF 是一个 32 位全 1 的掩码（十六进制写法）。ULL 后缀表示 Unsigned Long Long，即无符号 64 位整数常量。把变量 b 的每一位与掩码对应位相与，结果只保留低 32 位，其余全部置 0。</li>
<li><code>|</code>  把两部分按位或，拼成最终 64-bit 结果。</li>
</ul>
</li>
</ul>
<h2 id="8gltf-中的内容obj-中的内容">（8）.gltf 中的内容？.obj 中的内容？</h2>
<h2 id="9项目中智能指针的使用">（9）项目中智能指针的使用</h2>
<ul>
<li>
<p>GLFramebuffer.h 中构造函数里用 unique_ptr 存储纹理对象指针（支持可变数量的颜色附件（vector 纹理数组）和一个深度附件）。每个纹理对象只属于这一个帧缓冲对象；当 GLFramebuffer 对象销毁时，纹理会自动删除；避免内存泄漏，确保纹理资源在帧缓冲销毁时被正确释放。如果构造函数中发生异常，unique_ptr 会自动清理已创建的纹理避免部分初始化状态下的资源泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLFramebuffer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::unique_ptr&lt;GLTexture&gt;&gt; texColors_;<br>    std::unique_ptr&lt;GLTexture&gt; texDepth_;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>GLSceneDataLazy 类中的纹理共享。多个材质可能引用同一个纹理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLSceneDataLazy</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::shared_ptr&lt;GLTexture&gt; dummyTexture_;<br>    std::vector&lt;std::shared_ptr&lt;GLTexture&gt;&gt; allMaterialTextures_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>dummyTexture_</code><br>
在纹理加载完成前，所有材质都使用同一个 dummy texture，当多个材质引用同一个虚拟纹理时，需要确保最后一个引用消失时才释放。这样也避免为每个材质创建独立的 dummy texture 副本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 构造函数中，所有纹理初始化为dummyTexture_</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; f: textureFiles_) &#123;<br>    allMaterialTextures_.<span class="hljs-built_in">emplace_back</span>(dummyTexture_);  <span class="hljs-comment">// 共享同一个dummyTexture_</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>异步纹理加载的多线程共享</p>
<p>主线程和异步线程都需要访问纹理对象，异步线程创建纹理后，主线程接管所有权，纹理替换需要是原子操作，避免渲染时的数据竞争。</p>
<ul>
<li>异步加载机制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">taskflow_.for_each_index(<span class="hljs-number">0u</span>, (<span class="hljs-type">uint32_t</span>)textureFiles_.<span class="hljs-built_in">size</span>(), <span class="hljs-number">1u</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-type">int</span> idx) &#123;<br>    <span class="hljs-comment">// 异步加载纹理文件</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* img = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-keyword">this</span>-&gt;textureFiles_[idx].<span class="hljs-built_in">c_str</span>(), &amp;w, &amp;h, <span class="hljs-literal">nullptr</span>, STBI_rgb_alpha);<br>    <span class="hljs-keyword">if</span> (img) &#123;<br>        std::lock_guard <span class="hljs-built_in">lock</span>(loadedFilesMutex_);<br>        loadedFiles_.<span class="hljs-built_in">emplace_back</span>(LoadedImageData &#123; idx, w, h, img &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>主线程中的纹理替换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GLSceneDataLazy::uploadLoadedTextures</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 从异步加载队列中获取新纹理</span><br>    allMaterialTextures_[data.index_] = std::<span class="hljs-built_in">make_shared</span>&lt;GLTexture&gt;(data.w_, data.h_, data.img_);<br><br>    <span class="hljs-comment">// 更新材质，替换虚拟纹理</span><br>    <span class="hljs-built_in">updateMaterials</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>材质系统的纹理引用管理<br>
不同材质可能使用相同的纹理文件，确保所有引用该纹理的材质都销毁后，纹理才被释放。相同纹理文件只加载一次，通过引用计数共享。</p>
<ul>
<li>
<p>材质更新过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GLSceneDataLazy::updateMaterials</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != numMaterials; i++) &#123;<br>        <span class="hljs-comment">// 将纹理索引转换为 bindless 句柄</span><br>        out.ambientOcclusionMap_ = <span class="hljs-built_in">getTextureHandleBindless</span>(in.ambientOcclusionMap_, allMaterialTextures_);<br>        out.emissiveMap_ = <span class="hljs-built_in">getTextureHandleBindless</span>(in.emissiveMap_, allMaterialTextures_);<br>        out.albedoMap_ = <span class="hljs-built_in">getTextureHandleBindless</span>(in.albedoMap_, allMaterialTextures_);<br>        <span class="hljs-comment">// ... 其他纹理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/" class="category-chain-item">Graphics</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/graphics/" class="print-no-link">#graphics</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Summary and review of My OpenGL-based renderer</div>
      <div>http://example.com/2025/08/12/NextRendererSummary/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 12, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/09/02/GAMES202-L0405-EnvMapping/" title="GAMES 202 L04 and L05 - Environment Mapping">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GAMES 202 L04 and L05 - Environment Mapping</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/28/sorting-algo/" title="Summary of common sorting algorithms and solutions">
                        <span class="hidden-mobile">Summary of common sorting algorithms and solutions</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
