

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. OpenGL 接口封装（项目 RHI） （1）GLBuffer（GLShader.h&#x2F;.cpp）：   封装对象: GL_BUFFER   作用: 最基础的封装，代表了 GPU 上的一块连续内存。它被用作所有类型数据（顶点、索引、统一变量 UBO、着色器存储 SSBO）的容器。   实现: 123456789101112131415161718192021class GLBuffer&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="Summary and review of My OpenGL-based renderer">
<meta property="og:url" content="http://example.com/2025/08/12/NextRendererSummary/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="1. OpenGL 接口封装（项目 RHI） （1）GLBuffer（GLShader.h&#x2F;.cpp）：   封装对象: GL_BUFFER   作用: 最基础的封装，代表了 GPU 上的一块连续内存。它被用作所有类型数据（顶点、索引、统一变量 UBO、着色器存储 SSBO）的容器。   实现: 123456789101112131415161718192021class GLBuffer&amp;#12">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-12T15:55:36.549Z">
<meta property="article:modified_time" content="2025-08-17T16:49:47.577Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="graphics">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Summary and review of My OpenGL-based renderer - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Summary and review of My OpenGL-based renderer"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-12 23:55" pubdate>
          August 12, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.4k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          62 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Summary and review of My OpenGL-based renderer</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-opengl-接口封装项目-rhi">1. OpenGL 接口封装（项目 RHI）</h1>
<h2 id="1glbufferglshaderhcpp">（1）GLBuffer（GLShader.h/.cpp）：</h2>
<ul>
<li>
<p>封装对象: GL_BUFFER</p>
</li>
<li>
<p>作用: 最基础的封装，代表了 GPU 上的一块连续内存。它被用作所有类型数据（顶点、索引、统一变量 UBO、着色器存储 SSBO）的容器。</p>
</li>
<li>
<p>实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLBuffer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GLBuffer</span>(GLsizeiptr size, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, GLbitfield flags);<br>  ~<span class="hljs-built_in">GLBuffer</span>();<br><br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br><span class="hljs-keyword">private</span>:<br>  GLuint handle_;<br>&#125;;<br><span class="hljs-comment">// 构造函数: 调用 glCreateBuffers() 创建一个缓冲区句柄，然后调用 glNamedBufferStorage() 为其分配指定大小和用途的、不可变的存储空间。</span><br>GLBuffer::<span class="hljs-built_in">GLBuffer</span>(GLsizeiptr size, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, GLbitfield flags)<br>&#123;<br>  <span class="hljs-built_in">glCreateBuffers</span>(<span class="hljs-number">1</span>, &amp;handle_);<br>  <span class="hljs-built_in">glNamedBufferStorage</span>(handle_, size, data, flags);<br>&#125;<br><br>GLBuffer::~<span class="hljs-built_in">GLBuffer</span>()<br>&#123;<br>  <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;handle_);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2gltexture纹理资源管理器gltexturehcpp">（2）GLTexture（纹理资源管理器）（GLTexture.h/.cpp）：</h2>
<ul>
<li>
<p>封装对象: GL_TEXTURE</p>
</li>
<li>
<p>作用: 管理 2D 纹理、立方体贴图和纹理数组。</p>
</li>
<li>
<p>实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLTexture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName);<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, GLenum clamp);<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, GLenum internalFormat);<br>  <span class="hljs-built_in">GLTexture</span>(GLenum type, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> layers, GLenum internalFormat);<br>  <span class="hljs-built_in">GLTexture</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* img);<br>  ~<span class="hljs-built_in">GLTexture</span>();<br>  <span class="hljs-built_in">GLTexture</span>(<span class="hljs-type">const</span> GLTexture&amp;) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-built_in">GLTexture</span>(GLTexture&amp;&amp;) <span class="hljs-keyword">noexcept</span>;<br>  <span class="hljs-function">GLenum <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> type_; &#125;<br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br>  <span class="hljs-function">GLuint64 <span class="hljs-title">getHandleBindless</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handleBindless_; &#125;<br><span class="hljs-keyword">private</span>:<br>  GLenum type_ = <span class="hljs-number">0</span>;<br>  GLuint handle_ = <span class="hljs-number">0</span>;<br>  GLuint64 handleBindless_ = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>构造函数: 被**重载 (overloaded)**以处理多种情况：
<ul>
<li>GLTexture(type, width, height, format): 创建一个空的纹理，主要用作帧缓冲的附件。</li>
<li>GLTexture(type, fileName): 从文件加载纹理。它内部会判断文件类型（.ktx, .hdr 或普通图片），并调用 stbi_load 或 gli::load_ktx 来加载像素数据。</li>
<li>GLTexture(type, width, height, layers, format): 创建一个 GL_TEXTURE_2D_ARRAY (for CSM)。</li>
</ul>
</li>
<li>核心逻辑: 构造函数内部使用 glCreateTextures()创建句柄，用 glGenerateTextureMipmap 生成 mipmaps，glTextureParameteri 设置采样参数，用 glTextureStorage2D/3D()分配内存，用 glTextureSubImage2D/3D()上传像素数据。</li>
<li>高级功能: 它还封装了**无绑定纹理 (Bindless Textures)**的逻辑，通过 glGetTextureHandleARB 和 glMakeTextureHandleResidentARB 获取并激活 64 位句柄 。无绑定纹理避免了频繁的纹理绑定/解绑操作，提升性能；着色器程序可以在运行时动态选择纹理，无需重新绑定；多个绘制调用可以使用不同的纹理而无需状态切换。常用于大规模场景渲染、动态纹理管理等。</li>
</ul>
</li>
</ul>
<p>PS：项目中的主渲染循环（阴影 pass、主场景 pass、后处理）、天空盒、UI 系统都是使用的绑定纹理，无绑定纹理主要是用于场景数据管理：材质纹理（GLSceneData.cpp 和 GLSceneDataLazy.cpp 中）、PBR 材质贴图（环境光遮蔽、自发光、反照率、金属粗糙度、法线贴图）、<br>
通过 getTextureHandleBindless() 函数获取无绑定句柄。GLTexture 类：自动生成无绑定句柄并使其常驻，材质系统将传统纹理索引转换为无绑定句柄。</p>
<h2 id="3glframebuffer渲染目标切换器glframebufferh">（3）GLFramebuffer（渲染目标切换器）（GLFramebuffer.h）：</h2>
<ul>
<li>封装对象: GL_FRAMEBUFFER</li>
<li>作用: 封装一个帧缓冲对象（FBO），用于实现离屏渲染 (Offscreen Rendering)。</li>
<li>实现:
<ul>
<li>构造函数: 它不直接存储像素数据，而是像一个“插座板”，接收一个或多个颜色/深度格式，然后在内部创建并拥有 GLTexture 对象作为其附件。重载构造函数以创建包含单个/多个颜色附件、只包含深度附件</li>
<li>核心逻辑: 使用 glCreateFramebuffers()创建 FBO 句柄，然后通过 glNamedFramebufferTexture()将内部的 GLTexture 句柄“挂载”到 GL_COLOR_ATTACHMENTn 或 GL_DEPTH_ATTACHMENT 等附件点上 。对于多渲染目标（MRT），还会调用 glNamedFramebufferDrawBuffers()来启用多个颜色输出。</li>
<li>接口: 提供了 bind()和 unbind()方法来方便地切换渲染目标。getTextureColor/Depth 来获取颜色/深度纹理。</li>
</ul>
</li>
</ul>
<h2 id="4glshader-和-glprogram着色器管线glshaderhcpp">（4）GLShader 和 GLProgram（着色器管线）（GLShader.h/.cpp）：</h2>
<ul>
<li>
<p>封装对象: GL_SHADER 和 GL_PROGRAM</p>
</li>
<li>
<p>作用: 将 GLSL 着色器的加载、编译和链接过程封装起来。</p>
</li>
<li>
<p>实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLShader</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Constructors take either a filename or a shader type and source code</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GLShader</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName)</span></span>;<br>  <span class="hljs-built_in">GLShader</span>(GLenum type, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* text, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* debugFileName = <span class="hljs-string">&quot;&quot;</span>);<br>  ~<span class="hljs-built_in">GLShader</span>();<br>  <span class="hljs-function">GLenum <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> type_; &#125;<br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  GLenum type_;<br>  GLuint handle_;<br>&#125;;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// Use compiled shaders in OpenGL by linking them to a shader program</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLProgram</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a);<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a, <span class="hljs-type">const</span> GLShader&amp; b);<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a, <span class="hljs-type">const</span> GLShader&amp; b, <span class="hljs-type">const</span> GLShader&amp; c);<br>  <span class="hljs-built_in">GLProgram</span>(<span class="hljs-type">const</span> GLShader&amp; a, <span class="hljs-type">const</span> GLShader&amp; b, <span class="hljs-type">const</span> GLShader&amp; c, <span class="hljs-type">const</span> GLShader&amp; d, <span class="hljs-type">const</span> GLShader&amp; e);<br>  ~<span class="hljs-built_in">GLProgram</span>();<br><br>  <span class="hljs-comment">// To install a program object as part of the current rendering state.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useProgram</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-function">GLuint <span class="hljs-title">getHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> handle_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  GLuint handle_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>GLShader: 它的构造函数接收一个文件名，然后调用一个自定义的 readShaderFile()辅助函数（这个函数手动处理了 GLSL 中的#include 指令 ）。读取源码后，它调用 glCreateShader, glShaderSource, glCompileShader 来完成编译，并包含了错误检查和日志打印。</li>
<li>GLProgram: 它的构造函数接收一个或多个<em>已编译</em>的 GLShader 对象，然后调用 glCreateProgram, glAttachShader, glLinkProgram 来将它们链接成一个可执行的 GPU 程序 。</li>
</ul>
</li>
</ul>
<h2 id="核心设计哲学raii-与直接状态访问-dsa">核心设计哲学：RAII 与直接状态访问 (DSA)</h2>
<h3 id="1-raii">(1) RAII</h3>
<ul>
<li>原始的 OpenGL 中需要手动调用 glGen*()来创建对象，然后在不再需要时手动调用 glDelete*()来销毁它，这极易导致资源泄漏。本项目将每一个 OpenGL 对象（如缓冲区、纹理、着色器程序）都封装在一个 C++类中。</li>
<li>构造函数: 负责调用 glCreate*()或 glGen*()来获取 OpenGL 资源。</li>
<li>析构函数: 负责调用 glDelete*()来释放 OpenGL 资源。</li>
<li>优势: 这种方法利用了 C++的栈语义和对象生命周期管理。当一个封装类的对象（例如 GLTexture tex(…)）被创建时，OpenGL 资源会自动被创建；当这个对象离开其作用域时（例如函数返回），它的析构函数会自动被调用，确保 OpenGL 资源被干净利落地释放，从而从根本上消除了资源泄漏的风险。</li>
</ul>
<h3 id="2-直接状态访问-direct-state-access-dsa">(2) 直接状态访问 (Direct State Access - DSA)</h3>
<ul>
<li>OpenGL 4.5 引入的一套现代 API。在旧的 OpenGL 中，要修改一个对象（比如一个纹理），必须先把它绑定到一个全局的目标上，然后才能调用 glTexParameter*()等函数进行修改。这种“先绑定再编辑”的模式会污染全局状态，代码也不够清晰。本项目中的封装类（如 GLTexture, GLFramebuffer, GLMesh）大量使用了 DSA 函数。如 glTextureStorage2D(), glNamedBufferStorage(), glNamedFramebufferTexture() 这样的函数调用。这些函数的第一个参数都是对象的句柄 (handle)，而不是一个目标。</li>
<li>优势: DSA 可以直接对一个对象进行操作，而无需先将其绑定到全局状态。这使得代码更清晰、更不容易出错，并且在某些情况下性能更高，因为它减少了驱动程序需要进行的状态检查。</li>
</ul>
<h1 id="2-阴影">2. 阴影</h1>
<h2 id="1shadow-map-pcf">（1）Shadow Map + PCF</h2>
<h3 id="核心思想两次渲染两种视角"><strong>核心思想：两次渲染，两种视角</strong></h3>
<ul>
<li><strong>第一次渲染</strong>: 从<strong>光源的位置</strong>看场景。“看”到的所有东西，都是被光直接照亮的。把看到的每个物体的深度信息，拍成一张“深度照片”，这张照片就是<strong>阴影贴图 (Shadow Map)</strong>。</li>
<li><strong>第二次渲染</strong>: 从<strong>摄像机的位置</strong>正常地渲染场景。但在为每个像素上色之前先做一个判断：这个像素在世界中的位置，如果从光源的视角来看，是比之前拍的那张阴影贴图上的点更远/更近？
<ul>
<li>如果<strong>更远</strong>，说明它被挡住了，它就在<strong>阴影</strong>里。</li>
<li>如果<strong>更近或距离相同</strong>，说明它没被挡住，它就在<strong>光照</strong>下。</li>
</ul>
</li>
</ul>
<h3 id="第一步shadow-generation-pass"><strong>第一步：Shadow Generation Pass</strong></h3>
<p>从<strong>光源的视角</strong>渲染整个不透明场景。</p>
<ul>
<li>
<p><strong>C++ 端：</strong></p>
<ul>
<li><strong>计算光源矩阵</strong>: 根据 <code>g_LightTheta</code>, <code>g_LightPhi</code> 计算出光源的方向 <code>lightDir</code>。然后，用 <code>glm::lookAt(eye, target, up)</code> 和 <code>glm::ortho</code> 创建了光源的<strong>视图矩阵 (<code>lightView</code>)</strong> 和<strong>正交投影矩阵 (<code>lightProj</code>)</strong>。其中投影矩阵是把整个场景的包围盒转换到光源空间下，然后<code>lightProj = glm::ortho(box.min_.x, box.max_.x, box.min_.y, box.max_.y, -box.max_.z, -box.min_.z)</code>。</li>
<li><strong>绑定帧缓冲</strong>: 程序调用 <code>shadowMap.bind()</code> ，将渲染目标从屏幕切换到一个离线的帧缓冲对象（FBO）上。这个 <code>shadowMap</code> FBO 包含一个高分辨率的<strong>深度纹理附件</strong>。</li>
<li><strong>上传矩阵</strong>: 程序将 <code>lightView</code> 和 <code>lightProj</code> 组合成 <code>lightMatrix</code>，并将其上传到 <code>PerFrameData</code> 这个统一变量缓冲区（UBO）中。</li>
<li><strong>激活着色器</strong>: C++ <code>progShadowMap.useProgram()</code>。</li>
</ul>
</li>
<li>
<p><strong>GPU 端：</strong></p>
<ul>
<li><strong>顶点着色器 (<code>shadow.vert</code>)</strong>:
<ul>
<li>获取物体的顶点位置，然后用<code>lightMatrix</code>对其进行变换，计算出顶点在<strong>光源裁剪空间</strong>中的最终位置 <code>gl_Position</code>。</li>
</ul>
</li>
<li><strong>片元着色器 (<code>shadow.frag</code>)</strong>:
<ul>
<li>这个着色器类似一个“占位符” 。在这一步，<strong>只关心深度</strong>。当 GPU 对三角形进行光栅化时，它会自动计算每个片元的深度值，并将其写入 <code>shadowMap</code> FBO 的<strong>深度纹理</strong>中。</li>
<li>这个着色器输出的颜色 <code>vec4(1.0, 0.0, 0.0, 1.0)</code> 实际上被丢弃了，因为它所绑定的 FBO 已经被配置为只关心深度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>此阶段结束时，<code>shadowMap</code> FBO 的深度纹理中，就存储了一张从光源视角看去的、完整的场景深度图。</strong></p>
<h3 id="第二步shadow-application-pass"><strong>第二步：Shadow Application Pass</strong></h3>
<p>主渲染通道，从<strong>摄像机的视角</strong>正常渲染场景，并利用上一步生成的阴影贴图来计算阴影。</p>
<ul>
<li>
<p><strong>C++ 端：</strong></p>
<ul>
<li><strong>绑定主帧缓冲</strong></li>
<li><strong>计算摄像机矩阵</strong>: 正常计算摄像机的 <code>view</code> 和 <code>proj</code> 矩阵。</li>
<li><strong>绑定阴影贴图</strong>: <code>glBindTextureUnit(4, shadowMap.getTextureDepth().getHandle())</code>，将上一阶段生成的<strong>深度纹理</strong>绑定到一个可供着色器采样的纹理单元（这里是 4 号）上。</li>
<li><strong>激活着色器</strong>: C++ 代码调用 <code>program.useProgram()</code>。</li>
</ul>
</li>
<li>
<p><strong>GPU 端：</strong></p>
<ul>
<li><strong>顶点着色器 (<code>scene_IBL_MTR.vert</code>)</strong>:
<ul>
<li>计算顶点在<strong>摄像机裁剪空间</strong>中的位置，并赋值给 <code>gl_Position</code>，用于正常渲染。</li>
<li>计算同一个顶点在<strong>光源裁剪空间</strong>中的位置，并将其乘以 <code>scaleBias</code> 矩阵（将 <code>[-1, 1]</code> 范围映射到 <code>[0, 1]</code>），然后将这个结果 <code>v_shadowCoord</code> 传递给片元着色器。</li>
</ul>
</li>
<li><strong>片元着色器 (<code>scene_IBL_MTR.frag</code>)</strong>:
<ul>
<li><strong>接收坐标</strong>: 它接收从顶点着色器传来的、经过插值的 <code>v_shadowCoord</code>。</li>
<li><strong>透视除法</strong>: 它首先对 <code>v_shadowCoord</code> 进行透视除法 <code>(v_shadowCoord.xyz / v_shadowCoord.w)</code>，得到一个 <code>vec3</code> 坐标。这个坐标的 <code>.xy</code> 是在阴影贴图上的采样位置，<code>.z</code> 则是当前片元<strong>距离光源的深度</strong>。</li>
<li><strong>PCF 采样</strong>: 着色器调用您编写的 <code>PCF()</code> 函数。这个函数会以 <code>shadowCoord.xy</code> 为中心，在阴影贴图上进行多次采样（例如 5x5 的网格）。在每一次采样中，<code>texture()</code> 函数（配合 <code>sampler2DShadow</code> 类型）会自动将当前片元的深度 <code>shadowCoord.z</code> 与阴影贴图中存储的深度进行<strong>硬件加速比较</strong>。这一步解决普通 shadow mapping 的边缘锯齿问题。</li>
<li><strong>计算阴影因子</strong>: <code>PCF()</code> 函数将所有比较结果进行平均，返回一个 <code>0.0</code> (完全在阴影中) 到 <code>1.0</code> (完全被照亮) 之间的<strong>阴影因子 <code>shadow</code></strong>。</li>
<li><strong>应用阴影</strong>: 最后，着色器将计算出的 PBR 颜色 <code>pbrColor</code>，与这个阴影因子 <code>shadow</code> 相乘 (<code>finalColor = pbrColor * shadow;</code>)，得到最终的、带有真实阴影的像素颜色。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2遇到哪些问题如何处理采样精度不足指的是精度如果用-float-表达其实已经够了">（2）遇到哪些问题？如何处理？采样精度不足指的是？精度如果用 float 表达其实已经够了</h2>
<h3 id="shadow-acne"><strong>Shadow Acne</strong></h3>
<ul>
<li><strong>现象</strong>: 物体表面（特别是被光斜着照射的表面）出现不规则的黑色条纹或斑点，看起来像是“暗疮”。</li>
<li><strong>原因</strong>: 这是由<strong>深度精度</strong>问题引起的。阴影贴图的分辨率是有限的，它存储的深度值是离散的。当片元着色器计算一个片元距离光源的深度时，这个计算结果可能因为浮点数精度误差，比存储在阴影贴图上<strong>几乎相同位置</strong>的深度值要大那么一点点。这导致这个片元在进行深度比较时，错误地判断自己“被自己挡住了”，从而将自己渲染进了阴影中。</li>
<li><strong>解决方案：深度偏移 (Depth Bias)</strong></li>
</ul>
<h3 id="彼得潘现象-peter-panning"><strong>彼得潘现象 (Peter Panning)</strong></h3>
<ul>
<li><strong>现象</strong>: “用力过猛”的深度偏移导致的副作用。阴影看起来与投射出它的物体<strong>分离</strong>了。</li>
<li><strong>原因</strong>: 如果设置的深度偏移量（<code>Depth Bias</code>）过大，会导致阴影的起始位置离物体的根部太远，看起来就像悬浮在空中。</li>
<li><strong>解决方案：斜率缩放偏移 (Slope-Scaled Depth Bias)</strong>
<ul>
<li>一个固定的偏移量对于所有表面都不是最优的。对于那些与光线方向几乎平行的陡峭表面，需要更大的偏移；而对于那些与光线垂直的平坦表面，一个很小的偏移就足够了。</li>
<li><code>glPolygonOffset(slope, constant)</code> 函数的第一个参数 <code>slope</code> 正是为此而生。它会根据多边形相对于光源方向的“斜率”，动态地调整偏移量的大小。</li>
<li>通过仔细地调节 <code>slope</code> 和 <code>constant</code> 这两个参数，您可以在有效消除暗疮的同时，最大限度地减少彼得潘现象。</li>
</ul>
</li>
</ul>
<h3 id="边缘锯齿-aliasing"><strong>边缘锯齿 (Aliasing)</strong></h3>
<ul>
<li><strong>现象</strong>: 阴影的边缘呈现出明显的、块状的锯齿。</li>
<li><strong>原因</strong>: 阴影贴图本质上是一张纹理，它的分辨率是有限的。一个像素要么完全在阴影内（返回 0.0），要么完全在阴影外（返回 1.0），这种二元的判断导致了硬朗的、带有锯齿的边缘。</li>
<li><strong>解决方案：百分比渐近滤波 (Percentage-Closer Filtering, PCF)</strong>
<ul>
<li>PCF 的核心思想是，不再只对阴影贴图进行一次采样。而是在当前片元阴影坐标的<strong>周围邻域</strong>内，进行多次采样（例如，在一个 5x5 的网格中采样 25 次）。</li>
<li>将这 25 次硬件深度比较的结果（<code>0.0</code> 或 <code>1.0</code>）进行<strong>平均</strong>。</li>
<li>最终得到的阴影因子就是一个在<code>0.0</code>到<code>1.0</code>之间平滑变化的<strong>百分比</strong>，它代表了“当前片元有多大比例处于阴影中”。这个平滑的过渡值，就产生了柔和的阴影边缘，有效地消除了锯齿。</li>
</ul>
</li>
</ul>
<h3 id="透视失真-perspective-aliasing"><strong>透视失真 (Perspective Aliasing)</strong></h3>
<ul>
<li><strong>现象</strong>: 近处的阴影质量极差，充满了巨大的块状锯齿，而远处的阴影看起来却还可以。</li>
<li><strong>原因</strong>: 这是透视投影和阴影贴图分辨率的根本矛盾。主摄像机使用<strong>透视投影</strong>，近处的物体在屏幕上占据大量像素。而定向光源为了覆盖整个场景使用<strong>正交投影</strong>，为空间中的每个区域都分配了相同的分辨率。
<ul>
<li>这就导致了离摄像机很近的一大片地面可能只对应了阴影贴图中非常少的几个像素。当这些像素被放大显示在屏幕上时就形成了巨大的块状阴影。</li>
</ul>
</li>
<li><strong>解决方案：级联阴影贴图 (Cascaded Shadow Maps, CSM)</strong>
<ul>
<li>CSM 通过将摄像机的视锥体分割成多个<strong>级联</strong>来完美地解决这个问题。</li>
<li>离摄像机最近的级联（Cascade 0）只覆盖一小块区域，但它会得到一张独立的、高分辨率的阴影贴图。</li>
<li>离得最远的级联覆盖范围巨大，但使用一张较低分辨率的贴图。</li>
<li>通过为不同距离的区域“量身定制”阴影贴图，CSM 确保了无论在近处还是远处，阴影都能获得足够的分辨率，从而从根本上解决了透视失真问题。</li>
</ul>
</li>
</ul>
<h2 id="3csm">（3）CSM</h2>
<h3 id="第一阶段cpu-端-while-循环中"><strong>第一阶段：CPU 端 (<code>while</code> 循环中)</strong></h3>
<ul>
<li>
<p><strong>纹理数组</strong>: 创建了一个 <code>GLTexture shadowMapTextureArray</code>，其类型为 <code>GL_TEXTURE_2D_ARRAY</code>，尺寸为 2048x2048，层数为 4。</p>
</li>
<li>
<p><strong>计算级联分割</strong>：</p>
<ul>
<li>根据摄像机的近、远裁剪面（0.1f, 1000.0f）和设定的 <code>g_CascadeLambda</code> 参数，采用一种混合了<strong>对数和线性</strong>的分割方案。这里让前一个级联的远平面和后一个级联的近平面有一点重合的部分。</li>
<li>这种方案能在近处提供更多的深度精度，同时又保证了远处级联的平滑过渡。</li>
<li>得到每个级联的远近平面在观察空间中的 z 值</li>
</ul>
</li>
<li>
<p><strong>为每个级联计算光源矩阵</strong></p>
<ul>
<li><strong>计算子视锥角点</strong>: 计算出当前级联所覆盖的那个<strong>子视锥体 (sub-frustum)</strong> 在世界空间中的 8 个角点。</li>
<li><strong>找到视锥中心</strong>: 计算这 8 个角点的平均值，得到子视锥体的几何中心。</li>
<li><strong>创建光源视图矩阵 (<code>lightView</code>)</strong>: 以子视锥体的中心为目标点，沿着光线方向的反方向设置光源的“摄像机”位置，并使用 <code>glm::lookAt</code> 创建一个能正好观察到这个子视锥体的视图矩阵。</li>
<li><strong>计算紧凑的正交投影 (<code>lightProj</code>)</strong>: 将子视锥体的 8 个角点变换到刚刚创建的光源空间中，然后计算这 8 个点的轴对齐包围盒 (AABB)并转换到光源空间。再根据整个场景在光源空间的总 AABB 的范围来拓展小 AABB 的 z 值，从而计算出光源的<strong>正交投影矩阵</strong>。</li>
</ul>
</li>
</ul>
<h3 id="第二阶段shadow-pass"><strong>第二阶段：shadow pass</strong></h3>
<ul>
<li>在一个 <code>for</code> 循环中，遍历 4 个级联。在每一次循环中：
<ul>
<li>通过 <code>glNamedFramebufferTextureLayer</code>，将 FBO 的渲染目标<strong>切换</strong>到 <code>shadowMapTextureArray</code> 的第 <code>i</code> 层。</li>
<li>让 GPU 从光源的视角，将所有不透明物体渲染一遍。</li>
<li>此阶段结束后，<code>shadowMapTextureArray</code> 纹理数组的 4 个层中，就分别存储了 4 张从光源视角看去的、覆盖不同距离范围的深度图。</li>
</ul>
</li>
</ul>
<h3 id="第三阶段gpu-端-main-scene-pass"><strong>第三阶段：GPU 端 Main Scene Pass</strong></h3>
<ul>
<li><strong>C++ 端</strong>:
<ul>
<li>将 <code>shadowMapTextureArray</code> 这张纹理数组，绑定到一个 <code>sampler2DArrayShadow</code> 类型的纹理单元上（例如 <code>binding = 4</code>）。</li>
</ul>
</li>
<li><strong>GPU 端 (PBR 片元着色器)</strong>:
<ul>
<li><strong>选择级联</strong>: 着色器首先获取当前正在着色的片元（像素）在<strong>观察空间</strong>中的深度 <code>viewDepth</code>，将之与每个级联的分割深度远近平面进行比较，从而快速地确定出当前片元属于哪个级联。</li>
<li><strong>计算阴影坐标</strong>: 确定了级联索引后，取出对应索引的 <code>cascadeMat</code> 矩阵，用它来将片元的世界坐标变换到光源的裁剪空间，得到 <code>shadowCoord</code>和其在光源空间的深度。</li>
<li>进行硬件加速的深度比较和 PCF。</li>
</ul>
</li>
</ul>
<h2 id="4其他阴影算法">（4）其他阴影算法</h2>
<p>pcss（原理、切比雪夫什么时候精确）</p>
<p>见 <a href="/2025/03/30/interview-review/"> 面试复习：8. 阴影技术</a></p>
<h1 id="3-透明渲染">3. 透明渲染</h1>
<h2 id="1oit-实现">（1）OIT 实现</h2>
<p>传统 Alpha 混合的难点在于，GPU 在光栅化时，同一个像素可能会被多个不同远近的透明片元覆盖，而 GPU 并不知道应该先画哪个。</p>
<p>本项目中 OIT 算法的思路是：不让 GPU 在渲染时直接混合。取而代之的是：</p>
<ul>
<li><strong>第一趟 (Opaque Pass)</strong>：先把所有不透明的物体都画好，得到背景颜色和一张完整的深度图。</li>
<li><strong>第二趟 (Transparent Pass)</strong>：再渲染所有透明物体。但这次，不把它们的颜色画到屏幕上，而是把每个透明片元的<strong>颜色</strong>和<strong>深度</strong>信息放在对应屏幕像素的一个<strong>链表</strong>里。</li>
<li><strong>第三趟 (Combination Pass)</strong>：最后，渲染一个覆盖全屏的四边形。对于屏幕上的每一个像素，独立地处理它的链表：先把这些片元按<strong>从远到近</strong>的顺序排好，然后再逐个地、正确地将它们混合到第一趟渲染好的背景上。</li>
</ul>
<h3 id="第一阶段渲染不透明物体-opaque-pass"><strong>第一阶段：渲染不透明物体 (Opaque Pass)</strong></h3>
<p>略</p>
<h3 id="第二阶段收集透明片元-transparent-pass"><strong>第二阶段：收集透明片元 (Transparent Pass)</strong></h3>
<ul>
<li><strong>C++ 端</strong>
<ul>
<li>创建三个 GPU 缓冲区：
<ul>
<li><code>GLTexture oitHeads</code>: 一张 <code>GL_R32UI</code> 格式的 2D 纹理。每个纹素是一个无符号 32 位整数，存储该像素对应链表的头指针。</li>
<li><code>GLBuffer oitAtomicCounter</code>: 一个只包含一个整数的缓冲区，用作<strong>原子计数器</strong>。确保每个新来的片元都能拿到一个独一无二的 ID。</li>
<li><code>GLBuffer oitTransparencyLists</code>: 一个巨大的 SSBO，用来存放所有透明片元（<code>TransparentFragment</code> 结构体）的实际数据。</li>
</ul>
</li>
<li>在渲染循环开始时，<code>clearTransparencyBuffers()</code> 函数会被调用，它将 <code>oitHeads</code> 的所有像素都重置为 <code>-1</code>（表示链表为空），并将原子计数器归零。</li>
<li><code>glDepthMask(GL_FALSE)</code>: <strong>深度写入被关闭</strong>。透明物体之间不应该互相遮挡深度。</li>
<li><code>glColorMask(GL_FALSE, ..., GL_FALSE)</code>: <strong>颜色写入被关闭</strong>。我们不希望这些片元直接被画到帧缓冲里。</li>
</ul>
</li>
<li><strong>GPU 端 (<code>OIT_transparent.frag</code>)</strong><br>
为每一个通过深度测试的透明片元执行以下操作：
<ul>
<li><strong>获取序列号</strong>: 调用 <code>atomicCounterIncrement(numFragments)</code>（OpenGL 4.2 内置函数），从全局原子计数器中安全地获取一个<strong>新的、唯一的</strong>索引 <code>index</code>。</li>
<li><strong>获取链表当前的头节点</strong>: 调用 <code>imageAtomicExchange(heads, ivec2(gl_FragCoord.xy), index)</code>。
<ul>
<li>将<strong>新的</strong>索引 <code>index</code> 写入到 <code>heads</code> 纹理中当前像素的位置，使其成为新的“头指针”。</li>
<li><strong>返回</strong>在写入之前，那个位置上<strong>旧的</strong>“头指针” <code>prevIndex</code>。</li>
</ul>
</li>
<li><strong>存放新的节点</strong>: 将当前片元的颜色、深度 (<code>gl_FragCoord.z</code>) 以及刚刚获取到的<strong>旧头节点 <code>prevIndex</code></strong>（作为 <code>next</code> 指针），作为一个 <code>TransparentFragment</code> 结构体，存入<code>oitTransparencyLists</code> SSBO 的 <code>index</code> 位置。</li>
</ul>
</li>
</ul>
<p><strong>此阶段结束后，GPU 显存中就已经构建起了一个包含所有可见透明片元信息的、复杂的每像素链表数据结构。</strong></p>
<h3 id="第三阶段排序与混合-combination-pass"><strong>第三阶段：排序与混合 (Combination Pass)</strong></h3>
<ul>
<li><strong>GPU 端 (<code>OIT_full.frag</code>)：整理并混合</strong><br>
为屏幕四边形上的每一个像素执行以下操作：
<ul>
<li><strong>遍历链表</strong>: 根据当前像素坐标，从 <code>heads</code> 纹理中找到链表的头指针，然后顺着 <code>next</code> 指针遍历整个链表，将所有属于这个像素的 <code>TransparentFragment</code> 节点复制到一个小型的本地数组。</li>
<li><strong>排序</strong>: 对这个本地数组进行一次简单的<strong>插入排序</strong>，根据每个节点的 <code>depth</code> 值，将它们<strong>从后往前</strong>（从深度值大的到小的）排列好。</li>
<li><strong>混合</strong>: 首先读取第一趟渲染好的不透明背景色。然后从这个本地数组的<strong>末尾</strong>（现在是<strong>最远的片元</strong>）开始，按照刚刚排好的顺序，将数组中的片元颜色<strong>逐个地</strong>进行标准的 Alpha 混合 (<code>mix</code> 函数)。</li>
<li><strong>输出</strong>: 最终混合完成的颜色，就是这个像素最终应该呈现的、包含了正确透明效果的颜色，被写入到最终的帧缓冲中。</li>
</ul>
</li>
</ul>
<h2 id="2常见的-oit-算法比链表式更节省时间的">（2）常见的 OIT 算法？比链表式更节省时间的？</h2>
<p>另参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368065919">https://zhuanlan.zhihu.com/p/368065919</a></p>
<ul>
<li>精确 OIT</li>
</ul>
<p>这类算法<strong>保证像素颜色和深度混合结果与逐片元严格排序一致</strong>。但代价是<strong>存储和排序所有片元</strong>，计算量和显存需求很大。</p>
<ul>
<li>
<p>深度剥离 (Depth Peeling)</p>
<ul>
<li>逐次渲染场景，剥离最前面的片元层，直到把所有透明层处理完。</li>
<li>优点：结果准确。</li>
<li>缺点：需要多次 pass（=透明层数），效率低。</li>
<li>常见变种：
<ul>
<li>Dual Depth Peeling：每次剥离前后两层，提高效率。</li>
<li>Adaptive Depth Peeling：减少不必要的 pass。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>A-Buffer / Per-Pixel Linked List (PPLL)</p>
<ul>
<li>每个像素存储一个链表，链表里记录该像素下的所有片元（颜色、深度、透明度等）。之后在 fragment 处理结束后对链表排序并混合。</li>
<li>优点：结果精确，不依赖多 pass。</li>
<li>缺点：需要 GPU 上复杂的内存管理（原子操作、链表构建），显存消耗大。由于渲染某一场景所需内存无法提前知道，所以可能会因为没有分配足够内存而导致渲染错误。</li>
</ul>
</li>
<li>
<p>近似 OIT</p>
</li>
</ul>
<p>牺牲一定精度，换取性能。常用于实时渲染和游戏。</p>
<ul>
<li>Weighted Blended OIT (WBOIT)
<ul>
<li>每个片元根据深度给一个权重，把颜色和透明度累加到一个 buffer 中，最后归一化合成。不需要排序，也不需要存储所有片元。</li>
<li>优点：性能极高，单 pass 实现。</li>
<li>缺点：只是近似，可能在交叠复杂时与真实结果差距大。</li>
<li>常见扩展：Weighted Blended with Moment Transparency（结合更高阶统计信息）。</li>
</ul>
</li>
<li>Stencil Routed A-Buffer
<ul>
<li>用 stencil buffer 管理像素内的多个片元存储位置。</li>
<li>每个像素存储有限个片元（类似 k-buffer）。</li>
<li>缺点：硬件依赖强，受片元数限制。</li>
</ul>
</li>
<li>k-Buffer
<ul>
<li>每个像素存储最多 k 个片元（深度+颜色），最后做排序与混合。介于精确和近似之间：当片元数 &lt;= k 时精确，否则裁剪或近似。</li>
</ul>
</li>
<li>Moment-Based OIT
<ul>
<li>借鉴方差阴影贴图的思路，存储片元深度的统计量（前几阶矩），再进行透明度估算。</li>
<li>性能较高，但近似误差明显。</li>
</ul>
</li>
</ul>
<h2 id="3深度剥离意义-流程">（3）深度剥离（意义、流程）</h2>
<ul>
<li>传统渲染流程问题：
<ul>
<li>GPU 默认是 不保证片元顺序的（可能乱序写入）。</li>
<li>如果强行在 CPU 对所有三角形排序:复杂场景开销大、无法解决多层交叠的问题。</li>
</ul>
</li>
<li>深度剥离的意义：
<ul>
<li>提供了一种完全在 GPU 上进行 逐层排序 的方法。</li>
<li>最终结果与逐片元严格排序一致，属于 精确 OIT。</li>
</ul>
</li>
<li>深度剥离的核心思想：从前往后逐层合并
<ul>
<li>第一次 pass 渲染出每个像素最近的透明片元；</li>
<li>第二次 pass 剔除已处理的片元，找到每个像素第二近的片元；</li>
<li>依次类推，直到所有片元都被处理完。</li>
</ul>
</li>
<li>深度剥离的流程
<ul>
<li>Step 1：第一次渲染 (最近一层)
<ul>
<li>打开深度测试和深度写入。</li>
<li>渲染场景，得到每个像素最前的透明片元（最小深度值）。</li>
<li>把它的 颜色、α 和深度 存到缓冲区。</li>
</ul>
</li>
<li>Step 2：第二次渲染 (第二层)
<ul>
<li>使用 上一次 pass 得到的深度图，作为“剥离条件”：</li>
<li>只通过深度测试 z &gt; z_previous_layer 的片元。</li>
<li>这样，每个像素得到的就是比第一层更远的片元。</li>
<li>存储颜色、α、深度。</li>
</ul>
</li>
<li>Step 3：重复剥离
<ul>
<li>依次迭代，直到达到场景的最大透明层数，或者迭代到没有新的片元为止。</li>
</ul>
</li>
<li>Step 4：前到后混合
<ul>
<li>现在有了每一层的颜色和深度信息。</li>
<li>在最后一个 pass，把它们按顺序（前到后）做标准的 α 混合，得到最终结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-pbr">4. PBR</h1>
<h2 id="1pbr-实现">（1）PBR 实现</h2>
<p>NFG 各项</p>
<p>pbr 基于物理的相机、材质、环境光分别是什么</p>
<h2 id="2ibl-与-pbr-结合">（2）ibl 与 PBR 结合</h2>
<ul>
<li>天空盒立方体贴图如何采样？用什么坐标系？
<ul>
<li>天空盒先被渲染，然后渲染场景中的物体，这样物体就能正确地接收 IBL 光照。</li>
<li>天空盒将 PBR 所需的三个关键纹理绑定到着色器：绑定点 5: 环境贴图、绑定点 6: 辐照度贴图、绑定点 7: BRDF 查找表。</li>
</ul>
</li>
</ul>
<p>IBL 处理镜面和非镜面？</p>
<p>IBL 中加速的 trick？</p>
<p>pbr 中如何区分不同材质？</p>
<h2 id="3为什么-pbr-中的输入不能是-gamma-校正过的为什么要最后校正">（3）为什么 pbr 中的输入不能是 gamma 校正过的？为什么要最后校正？</h2>
<ul>
<li>显示器是非线性的：如果直接把线性空间颜色写入显示器，会显得灰蒙蒙的。解决办法是：在存储/显示时，对颜色做一个 gamma 压缩（通常是 1/2.2），保证在显示器上能正确显示。因此，显示/存储用 gamma 空间（sRGB）。计算/物理模拟 必须在线性空间。</li>
<li>PBR 本质上在做能量守恒的物理计算，这些运算必须是线性代数意义上的加减乘除，才能符合物理。如果把 gamma 校正过的输入（非线性值）拿来算，加法/乘法结果会被严重扭曲。</li>
</ul>
<h1 id="5-纹理">5. 纹理</h1>
<h2 id="1虚拟纹理与三维纹理">（1）虚拟纹理与三维纹理</h2>
<h2 id="2mipmap-原理会增加开销吗">（2）mipmap 原理？会增加开销吗？</h2>
<h2 id="3mipmap-有哪些缺点如何精准采样">（3）mipmap 有哪些缺点？如何精准采样？</h2>
<h2 id="410241000-的-rgba8-在显存存储占用的内存">（4）1024*1000 的 rgba8 在显存存储占用的内存</h2>
<h2 id="5导入一张很大的-png-需要在-cpu-gpu-做哪些操作">（5）导入一张很大的 png 需要在 cpu、gpu 做哪些操作</h2>
<h2 id="6对于不透明-png-的导入有什么优化cpu-gpu">（6）对于不透明 png 的导入有什么优化？（cpu、gpu）</h2>
<h2 id="7给一张纹理接下来的流程是怎样的封装了哪些接口">（7）给一张纹理接下来的流程是怎样的？封装了哪些接口？</h2>
<p>创建纹理时传递的数据格式是什么？</p>
<h2 id="8动态合批">（8）动态合批</h2>
<h1 id="6-场景结构">6. 场景结构</h1>
<h2 id="1渲染场景是怎么组织的有哪些节点">（1）渲染场景是怎么组织的？有哪些节点？</h2>
<h2 id="2大型场景中如何避免循环引用不是加-weakptr-这么简单">（2）大型场景中如何避免循环引用？不是加 weakptr 这么简单</h2>
<h1 id="7-hdr">7. hdr</h1>
<h2 id="1高斯模糊几个-pass">（1）高斯模糊（几个 pass？）</h2>
<h2 id="2bloom">（2）bloom</h2>
<h1 id="8-glsl">8. glsl</h1>
<h2 id="1手写判断一个点在方向内外">（1）手写判断一个点在方向内/外</h2>
<h1 id="9-剔除技术">9. 剔除技术</h1>
<h2 id="1视锥体剔除cpugpu">（1）视锥体剔除（cpu/gpu）</h2>
<h2 id="2背面剔除">（2）背面剔除</h2>
<h2 id="3顶点命中率">（3）顶点命中率</h2>
<ul>
<li>顶点命中率是用来衡量 顶点着色器执行效率 的一个经验指标。值越高，说明剔除和索引复用做得越好。</li>
<li>顶点命中率 = 被光栅化后真正进入片元阶段的顶点数 / 顶点着色器实际执行次数</li>
<li>为什么不是 100 %
<ul>
<li>视锥剔除、背面剔除、Early-Z/Screen-Space Culling 会让某些三角形在光栅化前就被扔掉。</li>
<li>重复顶点（索引缓存命中失败、分块渲染、GPU wave 粒度）会让同一个顶点被多次执行 VS。</li>
<li>细分/几何着色器放大 会额外产生顶点。</li>
</ul>
</li>
<li>典型场景
<ul>
<li>静态网格 + 良好索引 → 95 %–99 %</li>
<li>粒子系统（大量屏幕外）→ 20 %–60 %</li>
<li>细分曲面 + 高放大 → 10 %–30 %</li>
</ul>
</li>
<li>如何查看
<ul>
<li>Pix / RenderDoc：统计 VS Invocations vs. VS Output Vertices。</li>
<li>Unreal Engine：stat gpu 里有 Vertex Hit Rate 列。</li>
<li>Unity SRP：Frame Debugger 里看 VS wave occupancy 与 culled vertices。</li>
</ul>
</li>
</ul>
<h1 id="10-ao-算法">10. AO 算法</h1>
<h2 id="1-ssao">(1) SSAO</h2>
<h2 id="2-其他-ao-算法">(2) 其他 AO 算法</h2>
<h1 id="11-aa-算法">11. AA 算法</h1>
<h2 id="1fxaa">（1）FXAA</h2>
<h2 id="2taa">（2）TAA</h2>
<h2 id="3其他-aa">（3）其他 AA</h2>
<p>msaa 会对 colorbuffer 增加开销吗？对 depthbuffer 呢？</p>
<h1 id="12">12.</h1>
<h1 id="杂项">杂项</h1>
<h2 id="1项目坐标系">（1）项目坐标系</h2>
<h2 id="2">（2）</h2>
<h2 id="3几何着色器用在哪里了">（3）几何着色器用在哪里了？</h2>
<h2 id="4">（4）</h2>
<h2 id="5ndc-到屏幕坐标的变换">（5）ndc 到屏幕坐标的变换</h2>
<h2 id="6opengl-对图像旋转缩放">（6）opengl 对图像旋转缩放</h2>
<h2 id="7取-a-的前-4-个字节和-b-的后-4-个字节然后组成一个新的字节如何操作">（7）取 a 的前 4 个字节和 b 的后 4 个字节，然后组成一个新的字节，如何操作？</h2>
<h2 id="8gltf-中的内容obj-中的内容">（8）.gltf 中的内容？.obj 中的内容？</h2>
<h2 id="9项目中是否用到过智能指针">（9）项目中是否用到过智能指针？</h2>
<ul>
<li>GLFramebuffer.h 中构造函数里用 unique_ptr 存储纹理对象指针。每个纹理对象只属于这一个帧缓冲对象；当 GLFramebuffer 对象销毁时，纹理会自动删除；避免内存泄漏，确保纹理资源在帧缓冲销毁时被正确释放。如果构造函数中发生异常，unique_ptr 会自动清理已创建的纹理避免部分初始化状态下的资源泄漏。</li>
</ul>
<h2 id="10延迟渲染和前向渲染差别延迟渲染遇到多材质怎么办延迟渲染是否支持-msaa">（10）延迟渲染和前向渲染差别？延迟渲染遇到多材质怎么办？延迟渲染是否支持 msaa？</h2>
<h2 id="11opengl-渲染管线">（11）OpenGL 渲染管线</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/" class="category-chain-item">Graphics</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/graphics/" class="print-no-link">#graphics</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Summary and review of My OpenGL-based renderer</div>
      <div>http://example.com/2025/08/12/NextRendererSummary/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 12, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/28/sorting-algo/" title="Summary of common sorting algorithms and solutions">
                        <span class="hidden-mobile">Summary of common sorting algorithms and solutions</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
