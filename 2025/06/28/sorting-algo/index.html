

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="之前面试中碰到手撕归并排序的问题，故在此总结常见排序算法和相关的题目。 插入排序（比较排序） — 熟悉 — 基本思想 每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。 代码实现 123456789101112131415161718def insertion_sort(nums):    list_len &#x3D; len(nums)    # 循环不变量：">
<meta property="og:type" content="article">
<meta property="og:title" content="Summary of common sorting algorithms and solutions">
<meta property="og:url" content="http://example.com/2025/06/28/sorting-algo/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="之前面试中碰到手撕归并排序的问题，故在此总结常见排序算法和相关的题目。 插入排序（比较排序） — 熟悉 — 基本思想 每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。 代码实现 123456789101112131415161718def insertion_sort(nums):    list_len &#x3D; len(nums)    # 循环不变量：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-28T13:17:40.261Z">
<meta property="article:modified_time" content="2025-07-01T12:40:24.653Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Summary of common sorting algorithms and solutions - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Summary of common sorting algorithms and solutions"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-28 21:17" pubdate>
          June 28, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.9k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          83 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Summary of common sorting algorithms and solutions</h1>
            
            
              <div class="markdown-body">
                
                <p>之前面试中碰到手撕归并排序的问题，故在此总结常见排序算法和相关的题目。</p>
<h1 id="插入排序比较排序">插入排序（比较排序）</h1>
<p>— <strong>熟悉</strong> —</p>
<h2 id="基本思想">基本思想</h2>
<p>每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">nums</span>):<br>    list_len = <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment"># 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, list_len):<br>        <span class="hljs-comment"># 先暂存这个元素，然后之前元素逐个后移，留出空位</span><br>        temp = nums[i]<br>        j = i<br><br>        <span class="hljs-comment"># 注意边界 j &gt; 0</span><br>        <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[j - <span class="hljs-number">1</span>] &gt; temp:<br>            nums[j] = nums[j - <span class="hljs-number">1</span>]<br>            j -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 将暂存的元素插入到正确的位置</span><br>        nums[j] = temp<br><br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p>时间复杂度：O(N^2)，这里 N 是数组的长度；<br>
空间复杂度：O(1)，使用到常数个临时变量。</p>
<h2 id="优点">优点</h2>
<p>由于「插入排序」在「几乎有序」的数组上表现良好（在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 O(N)），特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。</p>
<h2 id="插入排序相关题目">插入排序相关题目</h2>
<h3 id="leetcode-147-用插入排序对链表排序">leetcode 147. 用插入排序对链表排序</h3>
<p>用插入排序对链表排序(<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insertion-sort-list/description/">https://leetcode.cn/problems/insertion-sort-list/description/</a>)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertionSortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-comment"># a dummy head pointing to original head so that we won&#x27;t lose the head of the list</span><br>        dummyHead = ListNode(<span class="hljs-number">0</span>)<br>        dummyHead.<span class="hljs-built_in">next</span> = head<br>        cur = head.<span class="hljs-built_in">next</span><br>        cur_sorted = head <span class="hljs-comment"># pointing to the end of the sorted part</span><br>        <span class="hljs-keyword">while</span> cur:<br>            <span class="hljs-keyword">if</span> cur_sorted.val &lt;= cur.val:<br>                <span class="hljs-comment"># current value is greater than the greatest value in the sorted part</span><br>                <span class="hljs-comment"># then no need to sort, just move the end</span><br>                cur_sorted = cur_sorted.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># search from the head to the end of the sorted part until find a node whose next value is greater than current value</span><br>                <span class="hljs-comment"># insert the current node after that node</span><br>                prev = dummyHead<br>                <span class="hljs-keyword">while</span> prev.<span class="hljs-built_in">next</span>.val &lt; cur.val:<br>                    prev = prev.<span class="hljs-built_in">next</span><br>                <span class="hljs-comment"># remove current node from the remaining list</span><br>                cur_sorted.<span class="hljs-built_in">next</span> = cur.<span class="hljs-built_in">next</span><br>                <span class="hljs-comment"># insert between prev and its next</span><br>                cur.<span class="hljs-built_in">next</span> = prev.<span class="hljs-built_in">next</span><br>                prev.<span class="hljs-built_in">next</span> = cur<br>            cur = cur_sorted.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h1 id="堆排序">堆排序</h1>
<h1 id="归并排序比较排序">归并排序（比较排序）</h1>
<p>—<strong>重点</strong>—</p>
<h2 id="归并排序基本思想">归并排序基本思想</h2>
<p>其基本思想是分治法。要排序长度为 n 的数组，则先借助额外空间排序两个长度为 n/2 的子数组，然后将两个排序后的子数组合并。</p>
<h2 id="归并排序代码实现">归并排序代码实现</h2>
<p>记住递归的方法就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">self, src: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], dst: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start:<span class="hljs-built_in">int</span>, end:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> start == end - <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># if there&#x27;s only one element in the list, no need to sort</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># Sort left and right</span><br>        mid = start + (end - start) // <span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.mergeSort(dst, src, start, mid)<br>        <span class="hljs-variable language_">self</span>.mergeSort(dst, src, mid, end)<br>        <span class="hljs-comment"># Merge</span><br>        i, j, k = start, mid, start <span class="hljs-comment"># pointers pointing to the left part, right part and dst, note to use `start`` instead of zero</span><br>        <span class="hljs-keyword">while</span>(k &lt; end):<br>            <span class="hljs-comment"># put the element in the left part into dst when the right part has no remaining element or there are remaining elements in both parts and the one in left part is smaller</span><br>            <span class="hljs-comment"># Note that to implement stable sorting we need to let src[i] &lt;= src[j] instead of using &lt;</span><br>            <span class="hljs-keyword">if</span> (j == end <span class="hljs-keyword">or</span> (i &lt; mid <span class="hljs-keyword">and</span> src[i] &lt;= src[j])):<br>                dst[k] = src[i]<br>                i += <span class="hljs-number">1</span> <span class="hljs-comment"># move pointer</span><br>            <span class="hljs-keyword">else</span>:<br>                dst[k] = src[j]<br>                j += <span class="hljs-number">1</span><br>            k += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># self.recursiveHelper(nums, 0, len(nums)-1)</span><br>        dst = <span class="hljs-built_in">list</span>(nums)<br>        <span class="hljs-variable language_">self</span>.mergeSort(nums, dst, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">return</span> dst<br></code></pre></td></tr></table></figure>
<h2 id="归并排序复杂度">归并排序复杂度</h2>
<p>时间复杂度：O(NlogN)，这里 N 是数组的长度；<br>
空间复杂度：O(N)，辅助数组与输入数组规模相当。</p>
<h2 id="归并排序特点">归并排序特点</h2>
<p>快速排序和归并排序的平均时间复杂度都是 O(nlogn)，但是快速排序在某些输入（如已经接近排序或有大量重复值）的时候性能会退化为 O(n)，而归并排序理论上不会退化。快速排序使用递归栈的深度导致空间复杂度为 O(logn)，而归并排序则需要 O(n)的额外空间（dst）。归并排序比快速排序好的一点是，它借助了额外空间，可以实现稳定排序。</p>
<h2 id="归并排序相关题目">归并排序相关题目</h2>
<h3 id="leetcode-77-链表排序">Leetcode 77. 链表排序</h3>
<ul>
<li>
<p>时间复杂度为 O(nlogn)的算法包括快排（对于链表则需要 O(n)才能通过下标获取值）、堆排序（不可能直接利用链表实现堆排序需要 O(n)的数组来实现堆，本质是给堆中的节点编号，数组的下标对应各个编号）、归并排序，其中最适合链表的是归并排序。自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(logn)。如果要达到 O(1) 的空间复杂度，则需要使用自底向上的实现方式。</p>
</li>
<li>
<p>归并排序链表的思路是：</p>
<ul>
<li>首先求得链表的长度 length，然后将链表拆分成子链表进行合并。
<ul>
<li>用 subLength 表示每次需要排序的子链表的长度，初始时 <strong>subLength=1</strong>。</li>
<li>每次将链表拆分成若干个长度为 subLength 的子链表（最后一个子链表的长度可以小于 subLength），按照每两个子链表一组进行合并，合并后即可得到若干个长度为 subLength×2 的有序子链表（最后一个子链表的长度可以小于 subLength×2）。</li>
<li>将 subLength 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 length，整个链表排序完毕。</li>
</ul>
</li>
<li>如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。
<ul>
<li>初始时 subLength=1，每个长度为 1 的子链表都是有序的。</li>
<li>如果每个长度为 subLength 的子链表已经有序，合并两个长度为 subLength 的有序子链表，得到长度为 subLength×2 的子链表，一定也是有序的。</li>
<li>当最后一个子链表的长度小于 subLength 时，该子链表也是有序的，合并两个有序子链表之后得到的子链表一定也是有序的。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>因为涉及合并两个有序链表，所以可以先看 leetcode 21. 合并有序链表（O(n)）。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummyHead = ListNode(-<span class="hljs-number">1</span>)<br>        prev = dummyHead <span class="hljs-comment"># the tail of the result</span><br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:<br>                prev.<span class="hljs-built_in">next</span> = list1<br>                list1 = list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                prev.<span class="hljs-built_in">next</span> = list2<br>                list2 = list2.<span class="hljs-built_in">next</span><br>            prev = prev.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> list2<br><br>        <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<ul>
<li>根据上面思路，归并排序链表的代码如下。时间复杂度为 O(nlogn)，空间复杂度为 O(1)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># sort two linked list and merge</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:<br>        <span class="hljs-comment"># only merge no sort in this function because we start from only one element, which must be sorted, and so the two-element/four-element list is also sorted, etc.</span><br>        dummyHead = ListNode(-<span class="hljs-number">1</span>)<br>        prev = dummyHead<br>        <span class="hljs-keyword">while</span> (l1 <span class="hljs-keyword">and</span> l2):<br>            <span class="hljs-keyword">if</span> l1.val &lt;= l2.val:<br>                prev.<span class="hljs-built_in">next</span> = l1<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                prev.<span class="hljs-built_in">next</span> = l2<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            prev = prev.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> l2<br>        <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> head<br>        <span class="hljs-comment"># 1. iterate to calculate the length of the linked list</span><br>        length = <span class="hljs-number">0</span><br>        tmp = head<br>        <span class="hljs-keyword">while</span> tmp:<br>            length += <span class="hljs-number">1</span><br>            tmp = tmp.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 2. iterate from sublength = 1 each time sublength *= 2.</span><br>        dummyHead = ListNode(-<span class="hljs-number">1</span>, head) <span class="hljs-comment"># used to return the result</span><br>        subLength = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> subLength &lt; length:<br>            <span class="hljs-comment"># each time process the sub lists from the start</span><br>            prev, curr = dummyHead, dummyHead.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">while</span> curr:<br>                head1 = curr <span class="hljs-comment"># head1 is at the start</span><br>                <span class="hljs-comment"># move curr to the end of the head1 list</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, subLength):<br>                    <span class="hljs-keyword">if</span> curr.<span class="hljs-built_in">next</span>:<br>                        curr = curr.<span class="hljs-built_in">next</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span> <span class="hljs-comment"># if there are less element than subLength just break</span><br>                head2 = curr.<span class="hljs-built_in">next</span> <span class="hljs-comment"># store head2 after the end of head1</span><br>                curr.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span> <span class="hljs-comment"># cut the connection between head1 tail and main list</span><br>                curr = head2 <span class="hljs-comment"># let curr be the beginning of head2 again to move it to its end</span><br>                <span class="hljs-comment"># move curr to the end of the head2 list</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, subLength):<br>                    <span class="hljs-keyword">if</span> curr <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>: <span class="hljs-comment"># remember to check curr</span><br>                        curr = curr.<span class="hljs-built_in">next</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span> <span class="hljs-comment"># if there are less element than subLength just break</span><br>                succ = <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">if</span> curr:<br>                    succ = curr.<span class="hljs-built_in">next</span> <span class="hljs-comment"># store the remaining main list</span><br>                    curr.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span> <span class="hljs-comment"># cut the connection between head2 tail and the main list</span><br>                <span class="hljs-comment">#</span><br>                merged = <span class="hljs-variable language_">self</span>.merge(head1, head2)<br>                prev.<span class="hljs-built_in">next</span> = merged <span class="hljs-comment"># connect merged list to the result</span><br>                <span class="hljs-keyword">while</span> prev.<span class="hljs-built_in">next</span>: <span class="hljs-comment"># move the prev to the current end of result list</span><br>                    prev = prev.<span class="hljs-built_in">next</span><br>                curr = succ <span class="hljs-comment"># let curr be at the head of the remaining main list</span><br>            subLength *= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h3 id="leetcode-78-合并-k-个升序链表">Leetcode 78. 合并 k 个升序链表</h3>
<p>把 lists 一分为二（尽量均分），先合并前一半的链表，再合并后一半的链表，然后把这两个链表合并成最终的链表。为合并前一半的链表，继续将其一分为二。如此分下去直到只有一个链表，此时无需合并。这里仍然会用到前面合并两个升序链表的经典操作。</p>
<p>按照一分为二再合并的逻辑，递归像是在后序遍历一棵平衡二叉树。由于平衡树的高度是 O(logk)，所以每个链表节点只会出现在 O(logk) 次合并中，这样就做到了 O(nlogk) 时间复杂度，而空间复杂度为 O(logk)因为递归深度为 O(logk)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, l1, l2</span>):<br>        dummyHead = ListNode(-<span class="hljs-number">1</span>)<br>        prev = dummyHead<br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>            <span class="hljs-keyword">if</span> l1.val &lt;= l2.val:<br>                prev.<span class="hljs-built_in">next</span> = l1<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                prev.<span class="hljs-built_in">next</span> = l2<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            prev = prev.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> l2<br>        <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[ListNode]</span>) -&gt; ListNode:<br>        m = <span class="hljs-built_in">len</span>(lists)<br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]<br>        left = <span class="hljs-variable language_">self</span>.mergeKLists(lists[:m//<span class="hljs-number">2</span>])<br>        right = <span class="hljs-variable language_">self</span>.mergeKLists(lists[m//<span class="hljs-number">2</span>:])<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.mergeTwoLists(left, right)<br></code></pre></td></tr></table></figure>
<h3 id="leetcode-170-交易逆序对">Leetcode 170. 交易逆序对</h3>
<ul>
<li>在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。
<ul>
<li>示例：<br>
输入：record = [9, 7, 5, 4, 6]<br>
输出：8<br>
解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。</li>
</ul>
</li>
<li>思路：在归并排序中合并的一步（<code>while k&lt;end</code>）时需要对比左右指针所指的数字的大小，一旦发现<code>src[i] &gt; src[j]</code>，就说明<code>src[i, mid) &gt;= src[i] &gt; src[j]</code>，也就是说左侧有 mid-i 个数字比右边大，这就造成了 mid-i 个逆序对。注意循环中判断左右是否都还有剩余的数字。而递归的逻辑是在此之前，如果数组中小于等于一个数字只会有一个逆序对（递归终止），否则递归求左右两侧的逆序对个数。最终的结果就是左侧逆序对个数+右侧逆序对个数+左右对比新求得的逆序对个数。</li>
<li>复杂度：其复杂度和归并排序一致，时间复杂度为 O(nlogn)，空间复杂度为 O(n)（辅助数组）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">self, src: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], dst: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-comment"># 1个或0个record的时候逆序对只有一个，停止递归</span><br>        <span class="hljs-keyword">if</span> end - start &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        ans = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录当前逆序对数目</span><br>        mid = start + (end-start)//<span class="hljs-number">2</span><br>        ans += <span class="hljs-variable language_">self</span>.mergeSort(dst, src, start, mid) <span class="hljs-comment"># 左半部分逆序对数目</span><br>        ans += <span class="hljs-variable language_">self</span>.mergeSort(dst, src, mid, end) <span class="hljs-comment"># 右半部分逆序对数目</span><br>        i, j, k = start, mid, start<br>        <span class="hljs-keyword">while</span> (k &lt; end):<br>            <span class="hljs-keyword">if</span> i == mid:<br>                <span class="hljs-comment"># 如果左半部分耗尽，不会再有逆序对</span><br>                dst[k] = src[j]<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> j == end:<br>                <span class="hljs-comment"># 如果右半部分耗尽，不会再有逆序对</span><br>                dst[k] = src[i]<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> (src[i] &lt;= src[j]):<br>                dst[k] = src[i]<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 右半部分，即后半部分较小，出现了逆序对</span><br>                dst[k] = src[j]<br>                j += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 本质是要确定当前放进合并数组的数字src[j]在合并前的原数组中左侧有多少个比它大的数字</span><br>                <span class="hljs-comment"># 若当前放入src[j]，则src[i:mid]一定在合并数组中在src[j]右边</span><br>                <span class="hljs-comment"># 即src[i:mid] &gt; src[j], 而这些数字位于左数组说明在原数组中它们都在src[j]左侧</span><br>                <span class="hljs-comment"># 则src[j]左侧共有mid-i个数字比它大，共造成 mid-i 项逆序对</span><br>                ans += (mid - i) <span class="hljs-comment"># 当前值 nums[j] 贡献的逆序对个数为 mid-i</span><br>            k += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reversePairs</span>(<span class="hljs-params">self, record: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(record)<br>        dst = <span class="hljs-built_in">list</span>(record)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.mergeSort(record, dst, <span class="hljs-number">0</span>, n)<br></code></pre></td></tr></table></figure>
<h3 id="leetcode-315-计算右侧小于当前元素的个数">Leetcode 315. 计算右侧小于当前元素的个数</h3>
<ul>
<li>
<p>给一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<ul>
<li>示例：<br>
输入：nums = [5,2,6,1]<br>
输出：[2,1,1,0]</li>
</ul>
</li>
<li>
<p>思路：在 leetcode 170 中，通过求解左侧有多少个数字大于 nums[j]来求得逆序对数，而本题中要求解的是 nums[i] 右侧小于 nums[i] 的元素的数量。这里的左和右是指在未排序的原数组中。注意到，在常规的归并排序过程中，数组中的元素其位置会发生变化，而在本题中我们则需要<strong>记录下每个元素的初始位置</strong>，以便将每个元素贡献的逆序对数目归功到对应的位置上。</p>
<ul>
<li>如何记录每个元素的初始位置？单独创建一个索引数组来存储。注意因为多了这个索引数组，本体没有再使用 src/dst 交换的方式，而是用类变量 temp 和相对应的 temp_index 暂时存储排序结果，一轮排序归并后把 temp 里的结果复制回原数组。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">tuple</span>], start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> end - start &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span><br>        mid = start + (end-start)//<span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.mergeSort(nums, start, mid)<br>        <span class="hljs-variable language_">self</span>.mergeSort(nums, mid, end)<br>        i, j, k = start, mid, start<br>        <span class="hljs-keyword">while</span> (k &lt; end):<br>            <span class="hljs-keyword">if</span> (i == mid):<br>                <span class="hljs-variable language_">self</span>.temp[k] = nums[j]<br>                <span class="hljs-variable language_">self</span>.temp_index[k] = <span class="hljs-variable language_">self</span>.index[j]<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> (j == end):<br>                <span class="hljs-variable language_">self</span>.temp[k] = nums[i]<br>                <span class="hljs-variable language_">self</span>.temp_index[k] = <span class="hljs-variable language_">self</span>.index[i]<br>                <span class="hljs-comment"># 本质是计算在未合并的原数组中nums[i]右侧有多少个数字比它小</span><br>                <span class="hljs-comment"># 此时右侧数组所有数字都已经被放进合并后的数组了，也就是说他们都比nums[i]小</span><br>                <span class="hljs-comment"># 而右侧数组中所有数字在原始数组中都在nums[i]的右侧，所以共j-mid个</span><br>                <span class="hljs-variable language_">self</span>.ans[<span class="hljs-variable language_">self</span>.index[i]] += (j-mid)<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> (nums[i] &lt;= nums[j]):<br>                <span class="hljs-variable language_">self</span>.temp[k] = nums[i]<br>                <span class="hljs-variable language_">self</span>.temp_index[k] = <span class="hljs-variable language_">self</span>.index[i]<br>                <span class="hljs-comment"># 本质是计算在未合并的原数组中nums[i]右侧有多少个数字比它小</span><br>                <span class="hljs-comment"># nums[i] &lt;= nums[j] 则可以确定右边数组里nums[mid:j]已经被放进合并后的数组了</span><br>                <span class="hljs-comment"># 也就是说nums[mid:j] &lt; nums[i]</span><br>                <span class="hljs-comment"># 而nums[mid:j]在合并前原数组中又在nums[i]的右侧，</span><br>                <span class="hljs-comment"># 则可以确定nums[i]右侧有j-mid个数字比它小</span><br>                <span class="hljs-variable language_">self</span>.ans[<span class="hljs-variable language_">self</span>.index[i]] += (j - mid)<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-variable language_">self</span>.temp[k] = nums[j]<br>                <span class="hljs-variable language_">self</span>.temp_index[k] = <span class="hljs-variable language_">self</span>.index[j]<br>                j += <span class="hljs-number">1</span><br>            k += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 将临时空间 temp 和 tempIndex 中排列好的、有序的结果，覆盖写回到原始的 nums 和 index 数组</span><br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, end):<br>            <span class="hljs-variable language_">self</span>.index[idx] = <span class="hljs-variable language_">self</span>.temp_index[idx]<br>            nums[idx] = <span class="hljs-variable language_">self</span>.temp[idx]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countSmaller</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure>
<h1 id="快速排序比较排序">快速排序（比较排序）</h1>
<p>—<strong>重点</strong>—</p>
<h2 id="基本思想">基本思想</h2>
<p>其基本思想也是分治法。首先从数组中随机取一个数作为中间值（pivot），然后对数组进行分区（partition），把数组中所有小于中间值的数放到中间值的左边，所有大于中间值的数放在其右边。然后对中间值左右的两个子数组用上述相同的方法分别排序，直到子数组中只有一个元素。这个过程可以通过递归实现。当表现良好时，该算法可以比归并排序等其他算法快 2~3 倍。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="单路快排">单路快排</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用快速排序对列表进行原地排序。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        arr: 待排序的整数列表。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr:<br>        <span class="hljs-keyword">return</span><br>    _quick_sort_recursive(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_quick_sort_recursive</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归地对 arr[low..high] 进行快速排序。&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> low &lt; high:<br>        <span class="hljs-comment"># partition an d get the pivot&#x27;s final index</span><br>        pivot_index = _partition(arr, low, high)<br><br>        <span class="hljs-comment"># 递归地对基准左边的子数组进行排序</span><br>        _quick_sort_recursive(arr, low, pivot_index - <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 递归地对基准右边的子数组进行排序</span><br>        _quick_sort_recursive(arr, pivot_index + <span class="hljs-number">1</span>, high)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_partition</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Lomuto 分区方案。选择 arr[high] 作为基准。</span><br><span class="hljs-string">    将小于基准的元素移到左边，大于的移到右边。</span><br><span class="hljs-string">    返回基准最后所在的索引。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    pivot = arr[high]  <span class="hljs-comment"># 选择最后一个元素作为基准</span><br>    <span class="hljs-comment"># 或随机选择一个基准的索引</span><br>    <span class="hljs-comment"># pivot_random_index = random.randint(low, high)</span><br>    i = low - <span class="hljs-number">1</span>  <span class="hljs-comment"># i 是“小于基准”区域的右边界</span><br><br>    <span class="hljs-comment"># 遍历 low 到 high-1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low, high):<br>        <span class="hljs-keyword">if</span> arr[j] &lt; pivot:<br>            i += <span class="hljs-number">1</span>  <span class="hljs-comment"># 扩展“小于基准”的区域</span><br>            arr[i], arr[j] = arr[j], arr[i]  <span class="hljs-comment"># 将当前元素换入该区域</span><br><br>    <span class="hljs-comment"># 遍历结束后，i+1 的位置就是基准应该在的位置</span><br>    <span class="hljs-comment"># 将基准换到正确的位置</span><br>    arr[i + <span class="hljs-number">1</span>], arr[high] = arr[high], arr[i + <span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::swap</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Lomuto 分区函数。选择 arr[high] 作为基准。</span><br><span class="hljs-comment"> * @return 基准最后所在的索引。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[high]; <span class="hljs-comment">// 选择最后一个元素作为基准</span><br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;       <span class="hljs-comment">// “小于基准”区域的右边界</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; pivot) &#123;<br>            i++;<br>            std::<span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 递归地对 arr[low..high] 进行快速排序。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortRecursive</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(arr, low, high);<br><br>        <span class="hljs-built_in">quickSortRecursive</span>(arr, low, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSortRecursive</span>(arr, pivot_index + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 使用快速排序对向量进行原地排序的主函数。</span><br><span class="hljs-comment"> * @param arr 待排序的整数向量。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">quickSortRecursive</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="双路三路快排">双路/三路快排</h3>
<ul>
<li>
<p>如上演示的是<strong>单路分区</strong>的快排（Lomuto 分区），即使用一个中间值将数组分为两部分：<code>[start, i]</code>为小于 pivot 的元素，<code>(i, j]</code>为大于等于 pivot 的元素。遍历数组（<code>j</code>从<code>start</code>到<code>end-1</code>），将小于 pivot 的元素交换到前面。这样写思路简单但是效率较低，如在 leetcode 912. 中会因为超出时间限制而无法通过某些用例。当数组中存在大量与基准值相等的重复元素时，这些重复元素会被全部划分到一侧（通常是左侧）。这会导致分区极其不平衡，例如，若对一个所有元素都相同的数组进行排序，每次分区都会形成一个包含 n-1 个元素的子数组和一个空数组。在这种情况下，快速排序的时间复杂度会从平均的 O(n log n) 退化到最坏的 O(n²)，并且可能导致递归深度过大，引发栈溢出。所以通常使用双路、三路的快排（包括在 leetcode 215 中）。</p>
</li>
<li>
<p>双路分区 (Hoare Partition)</p>
<ol>
<li>选择基准值 (pivot)：通常选择待排序区间的第一个元素。</li>
<li>初始化指针：设置两个指针，i 从左边界的下一个位置开始（l+1），j 从右边界开始（r）。</li>
<li>双向扫描：</li>
</ol>
<ul>
<li>指针 i 从左向右移动，直到找到一个大于等于 pivot 的元素 (arr[i] &gt;= pivot)。</li>
<li>指针 j 从右向左移动，直到找到一个小于等于 pivot 的元素 (arr[j] &lt;= pivot)。</li>
</ul>
<ol start="4">
<li>交换与继续：</li>
</ol>
<ul>
<li>如果此时 i &lt; j，则交换 arr[i] 和 arr[j] 的值。</li>
</ul>
<ol start="5">
<li>重复步骤 3，直到 i 越过 j (i &gt;= j)。</li>
<li>放置基准值：扫描结束后，将基准值 pivot（arr[l]）与指针 j 指向的元素 arr[j] 进行交换。此时，arr[j] 左边的元素都小于或等于它，右边的都大于或等于它。</li>
</ol>
</li>
<li>
<p>三路分区 (Three-Way Partitioning / Dutch National Flag Problem)</p>
<ol>
<li>选择基准值 (pivot)：同样选择待排序区间的第一个元素。</li>
<li>初始化指针：<br>
lt (less than)：指向小于部分的下一个位置，初始为 l。<br>
gt (greater than)：指向大于部分的前一个位置，初始为 r+1。<br>
i：当前扫描的元素指针，初始为 l+1。</li>
<li>扫描与分区：<br>
从 i 开始遍历数组，直到 i 与 gt 相遇 (i &lt; gt)。</li>
</ol>
<ul>
<li>情况一：arr[i] &lt; pivot
<ul>
<li>交换 arr[lt+1] 和 arr[i]。</li>
<li>lt 和 i 指针都向右移动一位。</li>
</ul>
</li>
<li>情况二：arr[i] &gt; pivot
<ul>
<li>交换 arr[i] 和 arr[gt-1]。</li>
<li>gt 指针向左移动一位。</li>
<li>i 指针不动，因为交换过来的新 arr[i] 还需要进行下一轮的比较。</li>
</ul>
</li>
<li>情况三：arr[i] == pivot
<ul>
<li>i 指针直接向右移动一位。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>放置基准值：遍历结束后，将 arr[l] (pivot) 与 arr[lt] 交换。最终，数组被分为三部分：<br>
[l, lt-1]：所有元素小于 pivot。<br>
[lt, gt-1]：所有元素等于 pivot。<br>
[gt, r]：所有元素大于 pivot。</li>
</ol>
<ul>
<li>关键优势：三路分区的最大优势在于，它将所有与 pivot 相等的元素 一次性地放置到了最终位置。在后续的递归排序中，这个“等于 pivot”的区间将不再需要处理，只需要递归地对“小于”和“大于”的两个子区间进行排序。当数组中重复元素非常多时，这种优化带来的性能提升是极其显著的，甚至可以将处理这些元素的复杂度降到线性时间。</li>
</ul>
</li>
</ul>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>时间复杂度:<br>
平均情况: O(nlogn)。在理想情况下，每次分区都能将数组分成大致相等的两半，递归树的深度为 O(logn)，每层的工作量为 O(n)。最坏情况: O(n^2)。当每次选择的基准都是当前数组的最小值或最大值时（例如，对一个已经排好序的数组使用最后一个元素做基准），分区会极度不平衡，导致递归树退化成一个链表，深度为 O(n)。</li>
<li>空间复杂度:<br>
O(logn) (平均) 到 O(n) (最坏)。这个空间主要用于递归调用栈。</li>
<li>稳定性:<br>
快速排序是一种不稳定的排序算法。在分区过程中，相等元素的原始相对顺序可能会被改变。</li>
<li>优化:<br>
为了避免最坏情况，可以优化基准的选择，例如采用“三数取中法”（比较开头、中间、结尾三个元素，取中间值作为基准）或随机选择基准。</li>
</ul>
<h2 id="优化后的快排"><strong>优化后的快排</strong></h2>
<p>上述单路分区效率较低，实际直接写下方优化过的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        pivot = nums[start]<br>        i, j = start, end<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>            <span class="hljs-keyword">while</span>(nums[i]&lt;pivot):<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(nums[j]&gt;pivot):<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> (i&gt;=j):<br>                <span class="hljs-keyword">break</span><br>            nums[i], nums[j] = nums[j], nums[i]<br>            <span class="hljs-comment"># 交换后，强制移动指针，以防止因 nums[i] == nums[j] == pivot 导致的无限循环</span><br>            i += <span class="hljs-number">1</span><br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> j<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursiveHelper</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span>(start &lt; end):<br>             <span class="hljs-comment"># 【关键优化】在分区前，随机选择一个元素作为基准</span><br>            <span class="hljs-comment"># 1. 随机选择一个索引</span><br>            pivot_idx = random.randint(start, end)<br>            <span class="hljs-comment"># 2. 将它与区间的第一个元素交换</span><br>            nums[start], nums[pivot_idx] = nums[pivot_idx], nums[start]<br>            pivot_index = <span class="hljs-variable language_">self</span>.partition(nums, start, end)<br>            <span class="hljs-variable language_">self</span>.recursiveHelper(nums, start, pivot_index)<br>            <span class="hljs-variable language_">self</span>.recursiveHelper(nums, pivot_index+<span class="hljs-number">1</span>, end)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-variable language_">self</span>.recursiveHelper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[start]; <span class="hljs-comment">// 最左侧设为pivot</span><br>        <span class="hljs-type">int</span> i = start<span class="hljs-number">-1</span>, j = end<span class="hljs-number">+1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 这里必须是 nums[i] &lt; pivot 和 nums[i] &gt; pivot，不能是 &gt;=, &lt;= 否则 有可能i永远小于j（记得一开始把最左侧设为pivot，则i=0时nums[i]==pivot，此后i不会再向右挪动）无法跳出循环。</span><br>            <span class="hljs-keyword">do</span> &#123;i++;&#125; <span class="hljs-keyword">while</span> (nums[i] &lt; pivot);<br>            <span class="hljs-keyword">do</span> &#123;j--;&#125; <span class="hljs-keyword">while</span> (nums[j] &gt; pivot);<br>            <span class="hljs-keyword">if</span> (i&gt;=j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, start, end);<br>            <span class="hljs-comment">// 为什么不是</span><br>            <span class="hljs-comment">// recursiveHelper(nums, start, pivot_index-1);</span><br>            <span class="hljs-comment">// recursiveHelper(nums, pivot_index+1, end);</span><br>            <span class="hljs-comment">// 因为上述是单路分区时的递归方式，单路分区时可以确定pivot_index就是pivot的位置，因此可以安全的排除此位置。</span><br>            <span class="hljs-comment">// 但双路分区返回的index，只能保证index左侧的数字都&lt;=pivot，index右侧的数字都&gt;=pivot，但index这个位置上本身未必是pivot。pivot 本身可能在左侧或右侧（都满足大于等于），所以不能排除。可以发现下方kth largest的题解也是没排除的。</span><br>            <span class="hljs-built_in">recursiveHelper</span>(nums, start, pivot_index);<br>            <span class="hljs-built_in">recursiveHelper</span>(nums, pivot_index<span class="hljs-number">+1</span>, end);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">recursiveHelper</span>(nums, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="快排相关题目">快排相关题目</h2>
<h3 id="leetcode-912-数组排序">leetcode 912. 数组排序</h3>
<h3 id="leetcode-215-数组中第-k-大的数字">leetcode 215. 数组中第 k 大的数字</h3>
<p><strong>快排中的 partition 函数还常被用于选择数组中第 k 大的数字</strong>。</p>
<p>从一个乱序数组中找出第 k 大的数字。</p>
<ul>
<li>
<p>解法 1：最小堆。每次从数据里路中读取一个数字，将其与最小堆堆顶的数字比较。当新读取的数字大于最小堆堆顶的数字时，删除堆顶的数字并将新读取的数字添加到堆中。只要保证堆的大小为 k，堆顶的数字永远是第 k 大的数字。这样做的时间复杂度是 O(nlogk)，空间复杂度时 O(k)。这种方法的场景是数据位于一个数据流中，不能一下把数据全部读入内存。</p>
</li>
<li>
<p>解法 2：如果所有数据保存在一个内存的数组中，可以用快排中的 partition 函数更快求解。</p>
<ul>
<li>在长度为 n 的排序数组中，第 k 大的数字的下标是 n-k。用 partition 函数对数组进行分区，如果 partition 函数返回的下标正好是 n-k，注意分区后 n-k 位置左边的数字都比其小，右边的数字都比其大，则即便整个数组不是排序的，第 n-k 个数字也一定是第 k 大的。如果返回的下标大于 n-k，则第 k 大的数字一定在当前中间值的左侧，于是再用 partition 函数对左侧的子数组分区。如果返回的下标小于 n-k，则第 k 大的数字一定在当前中间值的右侧，于是再用 partition 函数对右侧的子数组分区。重复这个过程直到 partition 函数的返回值正好是 n-k。</li>
<li>代码实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_kth_largest</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用 Quickselect 算法（基于 partition）寻找数组中第 k 大的元素。</span><br><span class="hljs-string">    LeetCode #215. Kth Largest Element in an Array</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        nums: 乱序整数列表。</span><br><span class="hljs-string">        k: 要寻找的第 k 大。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        第 k 大的元素的值。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> k &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> k &gt; <span class="hljs-built_in">len</span>(nums):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Invalid input&quot;</span>)<br><br>    <span class="hljs-comment">#----------------------------------------------------------#</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;Lomuto 分区方案，返回基准的最终索引。&quot;&quot;&quot;</span><br>        pivot = nums[high]<br>        i = low - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low, high):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; pivot:<br>                i += <span class="hljs-number">1</span><br>                nums[i], nums[j] = nums[j], nums[i]<br>        nums[i + <span class="hljs-number">1</span>], nums[high] = nums[high], nums[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>    <span class="hljs-comment">#----------------------------------------------------------#</span><br><br>    low, high = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 我们要找的目标索引 (0-indexed from smallest)</span><br>    target_index = <span class="hljs-built_in">len</span>(nums) - k<br><br>    <span class="hljs-keyword">while</span> low &lt;= high:<br>        <span class="hljs-comment"># 随机化基准以避免最坏情况</span><br>        pivot_random_index = random.randint(low, high)<br>        nums[pivot_random_index], nums[high] = nums[high], nums[pivot_random_index]<br><br>        pivot_index = partition(low, high)<br><br>        <span class="hljs-keyword">if</span> pivot_index == target_index:<br>            <span class="hljs-keyword">return</span> nums[pivot_index]<br>        <span class="hljs-keyword">elif</span> pivot_index &lt; target_index:<br>            <span class="hljs-comment"># 目标在右侧</span><br>            low = pivot_index + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>: <span class="hljs-comment"># pivot_index &gt; target_index</span><br>            <span class="hljs-comment"># 目标在左侧</span><br>            high = pivot_index - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># This line should not be reached in a valid run</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span>    <span class="hljs-comment">// For modern C++ random number generation</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>   <span class="hljs-comment">// For std::swap</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// For std::runtime_error</span></span><br><br><span class="hljs-comment">// Partition function (can be defined inside or outside)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[high];<br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] &lt; pivot) &#123;<br>            i++;<br>            std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(nums[i + <span class="hljs-number">1</span>], nums[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>() || k &lt; <span class="hljs-number">1</span> || k &gt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid input&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> target_index = nums.<span class="hljs-built_in">size</span>() - k;<br><br>    <span class="hljs-comment">// For random pivot selection</span><br>    std::random_device rd;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;<br><br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-comment">// Randomize pivot</span><br>        std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">distrib</span>(low, high);<br>        <span class="hljs-type">int</span> pivot_random_index = <span class="hljs-built_in">distrib</span>(gen);<br>        std::<span class="hljs-built_in">swap</span>(nums[pivot_random_index], nums[high]);<br><br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, low, high);<br><br>        <span class="hljs-keyword">if</span> (pivot_index == target_index) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivot_index];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_index &lt; target_index) &#123;<br>            low = pivot_index + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            high = pivot_index - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Should not be reached</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意如下部分的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (nums[j] &lt; pivot) &#123;<br>    i++;<br>    std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处使用<code>nums[j] &lt; pivot</code>而非<code>nums[j] &lt;= pivot</code>，从而能在输入数组有非常多重复值的时候仍能正常通过不超时。<br>
如果用<code>nums[j] &lt;= pivot</code>，想象输入数组为：[3, 3, 3, 3, 3, 3, 3, 3]，需要找到中位数。任意取一个 pivot 大概率是 3（实际上本例中只可能是 3）。</p>
</li>
<li>
<p>分区循环开始。 i 位于 low - 1。 j 从 low 迭代到 high - 1。</p>
</li>
<li>
<p>对于每个元素 <code>nums[j]</code>，条件 <code>nums[j] &lt;= pivot</code> (即 3 &lt;= 3) 将为真。</p>
</li>
<li>
<p>这意味着 i 将为每个元素递增，并且每个元素将与自身交换。 分区最终将使 i 位于 high - 1。</p>
</li>
<li>
<p>最后的交换 std::swap(nums[i + 1], nums[high]); 将枢轴（位于 high）与自身（位于 i + 1，现在是 high）交换。</p>
</li>
<li>
<p>分区函数返回 high。</p>
</li>
<li>
<p>因为假设正在寻找中位数，所以 target_index 在中间的位置。但此时的 pivot_index 将是 high。</p>
</li>
<li>
<p>由于 pivot_index &gt; target_index，下一个递归调用（或循环迭代）将在范围 (low, high - 1) 上进行。</p>
</li>
<li>
<p>问题是，你只将搜索空间减少了一个元素（high=pivot-1）。 如果是一个包含许多重复项的数组，这可能会持续导致最坏情况下的 O(n^2) 性能，从而超出时间限制。随机枢轴选择在这种特定情况下没有帮助，因为无论你选择哪个’3’，结果都是一样的。</p>
</li>
</ul>
<h4 id="复杂度">复杂度</h4>
<ul>
<li>时间复杂度:
<ul>
<li>平均情况: O(n)。这虽然每次分区是 O(n)，但由于我们每次都丢弃了一半（平均）的元素，总的计算量是 n+n/2+n/4+…，这是一个收敛的等比数列，其和为 2n。因此平均复杂度是线性的 O(n)。</li>
<li>最坏情况: O(n^2)。如果每次都选到最差的基准（和快速排序一样），算法会退化。但通过随机化，这种情况在实际中几乎不可能发生。</li>
</ul>
</li>
<li>空间复杂度: O(1)。上面的实现是迭代式的（使用了 while 循环），没有递归调用，因此除了存储几个变量外，不需要额外的栈空间。</li>
</ul>
<h4 id="优化后的-kth-largest"><strong>优化后的 kth largest</strong></h4>
<p>上述方法便于理解实际中效率较低，实际见下方优化后的双路分区代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span>, target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> (start == end):<br>            <span class="hljs-keyword">return</span> nums[target]<br>        pivot_idx = random.randint(start, end)<br>        nums[start], nums[pivot_idx] = nums[pivot_idx], nums[start]<br>        pivot = nums[start]<br>        i, j = start, end<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>            <span class="hljs-keyword">while</span>(nums[i] &lt; pivot):<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(nums[j] &gt; pivot):<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> (i &gt;= j):<br>                <span class="hljs-keyword">break</span><br>            nums[i], nums[j] = nums[j], nums[i]<br>            <span class="hljs-comment"># 交换后强制移动指针防止nums[i]==nums[j]==pivot时陷入无限循环</span><br>            i += <span class="hljs-number">1</span><br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> j &lt; target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.quickSort(nums, j+<span class="hljs-number">1</span>, end, target)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.quickSort(nums, start, j, target)<br>        <span class="hljs-comment"># 注意下面这种递归逻辑是错的，因为有可能j==start，导致第一个分支下无法缩小select的范围，从而无限递归。而上方正确的逻辑中j不可能等与end，因为从上面的循环中可以发现，j会强制被向左移动至少一步。</span><br>        <span class="hljs-comment"># if j &lt;= target:</span><br>        <span class="hljs-comment">#     return self.quickSelect(nums, j, end, target)</span><br>        <span class="hljs-comment"># else:</span><br>        <span class="hljs-comment">#     return self.quickSelect(nums, start, j-1, target)</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        k_largest = <span class="hljs-variable language_">self</span>.quickSort(nums, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>, n-k)<br>        <span class="hljs-keyword">return</span> k_largest<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickselect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<br>            <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-type">int</span> partition = nums[l], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; partition);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; partition);<br>            <span class="hljs-keyword">if</span> (i &lt; j)<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt;= j)<span class="hljs-keyword">return</span> <span class="hljs-built_in">quickselect</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickselect</span>(nums, j + <span class="hljs-number">1</span>, r, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickselect</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n - k);<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/kth-largest-element-in-an-array/solutions/307351/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcod-2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>
<p>时间复杂度：O(n).<br>
空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)。</p>
<h3 id="leetcode-75-荷兰国旗颜色分类">leetcode 75. 荷兰国旗/颜色分类</h3>
<ul>
<li>
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
</li>
<li>
<p>这个问题的经典解法被称为荷兰国旗问题（Dutch National Flag problem），由计算机科学家 Edsger Dijkstra 提出。它使用三个指针来在<strong>一次遍历</strong>中完成排序：</p>
<ul>
<li>low：指向下一个应该放置 0 的位置。[0…low-1] 的区域都是 0。</li>
<li>mid：当前正在处理的位置。[low…mid-1] 的区域都是 1。</li>
<li>high：2 区的前一个位置（用于放置 2）。[high+1…end] 的区域都是 2。</li>
</ul>
<p>它们分别初始化为 0,0,n-1</p>
</li>
<li>
<p>处理逻辑：</p>
<ul>
<li>当 arr[mid] == 0：把它与 arr[low] 交换，low += 1，mid += 1</li>
<li>当 arr[mid] == 1：直接跳过，mid += 1</li>
<li>当 arr[mid] == 2：把它与 arr[high] 交换，high -= 1（注意 mid 不动，因为交换过来的值可能还需要判断）</li>
</ul>
</li>
<li>
<p>流程：指针 mid 作为活动指针，而 low,high 则是作为标记位。当前 low 左侧和 high 右侧都已经处理完毕，中间部分等待处理。如果 mid &gt; high，说明所有元素处理完成。</p>
</li>
<li>
<p>适用范围：类别数量固定且较少的「划分」问题。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortColors</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        low, mid, high = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (mid &lt;= high):<br>            <span class="hljs-keyword">if</span> nums[mid] == <span class="hljs-number">0</span>:<br>                nums[low], nums[mid] = nums[mid], nums[low]<br>                low += <span class="hljs-number">1</span><br>                mid += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[mid] == <span class="hljs-number">1</span>:<br>                mid += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                nums[mid], nums[high] = nums[high], nums[mid]<br>                high -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<h2 id="快排的性能退化">快排的性能退化</h2>
<p>快速排序在以下场景中效果不佳，甚至可能退化为低效算法：</p>
<h3 id="1-输入数据已基本有序正序或逆序">1. <strong>输入数据已基本有序（正序或逆序）</strong></h3>
<ul>
<li><strong>问题</strong>：分区操作后产生极度不平衡的分区（一个分区几乎为空，另一个包含所有元素）</li>
<li><strong>复杂度退化</strong>：时间复杂度从平均 O(n log n) → <strong>最坏 O(n²)</strong></li>
<li><strong>原因</strong>：每次选择的 pivot 都是最小/最大值（如选第一个/最后一个元素作为 pivot）</li>
<li><strong>解决方案</strong>：
<ul>
<li>随机选择 pivot (<code>swap(nums[low], nums[random(low, high)])</code>)</li>
<li>三数取中法（median-of-three）：选 <code>nums[low]</code>, <code>nums[mid]</code>, <code>nums[high]</code> 的中值</li>
</ul>
</li>
</ul>
<h3 id="2-输入数据包含大量重复元素">2. <strong>输入数据包含大量重复元素</strong></h3>
<ul>
<li><strong>问题</strong>：重复元素导致分区不平衡</li>
<li><strong>复杂度退化</strong>：可能退化为 O(n²)</li>
<li><strong>原因</strong>：标准 Lomuto/Hoare 分区无法高效处理重复值</li>
<li><strong>解决方案</strong>：改用 <strong>三路分区</strong>（Dutch National Flag 算法）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition3</span>(<span class="hljs-params">arr, low, high</span>):<br>    lt, gt = low, high<br>    pivot = arr[low]<br>    i = low<br>    <span class="hljs-keyword">while</span> i &lt;= gt:<br>        <span class="hljs-keyword">if</span> arr[i] &lt; pivot:<br>            arr[lt], arr[i] = arr[i], arr[lt]<br>            lt += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> arr[i] &gt; pivot:<br>            arr[i], arr[gt] = arr[gt], arr[i]<br>            gt -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lt, gt  <span class="hljs-comment"># 返回等于pivot的区间</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-小规模数据集n-lt-15~20">3. <strong>小规模数据集（n &lt; 15~20）</strong></h3>
<ul>
<li>
<p><strong>问题</strong>：递归调用开销超过排序本身</p>
</li>
<li>
<p><strong>性能对比</strong>：插入排序在小数据量更优</p>
</li>
<li>
<p><strong>解决方案</strong>：混合策略（如 Introsort）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">arr, low, high</span>):<br>    <span class="hljs-keyword">if</span> high - low &lt; <span class="hljs-number">15</span>:          <span class="hljs-comment"># 小数组切换插入排序</span><br>        insertion_sort(arr, low, high)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># ...快速排序主逻辑...</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-内存受限环境">4. <strong>内存受限环境</strong></h3>
<ul>
<li><strong>问题</strong>：递归栈空间消耗 O(log n) → 最坏 O(n)</li>
<li><strong>风险</strong>：可能导致栈溢出</li>
<li><strong>解决方案</strong>：
<ul>
<li>迭代实现（手动管理栈）</li>
<li>尾递归优化</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort_iterative</span>(<span class="hljs-params">arr</span>):<br>    stack = [(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">while</span> stack:<br>        low, high = stack.pop()<br>        <span class="hljs-keyword">if</span> low &lt; high:<br>            p = partition(arr, low, high)<br>            <span class="hljs-comment"># 先处理较小分区减少栈深度</span><br>            <span class="hljs-keyword">if</span> p - low &lt; high - p:<br>                stack.append((p+<span class="hljs-number">1</span>, high))<br>                stack.append((low, p-<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">else</span>:<br>                stack.append((low, p-<span class="hljs-number">1</span>))<br>                stack.append((p+<span class="hljs-number">1</span>, high))<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-稳定性要求严格的场景">5. <strong>稳定性要求严格的场景</strong></h3>
<ul>
<li><strong>问题</strong>：快速排序是<strong>不稳定排序</strong></li>
<li><strong>反例</strong>：<code>[(5, &quot;A&quot;), (3, &quot;B&quot;), (5, &quot;C&quot;)]</code> 排序后可能变为 <code>[(3, &quot;B&quot;), (5, &quot;C&quot;), (5, &quot;A&quot;)]</code></li>
<li><strong>替代方案</strong>：<strong>归并排序</strong>（稳定且 O(n log n)）</li>
</ul>
<h1 id="计数排序">计数排序</h1>
<h2 id="基本思想">基本思想</h2>
<p>计数排序是<strong>线性时间</strong>的<strong>整数</strong>排序算法，如果数组长度为 n，整数范围为 k，对于<strong>k 远小于 n</strong>的场景，计数排序的时间复杂度优于其他基于比较的算法（如归并、快排）。其基本思想是：先扫描一遍数组记录数组中的每个整数出现的次数（使用辅助数组），然后按照从小到大的顺序把，每种整数出现了几次就填入几个该整数到原数组中。</p>
<p>例如，输入整数数组<code>[2,3,4,2,3,2,1]</code>，扫描一次之后得到 1 出现 1 次，2 出现 3 次，3 出现 2 次，4 出现 1 次。于是先后在数组中填入 1 个 1，3 个 2，2 个 3，1 个 4，就得到了排序后的数组<code>[1,2,2,2,3,3,4]</code>。</p>
<h2 id="代码实现">代码实现</h2>
<p>以下实现是非稳定的，因为最后是根据计数结果直接覆盖写入原数组，而不是通过一个临时数组来保证相同元素的原始相对顺序。也就是说同等大小的整数的先后顺序是任意的。如果想要稳定的，可以另创建一个新数组用于存储结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sort_array_py</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        nums: 待排序的整数列表。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        排序后的原列表的引用。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> nums<br><br>    <span class="hljs-comment"># 1. 找出数组中的最大值和最小值</span><br>    min_val, max_val = <span class="hljs-built_in">min</span>(nums), <span class="hljs-built_in">max</span>(nums)<br><br>    <span class="hljs-comment"># 2. 创建计数数组，其长度为 (max - min + 1)</span><br>    <span class="hljs-comment">#    counts 数组的索引 0 对应原始数字 min_val</span><br>    counts = [<span class="hljs-number">0</span>] * (max_val - min_val + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 3. 统计每个数字出现的次数，注意偏移量 min_val</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        counts[num - min_val] += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 4. 根据计数数组的结果，重构原数组</span><br>    write_idx = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 遍历计数数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(counts)):<br>        <span class="hljs-comment"># 当计数值大于0时，说明这个数存在</span><br>        <span class="hljs-keyword">while</span> counts[i] &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 将索引 i 还原为原始数字 (i + min_val) 并写入</span><br>            nums[write_idx] = i + min_val<br>            <span class="hljs-comment"># 更新写入位置</span><br>            write_idx += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 将该数字的计数值减一</span><br>            counts[i] -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<p>从功能上讲，return nums 不是必需的。因为列表是可变对象，当它被作为参数传递给函数时，传递的是它的引用。函数内部对列表内容的任何修改，都会直接反映在函数外部的原始列表上。return nums 主要是出于设计惯例和使用灵活性的考虑。例如返回对象本身可以让你把函数调用当作一个表达式来使用，从而可以进行链式调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 用于 std::min_element 和 std::max_element</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort_array_cpp</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 找出数组中的最大值和最小值</span><br>    <span class="hljs-type">int</span> min_val = *std::<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要*解引用因为std::min_element返回的不是值本身而是指向其的迭代器</span><br>    <span class="hljs-type">int</span> max_val = *std::<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 2. 创建计数数组，其长度为 (max - min + 1)</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(max_val - min_val + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 3. 统计每个数字出现的次数，注意偏移量 min_val</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        counts[num - min_val]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 根据计数数组的结果，重构原数组</span><br>    <span class="hljs-type">int</span> write_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历计数数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; counts.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">// 当计数值大于0时，说明这个数存在</span><br>        <span class="hljs-keyword">while</span> (counts[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将索引 i 还原为原始数字 (i + min_val) 并写入</span><br>            nums[write_idx] = i + min_val;<br>            <span class="hljs-comment">// 更新写入位置</span><br>            write_idx++;<br>            <span class="hljs-comment">// 将该数字的计数值减一</span><br>            counts[i]--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="复杂度">复杂度</h2>
<p>时间复杂度 O(n+k)，空间复杂度为 O(k) (因为需要一个长度为 O(k)的辅助数组)。由此可见 k 较小时该算法效率很高。</p>
<h1 id="冒泡排序比较排序">冒泡排序（比较排序）</h1>
<p>—<strong>了解</strong>—</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bubble_sort</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> nums<br><br>    <span class="hljs-comment"># 外层循环控制排序的轮数，每一轮都会将当前未排序部分的最大值“冒泡”到其最终位置。</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br><br>        <span class="hljs-comment"># 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较，</span><br>        <span class="hljs-comment"># 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组。</span><br>        is_sorted = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 内层循环负责比较相邻元素并进行交换。</span><br>        <span class="hljs-comment"># 每一轮的比较范围是 [0, i)，因为 i 以后的元素已经排好序了。</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j + <span class="hljs-number">1</span>]:<br>                nums[j], nums[j + <span class="hljs-number">1</span>] = nums[j + <span class="hljs-number">1</span>], nums[j]<br>                <span class="hljs-comment"># 只要发生了一次交换，就将标志位设置为 False</span><br>                is_sorted = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 如果经过一整轮内层循环都没有发生交换，说明数组已经完全有序</span><br>        <span class="hljs-keyword">if</span> is_sorted:<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p>时间复杂度：O(N^2)，这里 N 是数组的长度；<br>
空间复杂度：O(1)，使用到常数个临时变量。</p>
<h2 id="优点">优点</h2>
<p>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</p>
<h1 id="选择排序比较排序">选择排序（比较排序）</h1>
<p>—<strong>了解</strong>—</p>
<h2 id="基本思想">基本思想</h2>
<p>思路：每一轮选取未排定的部分中最小的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p>
<h2 id="代码">代码</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">nums</span>):<br>    list_len = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment"># 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(list_len - <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 选择区间 [i, len - 1] 里最小的元素的索引，然后交换到下标 i</span><br>        min_index = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, list_len):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[min_index]:<br>                min_index = j<br><br>        <span class="hljs-comment"># 对应 Java 中的 swap(nums, i, minIndex);</span><br>        <span class="hljs-comment"># Python 可以使用更简洁的元组解包语法进行交换。</span><br>        <span class="hljs-keyword">if</span> i != min_index:<br>            nums[i], nums[min_index] = nums[min_index], nums[i]<br><br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p>时间复杂度：O(N^2)，这里 N 是数组的长度；<br>
空间复杂度：O(1)，使用到常数个临时变量。</p>
<h2 id="优点">优点</h2>
<p>交换次数最少。选择排序看起来好像最没有用，但是如果在<strong>交换成本较高</strong>的排序任务中，就可以使用选择排序。</p>
<h1 id="references">References</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419">https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/solutions/3679173/tu-jie-he-lan-guo-qi-san-zhi-zhen-wen-ti-k690">https://leetcode.cn/problems/sort-colors/solutions/3679173/tu-jie-he-lan-guo-qi-san-zhi-zhen-wen-ti-k690</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7WHec2/solutions/1401990/lian-biao-pai-xu-by-leetcode-solution-0rjx">https://leetcode.cn/problems/7WHec2/solutions/1401990/lian-biao-pai-xu-by-leetcode-solution-0rjx</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solutions/1312391/4chong-jie-fa-yi-wang-da-jin-you-xu-shu-0nia5">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solutions/1312391/4chong-jie-fa-yi-wang-da-jin-you-xu-shu-0nia5</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Algorithms/" class="category-chain-item">Algorithms</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithms/" class="print-no-link">#Algorithms</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Summary of common sorting algorithms and solutions</div>
      <div>http://example.com/2025/06/28/sorting-algo/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 28, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/21/cpp-templates/" title="C++ Template - Why C++ templates are usually put in header files?">
                        <span class="hidden-mobile">C++ Template - Why C++ templates are usually put in header files?</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
