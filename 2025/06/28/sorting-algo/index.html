

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="插入排序 堆排序 归并排序 基本思想 其基本思想是分治法。要排序长度为 n 的数组，则先排序排序两个长度为 n&#x2F;2 的子数组，然后将两个排序后的子数组合并。 快速排序 基本思想 其基本思想也是分治法。首先从数组中随机取一个数作为中间值（pivot），然后对数组进行分区（partition），把数组中所有小于中间值的数放到中间值的左边，所有大于中间值的数放在其右边。然后对中间值左右的两个子数组用上述">
<meta property="og:type" content="article">
<meta property="og:title" content="Summary of common sorting algorithms and solutions">
<meta property="og:url" content="http://example.com/2025/06/28/sorting-algo/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="插入排序 堆排序 归并排序 基本思想 其基本思想是分治法。要排序长度为 n 的数组，则先排序排序两个长度为 n&#x2F;2 的子数组，然后将两个排序后的子数组合并。 快速排序 基本思想 其基本思想也是分治法。首先从数组中随机取一个数作为中间值（pivot），然后对数组进行分区（partition），把数组中所有小于中间值的数放到中间值的左边，所有大于中间值的数放在其右边。然后对中间值左右的两个子数组用上述">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-28T13:17:40.261Z">
<meta property="article:modified_time" content="2025-06-29T10:42:20.020Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Summary of common sorting algorithms and solutions - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Summary of common sorting algorithms and solutions"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-28 21:17" pubdate>
          June 28, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.7k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          40 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Summary of common sorting algorithms and solutions</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="插入排序">插入排序</h1>
<h1 id="堆排序">堆排序</h1>
<h1 id="归并排序">归并排序</h1>
<h2 id="基本思想">基本思想</h2>
<p>其基本思想是分治法。要排序长度为 n 的数组，则先排序排序两个长度为 n/2 的子数组，然后将两个排序后的子数组合并。</p>
<h1 id="快速排序">快速排序</h1>
<h2 id="基本思想">基本思想</h2>
<p>其基本思想也是分治法。首先从数组中随机取一个数作为中间值（pivot），然后对数组进行分区（partition），把数组中所有小于中间值的数放到中间值的左边，所有大于中间值的数放在其右边。然后对中间值左右的两个子数组用上述相同的方法分别排序，直到子数组中只有一个元素。这个过程可以通过递归实现。当表现良好时，该算法可以比归并排序等其他算法快 2~3 倍。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="单路快排">单路快排</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用快速排序对列表进行原地排序。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        arr: 待排序的整数列表。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr:<br>        <span class="hljs-keyword">return</span><br>    _quick_sort_recursive(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_quick_sort_recursive</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归地对 arr[low..high] 进行快速排序。&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> low &lt; high:<br>        <span class="hljs-comment"># partition an d get the pivot&#x27;s final index</span><br>        pivot_index = _partition(arr, low, high)<br><br>        <span class="hljs-comment"># 递归地对基准左边的子数组进行排序</span><br>        _quick_sort_recursive(arr, low, pivot_index - <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 递归地对基准右边的子数组进行排序</span><br>        _quick_sort_recursive(arr, pivot_index + <span class="hljs-number">1</span>, high)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_partition</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Lomuto 分区方案。选择 arr[high] 作为基准。</span><br><span class="hljs-string">    将小于基准的元素移到左边，大于的移到右边。</span><br><span class="hljs-string">    返回基准最后所在的索引。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    pivot = arr[high]  <span class="hljs-comment"># 选择最后一个元素作为基准</span><br>    <span class="hljs-comment"># 或随机选择一个基准的索引</span><br>    <span class="hljs-comment"># pivot_random_index = random.randint(low, high)</span><br>    i = low - <span class="hljs-number">1</span>  <span class="hljs-comment"># i 是“小于基准”区域的右边界</span><br><br>    <span class="hljs-comment"># 遍历 low 到 high-1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low, high):<br>        <span class="hljs-keyword">if</span> arr[j] &lt; pivot:<br>            i += <span class="hljs-number">1</span>  <span class="hljs-comment"># 扩展“小于基准”的区域</span><br>            arr[i], arr[j] = arr[j], arr[i]  <span class="hljs-comment"># 将当前元素换入该区域</span><br><br>    <span class="hljs-comment"># 遍历结束后，i+1 的位置就是基准应该在的位置</span><br>    <span class="hljs-comment"># 将基准换到正确的位置</span><br>    arr[i + <span class="hljs-number">1</span>], arr[high] = arr[high], arr[i + <span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::swap</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Lomuto 分区函数。选择 arr[high] 作为基准。</span><br><span class="hljs-comment"> * @return 基准最后所在的索引。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[high]; <span class="hljs-comment">// 选择最后一个元素作为基准</span><br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;       <span class="hljs-comment">// “小于基准”区域的右边界</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; pivot) &#123;<br>            i++;<br>            std::<span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 递归地对 arr[low..high] 进行快速排序。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortRecursive</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(arr, low, high);<br><br>        <span class="hljs-built_in">quickSortRecursive</span>(arr, low, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSortRecursive</span>(arr, pivot_index + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 使用快速排序对向量进行原地排序的主函数。</span><br><span class="hljs-comment"> * @param arr 待排序的整数向量。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">quickSortRecursive</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="双路三路快排">双路/三路快排</h3>
<ul>
<li>
<p>如上演示的是<strong>单路分区</strong>的快排（Lomuto 分区），即使用一个中间值将数组分为两部分：<code>[start, i]</code>为小于 pivot 的元素，<code>(i, j]</code>为大于等于 pivot 的元素。遍历数组（<code>j</code>从<code>start</code>到<code>end-1</code>），将小于 pivot 的元素交换到前面。这样写思路简单但是效率较低，如在 leetcode 912. 中会因为超出时间限制而无法通过某些用例。当数组中存在大量与基准值相等的重复元素时，这些重复元素会被全部划分到一侧（通常是左侧）。这会导致分区极其不平衡，例如，若对一个所有元素都相同的数组进行排序，每次分区都会形成一个包含 n-1 个元素的子数组和一个空数组。在这种情况下，快速排序的时间复杂度会从平均的 O(n log n) 退化到最坏的 O(n²)，并且可能导致递归深度过大，引发栈溢出。所以通常使用双路、三路的快排（包括在 leetcode 215 中）。</p>
</li>
<li>
<p>双路分区 (Hoare Partition)</p>
<ol>
<li>选择基准值 (pivot)：通常选择待排序区间的第一个元素。</li>
<li>初始化指针：设置两个指针，i 从左边界的下一个位置开始（l+1），j 从右边界开始（r）。</li>
<li>双向扫描：</li>
</ol>
<ul>
<li>指针 i 从左向右移动，直到找到一个大于等于 pivot 的元素 (arr[i] &gt;= pivot)。</li>
<li>指针 j 从右向左移动，直到找到一个小于等于 pivot 的元素 (arr[j] &lt;= pivot)。</li>
</ul>
<ol start="4">
<li>交换与继续：</li>
</ol>
<ul>
<li>如果此时 i &lt; j，则交换 arr[i] 和 arr[j] 的值。</li>
</ul>
<ol start="5">
<li>重复步骤 3，直到 i 越过 j (i &gt;= j)。</li>
<li>放置基准值：扫描结束后，将基准值 pivot（arr[l]）与指针 j 指向的元素 arr[j] 进行交换。此时，arr[j] 左边的元素都小于或等于它，右边的都大于或等于它。</li>
</ol>
</li>
<li>
<p>三路分区 (Three-Way Partitioning / Dutch National Flag Problem)</p>
<ol>
<li>选择基准值 (pivot)：同样选择待排序区间的第一个元素。</li>
<li>初始化指针：<br>
lt (less than)：指向小于部分的下一个位置，初始为 l。<br>
gt (greater than)：指向大于部分的前一个位置，初始为 r+1。<br>
i：当前扫描的元素指针，初始为 l+1。</li>
<li>扫描与分区：<br>
从 i 开始遍历数组，直到 i 与 gt 相遇 (i &lt; gt)。</li>
</ol>
<ul>
<li>情况一：arr[i] &lt; pivot
<ul>
<li>交换 arr[lt+1] 和 arr[i]。</li>
<li>lt 和 i 指针都向右移动一位。</li>
</ul>
</li>
<li>情况二：arr[i] &gt; pivot
<ul>
<li>交换 arr[i] 和 arr[gt-1]。</li>
<li>gt 指针向左移动一位。</li>
<li>i 指针不动，因为交换过来的新 arr[i] 还需要进行下一轮的比较。</li>
</ul>
</li>
<li>情况三：arr[i] == pivot
<ul>
<li>i 指针直接向右移动一位。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>放置基准值：遍历结束后，将 arr[l] (pivot) 与 arr[lt] 交换。最终，数组被分为三部分：<br>
[l, lt-1]：所有元素小于 pivot。<br>
[lt, gt-1]：所有元素等于 pivot。<br>
[gt, r]：所有元素大于 pivot。</li>
</ol>
<ul>
<li>关键优势：三路分区的最大优势在于，它将所有与 pivot 相等的元素 一次性地放置到了最终位置。在后续的递归排序中，这个“等于 pivot”的区间将不再需要处理，只需要递归地对“小于”和“大于”的两个子区间进行排序。当数组中重复元素非常多时，这种优化带来的性能提升是极其显著的，甚至可以将处理这些元素的复杂度降到线性时间。</li>
</ul>
</li>
</ul>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>时间复杂度:<br>
平均情况: O(nlogn)。在理想情况下，每次分区都能将数组分成大致相等的两半，递归树的深度为 O(logn)，每层的工作量为 O(n)。最坏情况: O(n^2)。当每次选择的基准都是当前数组的最小值或最大值时（例如，对一个已经排好序的数组使用最后一个元素做基准），分区会极度不平衡，导致递归树退化成一个链表，深度为 O(n)。</li>
<li>空间复杂度:<br>
O(logn) (平均) 到 O(n) (最坏)。这个空间主要用于递归调用栈。</li>
<li>稳定性:<br>
快速排序是一种不稳定的排序算法。在分区过程中，相等元素的原始相对顺序可能会被改变。</li>
<li>优化:<br>
为了避免最坏情况，可以优化基准的选择，例如采用“三数取中法”（比较开头、中间、结尾三个元素，取中间值作为基准）或随机选择基准。</li>
</ul>
<h2 id="优化后的快排"><strong>优化后的快排</strong></h2>
<p>上述单路分区效率较低，实际直接写下方优化过的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[start]; <span class="hljs-comment">// 最左侧设为pivot</span><br>        <span class="hljs-type">int</span> i = start<span class="hljs-number">-1</span>, j = end<span class="hljs-number">+1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 这里必须是 nums[i] &lt; pivot 和 nums[i] &gt; pivot，不能是 &gt;=, &lt;= 否则 有可能i永远小于j（记得一开始把最左侧设为pivot，则i=0时nums[i]==pivot，此后i不会再向右挪动）无法跳出循环。</span><br>            <span class="hljs-keyword">do</span> &#123;i++;&#125; <span class="hljs-keyword">while</span> (nums[i] &lt; pivot);<br>            <span class="hljs-keyword">do</span> &#123;j--;&#125; <span class="hljs-keyword">while</span> (nums[j] &gt; pivot);<br>            <span class="hljs-keyword">if</span> (i&gt;=j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, start, end);<br>            std::cout &lt;&lt; pivot_index &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-comment">// 为什么不是</span><br>            <span class="hljs-comment">// recursiveHelper(nums, start, pivot_index-1);</span><br>            <span class="hljs-comment">// recursiveHelper(nums, pivot_index+1, end);</span><br>            <span class="hljs-comment">// 因为上述是单路分区时的递归方式，单路分区时可以确定pivot_index就是pivot的位置，因此可以安全的排除此位置。</span><br>            <span class="hljs-comment">// 但双路分区返回的index，只能保证index左侧的数字都&lt;=pivot，index右侧的数字都&gt;=pivot，但index这个位置上本身未必是pivot。pivot 本身可能在左侧或右侧（都满足大于等于），所以不能排除。可以发现下方kth largest的题解也是没排除的。</span><br>            <span class="hljs-built_in">recursiveHelper</span>(nums, start, pivot_index);<br>            <span class="hljs-built_in">recursiveHelper</span>(nums, pivot_index<span class="hljs-number">+1</span>, end);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">recursiveHelper</span>(nums, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="数组中第-k-大的数字">数组中第 k 大的数字</h2>
<p><strong>快排中的 partition 函数还常被用于选择数组中第 k 大的数字</strong>。</p>
<p>从一个乱序数组中找出第 k 大的数字。</p>
<ul>
<li>
<p>解法 1：最小堆。每次从数据里路中读取一个数字，将其与最小堆堆顶的数字比较。当新读取的数字大于最小堆堆顶的数字时，删除堆顶的数字并将新读取的数字添加到堆中。只要保证堆的大小为 k，堆顶的数字永远是第 k 大的数字。这样做的时间复杂度是 O(nlogk)，空间复杂度时 O(k)。这种方法的场景是数据位于一个数据流中，不能一下把数据全部读入内存。</p>
</li>
<li>
<p>解法 2：如果所有数据保存在一个内存的数组中，可以用快排中的 partition 函数更快求解。</p>
<ul>
<li>在长度为 n 的排序数组中，第 k 大的数字的下标是 n-k。用 partition 函数对数组进行分区，如果 partition 函数返回的下标正好是 n-k，注意分区后 n-k 位置左边的数字都比其小，右边的数字都比其大，则即便整个数组不是排序的，第 n-k 个数字也一定是第 k 大的。如果返回的下标大于 n-k，则第 k 大的数字一定在当前中间值的左侧，于是再用 partition 函数对左侧的子数组分区。如果返回的下标小于 n-k，则第 k 大的数字一定在当前中间值的右侧，于是再用 partition 函数对右侧的子数组分区。重复这个过程直到 partition 函数的返回值正好是 n-k。</li>
<li>代码实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_kth_largest</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用 Quickselect 算法（基于 partition）寻找数组中第 k 大的元素。</span><br><span class="hljs-string">    LeetCode #215. Kth Largest Element in an Array</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        nums: 乱序整数列表。</span><br><span class="hljs-string">        k: 要寻找的第 k 大。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        第 k 大的元素的值。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> k &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> k &gt; <span class="hljs-built_in">len</span>(nums):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Invalid input&quot;</span>)<br><br>    <span class="hljs-comment">#----------------------------------------------------------#</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;Lomuto 分区方案，返回基准的最终索引。&quot;&quot;&quot;</span><br>        pivot = nums[high]<br>        i = low - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low, high):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; pivot:<br>                i += <span class="hljs-number">1</span><br>                nums[i], nums[j] = nums[j], nums[i]<br>        nums[i + <span class="hljs-number">1</span>], nums[high] = nums[high], nums[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>    <span class="hljs-comment">#----------------------------------------------------------#</span><br><br>    low, high = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 我们要找的目标索引 (0-indexed from smallest)</span><br>    target_index = <span class="hljs-built_in">len</span>(nums) - k<br><br>    <span class="hljs-keyword">while</span> low &lt;= high:<br>        <span class="hljs-comment"># 随机化基准以避免最坏情况</span><br>        pivot_random_index = random.randint(low, high)<br>        nums[pivot_random_index], nums[high] = nums[high], nums[pivot_random_index]<br><br>        pivot_index = partition(low, high)<br><br>        <span class="hljs-keyword">if</span> pivot_index == target_index:<br>            <span class="hljs-keyword">return</span> nums[pivot_index]<br>        <span class="hljs-keyword">elif</span> pivot_index &lt; target_index:<br>            <span class="hljs-comment"># 目标在右侧</span><br>            low = pivot_index + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>: <span class="hljs-comment"># pivot_index &gt; target_index</span><br>            <span class="hljs-comment"># 目标在左侧</span><br>            high = pivot_index - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># This line should not be reached in a valid run</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span>    <span class="hljs-comment">// For modern C++ random number generation</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>   <span class="hljs-comment">// For std::swap</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// For std::runtime_error</span></span><br><br><span class="hljs-comment">// Partition function (can be defined inside or outside)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[high];<br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] &lt; pivot) &#123;<br>            i++;<br>            std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(nums[i + <span class="hljs-number">1</span>], nums[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>() || k &lt; <span class="hljs-number">1</span> || k &gt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid input&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> target_index = nums.<span class="hljs-built_in">size</span>() - k;<br><br>    <span class="hljs-comment">// For random pivot selection</span><br>    std::random_device rd;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;<br><br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-comment">// Randomize pivot</span><br>        std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">distrib</span>(low, high);<br>        <span class="hljs-type">int</span> pivot_random_index = <span class="hljs-built_in">distrib</span>(gen);<br>        std::<span class="hljs-built_in">swap</span>(nums[pivot_random_index], nums[high]);<br><br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, low, high);<br><br>        <span class="hljs-keyword">if</span> (pivot_index == target_index) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivot_index];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_index &lt; target_index) &#123;<br>            low = pivot_index + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            high = pivot_index - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Should not be reached</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意如下部分的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (nums[j] &lt; pivot) &#123;<br>    i++;<br>    std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处使用<code>nums[j] &lt; pivot</code>而非<code>nums[j] &lt;= pivot</code>，从而能在输入数组有非常多重复值的时候仍能正常通过不超时。<br>
如果用<code>nums[j] &lt;= pivot</code>，想象输入数组为：[3, 3, 3, 3, 3, 3, 3, 3]，需要找到中位数。任意取一个 pivot 大概率是 3（实际上本例中只可能是 3）。</p>
</li>
<li>
<p>分区循环开始。 i 位于 low - 1。 j 从 low 迭代到 high - 1。</p>
</li>
<li>
<p>对于每个元素 <code>nums[j]</code>，条件 <code>nums[j] &lt;= pivot</code> (即 3 &lt;= 3) 将为真。</p>
</li>
<li>
<p>这意味着 i 将为每个元素递增，并且每个元素将与自身交换。 分区最终将使 i 位于 high - 1。</p>
</li>
<li>
<p>最后的交换 std::swap(nums[i + 1], nums[high]); 将枢轴（位于 high）与自身（位于 i + 1，现在是 high）交换。</p>
</li>
<li>
<p>分区函数返回 high。</p>
</li>
<li>
<p>因为假设正在寻找中位数，所以 target_index 在中间的位置。但此时的 pivot_index 将是 high。</p>
</li>
<li>
<p>由于 pivot_index &gt; target_index，下一个递归调用（或循环迭代）将在范围 (low, high - 1) 上进行。</p>
</li>
<li>
<p>问题是，你只将搜索空间减少了一个元素（high=pivot-1）。 如果是一个包含许多重复项的数组，这可能会持续导致最坏情况下的 O(n^2) 性能，从而超出时间限制。随机枢轴选择在这种特定情况下没有帮助，因为无论你选择哪个’3’，结果都是一样的。</p>
</li>
</ul>
<h3 id="复杂度">复杂度</h3>
<ul>
<li>时间复杂度:
<ul>
<li>平均情况: O(n)。这虽然每次分区是 O(n)，但由于我们每次都丢弃了一半（平均）的元素，总的计算量是 n+n/2+n/4+…，这是一个收敛的等比数列，其和为 2n。因此平均复杂度是线性的 O(n)。</li>
<li>最坏情况: O(n^2)。如果每次都选到最差的基准（和快速排序一样），算法会退化。但通过随机化，这种情况在实际中几乎不可能发生。</li>
</ul>
</li>
<li>空间复杂度: O(1)。上面的实现是迭代式的（使用了 while 循环），没有递归调用，因此除了存储几个变量外，不需要额外的栈空间。</li>
</ul>
<h3 id="优化后的-kth-largest"><strong>优化后的 kth largest</strong></h3>
<p>上述方法实际中效率较低，见下方优化代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickselect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<br>            <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-type">int</span> partition = nums[l], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; partition);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; partition);<br>            <span class="hljs-keyword">if</span> (i &lt; j)<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt;= j)<span class="hljs-keyword">return</span> <span class="hljs-built_in">quickselect</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickselect</span>(nums, j + <span class="hljs-number">1</span>, r, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickselect</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n - k);<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/kth-largest-element-in-an-array/solutions/307351/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcod-2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>
<p>时间复杂度：O(n).<br>
空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)。</p>
<h1 id="计数排序">计数排序</h1>
<h2 id="基本思想">基本思想</h2>
<p>计数排序是<strong>线性时间</strong>的<strong>整数</strong>排序算法，如果数组长度为 n，整数范围为 k，对于<strong>k 远小于 n</strong>的场景，计数排序的时间复杂度优于其他基于比较的算法（如归并、快排）。其基本思想是：先扫描一遍数组记录数组中的每个整数出现的次数（使用辅助数组），然后按照从小到大的顺序把，每种整数出现了几次就填入几个该整数到原数组中。</p>
<p>例如，输入整数数组<code>[2,3,4,2,3,2,1]</code>，扫描一次之后得到 1 出现 1 次，2 出现 3 次，3 出现 2 次，4 出现 1 次。于是先后在数组中填入 1 个 1，3 个 2，2 个 3，1 个 4，就得到了排序后的数组<code>[1,2,2,2,3,3,4]</code>。</p>
<h2 id="代码实现">代码实现</h2>
<p>以下实现是非稳定的，因为最后是根据计数结果直接覆盖写入原数组，而不是通过一个临时数组来保证相同元素的原始相对顺序。也就是说同等大小的整数的先后顺序是任意的。如果想要稳定的，可以另创建一个新数组用于存储结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sort_array_py</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        nums: 待排序的整数列表。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        排序后的原列表的引用。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> nums<br><br>    <span class="hljs-comment"># 1. 找出数组中的最大值和最小值</span><br>    min_val, max_val = <span class="hljs-built_in">min</span>(nums), <span class="hljs-built_in">max</span>(nums)<br><br>    <span class="hljs-comment"># 2. 创建计数数组，其长度为 (max - min + 1)</span><br>    <span class="hljs-comment">#    counts 数组的索引 0 对应原始数字 min_val</span><br>    counts = [<span class="hljs-number">0</span>] * (max_val - min_val + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 3. 统计每个数字出现的次数，注意偏移量 min_val</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        counts[num - min_val] += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 4. 根据计数数组的结果，重构原数组</span><br>    write_idx = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 遍历计数数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(counts)):<br>        <span class="hljs-comment"># 当计数值大于0时，说明这个数存在</span><br>        <span class="hljs-keyword">while</span> counts[i] &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 将索引 i 还原为原始数字 (i + min_val) 并写入</span><br>            nums[write_idx] = i + min_val<br>            <span class="hljs-comment"># 更新写入位置</span><br>            write_idx += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 将该数字的计数值减一</span><br>            counts[i] -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<p>从功能上讲，return nums 不是必需的。因为列表是可变对象，当它被作为参数传递给函数时，传递的是它的引用。函数内部对列表内容的任何修改，都会直接反映在函数外部的原始列表上。return nums 主要是出于设计惯例和使用灵活性的考虑。例如返回对象本身可以让你把函数调用当作一个表达式来使用，从而可以进行链式调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 用于 std::min_element 和 std::max_element</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort_array_cpp</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 找出数组中的最大值和最小值</span><br>    <span class="hljs-type">int</span> min_val = *std::<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要*解引用因为std::min_element返回的不是值本身而是指向其的迭代器</span><br>    <span class="hljs-type">int</span> max_val = *std::<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 2. 创建计数数组，其长度为 (max - min + 1)</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(max_val - min_val + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 3. 统计每个数字出现的次数，注意偏移量 min_val</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        counts[num - min_val]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 根据计数数组的结果，重构原数组</span><br>    <span class="hljs-type">int</span> write_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历计数数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; counts.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">// 当计数值大于0时，说明这个数存在</span><br>        <span class="hljs-keyword">while</span> (counts[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将索引 i 还原为原始数字 (i + min_val) 并写入</span><br>            nums[write_idx] = i + min_val;<br>            <span class="hljs-comment">// 更新写入位置</span><br>            write_idx++;<br>            <span class="hljs-comment">// 将该数字的计数值减一</span><br>            counts[i]--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="复杂度">复杂度</h2>
<p>时间复杂度 O(n+k)，空间复杂度为 O(k) (因为需要一个长度为 O(k)的辅助数组)。由此可见 k 较小时该算法效率很高。</p>
<h1 id="冒泡排序">冒泡排序</h1>
<h1 id="references">References</h1>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Algorithms/" class="category-chain-item">Algorithms</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithms/" class="print-no-link">#Algorithms</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Summary of common sorting algorithms and solutions</div>
      <div>http://example.com/2025/06/28/sorting-algo/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 28, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/21/cpp-templates/" title="C++ Template - Why C++ templates are usually put in header files?">
                        <span class="hidden-mobile">C++ Template - Why C++ templates are usually put in header files?</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
