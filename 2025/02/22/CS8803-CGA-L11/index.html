

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="Rasterization pipeline Core Concepts: Essence of NeRF and GS  NeRF is neural radiance representation + differentiable ray tracing 3D GS is point-based representation + differentiable rasterization  Ra">
<meta property="og:type" content="article">
<meta property="og:title" content="CS 8803 CGA - Point-based Rendering">
<meta property="og:url" content="http://example.com/2025/02/22/CS8803-CGA-L11/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="Rasterization pipeline Core Concepts: Essence of NeRF and GS  NeRF is neural radiance representation + differentiable ray tracing 3D GS is point-based representation + differentiable rasterization  Ra">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/rasterization.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/raytracing.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/raster_raycast.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/rendering_pipeline.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/obj2screen.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/warping.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/warping_proc.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/visibility_test.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/alpha_blending.png">
<meta property="og:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/filtering.png">
<meta property="article:published_time" content="2025-02-23T03:25:03.979Z">
<meta property="article:modified_time" content="2025-02-25T20:59:14.398Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="graphics">
<meta property="article:tag" content="Gaussian Splatting">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/02/22/CS8803-CGA-L11/rasterization.png">
  
  
  
  <title>CS 8803 CGA - Point-based Rendering - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CS 8803 CGA - Point-based Rendering"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-22 21:25" pubdate>
          February 22, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          456 words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          4 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CS 8803 CGA - Point-based Rendering</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="rasterization-pipeline">Rasterization pipeline</h2>
<h3 id="core-concepts-essence-of-nerf-and-gs">Core Concepts: Essence of NeRF and GS</h3>
<ul>
<li>NeRF is neural radiance representation + differentiable ray tracing</li>
<li>3D GS is point-based representation + differentiable rasterization</li>
</ul>
<h3 id="rasterization-vs-ray-tracing">Rasterization v.s. Ray Tracing</h3>
<ul>
<li>Rasterization: object point to image plane
<ul>
<li>start with a 3D object point</li>
<li>apply transforms</li>
<li>determine the 2D image plane point it projects to</li>
</ul>
</li>
</ul>
<p><img src="rasterization.png" alt="rasterization"></p>
<ul>
<li>Ray tracing: image plane to object point
<ul>
<li>start with a 2D image point</li>
<li>generate a ray</li>
<li>determine the visible 3D object point</li>
</ul>
</li>
</ul>
<p><img src="raytracing.png" alt="ray tracing"></p>
<p><em>Rasterization and ray tracing are inverse processes to each other.</em></p>
<h3 id="rasterization-vs-ray-casting">Rasterization vs. Ray casting</h3>
<p><img src="raster_raycast.png" alt="Rasterization vs. Ray casting"></p>
<ul>
<li>What needs to be stored in memory in each case?
<ul>
<li>The rasterizer only needs one primitive at a time, plus the entire image and associated depth information for all pixels.</li>
<li>In this basic form, ray tracing needs the entire scene description in memory at once.</li>
</ul>
</li>
</ul>
<h3 id="review-of-rendering-pipeline">Review of rendering pipeline</h3>
<p><img src="rendering_pipeline.png" alt="rendering pipeline"></p>
<h4 id="stage-i-vertex-processing">Stage I: Vertex Processing</h4>
<ul>
<li>The vertex processing stage processes vertex data through a vertex shader.</li>
<li>Each vertex’s properties, like position, color, and texture coordinates, are calculated and transformed to prepare for primitive processing.</li>
<li>We can program this stage in Vertex Shaders.</li>
</ul>
<h4 id="stage-ii-primitive-processing">Stage II: Primitive Processing</h4>
<ul>
<li>Once vertices are processed, they are assembled into geometric primitives such as <strong>points</strong>, lines, or triangles.</li>
<li>This stage may include tessellation (镶嵌), where primitives are subdivided into finer details, and geometry shading.</li>
<li>This stage can be programmed using Geometry Shaders.</li>
</ul>
<h4 id="stage-iii-rasterization">Stage III: Rasterization</h4>
<ul>
<li>Rasterization converts primitives into a 2D image or framebuffer.</li>
<li>It determines the pixels that form the primitives, performing interpolations for pixel positions. This stage sets the scene for fragment processing.</li>
<li>This stage is not programmable.</li>
</ul>
<h4 id="stage-iv-fragment-processing">Stage IV: Fragment Processing</h4>
<ul>
<li>Fragments can be thought of as pixels (but they are actually not!), are processed to determine<br>
their final color and properties.</li>
<li>Fragment shaders compute lighting, apply textures, and carry out operations for visual effects.</li>
<li>We can program this stage in Fragment Shaders.</li>
</ul>
<p>In the rendering pipeline, fragments and pixels are closely related but distinct concepts. A fragment is an intermediate stage in the pipeline, while a pixel represents the final output on the screen.</p>
<ul>
<li>
<p>Fragment</p>
<ul>
<li>A fragment is a <em>potential</em> pixel generated during rasterization.</li>
<li>It contains <em>interpolated</em> attributes from vertices, such as:
<ul>
<li>Depth (Z-value)</li>
<li>Color</li>
<li>Texture coordinates</li>
<li>Normals, lighting values, etc.</li>
</ul>
</li>
<li>Each fragment undergoes per-fragment operations (like shading, depth testing, blending).</li>
<li>Not all fragments become pixels due to <em>depth testing, alpha testing, and other rejection criteria</em>.</li>
</ul>
</li>
<li>
<p>Pixel</p>
<ul>
<li>A pixel is the final colored output on the screen.</li>
<li>It contains final colors only.</li>
<li>After fragment processing, only one final color value per pixel is stored in the frame buffer.</li>
<li>Operations affecting pixels:
<ul>
<li>Blending (combining multiple fragments)</li>
<li>Post-processing effects (antialiasing, tone mapping)</li>
</ul>
</li>
<li>If two fragments map to the same pixel, only the one closest to the camera (passing depth test) is displayed.</li>
</ul>
</li>
</ul>
<h4 id="stage-v-pixel-processing">Stage V: Pixel Processing</h4>
<ul>
<li>The pixel processing stage involves operations like blending and testing pixels for depth and stencil (模板) comparison.</li>
<li>The final pixel colors are output to the screen, resulting in the rendered image.</li>
<li>This stage is not fully programmable (mainly hardware control).</li>
</ul>
<h2 id="points-and-surfels">Points and surfels</h2>
<h3 id="points-as-rendering-primitives">Points as Rendering Primitives</h3>
<ul>
<li>We want to use point clouds instead of triangle meshes and textures as a rendering primitive</li>
<li>Points are considered as a collection of nonuniform samplers of a surface in 3D space</li>
<li>We want to carry surface information such as colors, normal, and textures on each point</li>
<li>The original idea has been proposed by Levoy and Whitted in 1985 (<em>The Use of Points as a Display Primitive</em> Marc Levoy and Turner WhittedTechnical Report 85-022, UNC Chapel Hill, January, 1985.)</li>
</ul>
<h3 id="why-points">Why Points?</h3>
<h4 id="representation-simplicity">Representation Simplicity</h4>
<ul>
<li>Performance of 3D hardware has exploded</li>
<li>Projected triangles are very small, causing higher setup overhead</li>
<li><strong>Generating triangle meshes is time-consuming and difficult</strong></li>
<li>Seeking a simpler, more efficient rendering primitive than triangles</li>
</ul>
<h4 id="model-acquisition">Model Acquisition</h4>
<ul>
<li>3D scanning of physical objects is ubiquitous</li>
<li>Modern 3D scanning and LiDAR devices produce huge point clouds</li>
<li>Direct rendering of acquired point clouds becomes possible with the improvement of GPU power</li>
<li>Efficient rendering of synthetic models and animated scenes</li>
</ul>
<h4 id="model-editing">Model Editing</h4>
<ul>
<li>Processing and editing of point-sampled geometry become necessary after obtaining these geometries from real-world scanning</li>
<li>Graphics community needs a point-based content creation pipeline</li>
</ul>
<h3 id="points-as-primitives-summary">Points as primitives - Summary</h3>
<ul>
<li>Point clouds instead of triangle meshes</li>
<li>No explicit connectivity or texture maps</li>
<li>Each point carries 3D geometry and surface reflectance properties</li>
<li>We need a large number of points to render realistic appearance</li>
</ul>
<h3 id="recap-render-a-single-particle-in-fragment-shader">Recap: Render a Single Particle in Fragment Shader</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- Input: <span class="hljs-comment">/*fragment position*/</span> frag_pos, <span class="hljs-comment">/*particle position*/</span> particle_pos, <span class="hljs-comment">/*particle’s default brightness*/</span> brightness, <span class="hljs-comment">/*particle’s default color*/</span> color<br>- Output: <span class="hljs-comment">/*fragment color*/</span> frag_color<br>- Algorithm:<br><span class="hljs-comment">// Given the particle’s position, we want to render it like a Gaussian blob in the fragment shader</span><br><span class="hljs-comment">// For each pixel, we check its distance to the center of the particle, and then calculate a color based on a decay function</span><br>distance = <span class="hljs-built_in">length</span>(frag_pos – particle_pos)<br>decay = <span class="hljs-number">1</span> / distance<br>frag_color = color * brightness * decay <span class="hljs-comment">// Get a bright color with a short distance / Get a dark color with a long distance</span><br><span class="hljs-keyword">return</span> frag_color<br><br><span class="hljs-comment">// We can play with the distance, direction, as well as the decay function to produce different particle shapes</span><br></code></pre></td></tr></table></figure>
<h3 id="recap-render-multiple-particles-in-fragment-shader">Recap: Render Multiple Particles in Fragment Shader</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- Input: <span class="hljs-comment">/*fragment coordinate*/</span> frag_pos<br>- Output: <span class="hljs-comment">/*fragment color*/</span> frag_color<br>- Algorithm:<br>frag_color = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">// Use a for loop to go over all particles for each pixel</span><br><span class="hljs-keyword">for</span> each particle p:<br>  get its position, brightness, <span class="hljs-keyword">and</span> color <span class="hljs-comment">// We can create functions of time to change each particle’s appearance (e.g., brightness and color) to produce effects like flickering, fading, color transition, etc.</span><br>  <span class="hljs-comment">// The color of the fragment is the sum of contributions from all particles on the screen</span><br>  frag_color += <span class="hljs-built_in">SingleParticleColor</span>(frag_pos, particle_pos, brightness, color)<br><span class="hljs-keyword">return</span> frag_color<br></code></pre></td></tr></table></figure>
<h3 id="surface-element-surfel">Surface Element (Surfel)</h3>
<ul>
<li>A surfel is defined as a point in space carrying a list of attributes (position:x, color:c)</li>
<li>A surfel encapsulates the properties of a small patch of a surface</li>
<li>Extended attributes include normal, radius, and other shading properties such as transparency</li>
</ul>
<h3 id="using-surfels-to-represent-a-surface">Using Surfels to Represent a Surface</h3>
<ul>
<li>Each surfel represents as a small patch of the surface</li>
<li>A certain surface area is associated with each surfel</li>
<li>Its normal vector represents the normal direction of the surface on the local patch</li>
<li>How to represent the surface between the points? Surfels need to interpolate the surface between the points</li>
</ul>
<h4 id="surfel-interpolation">Surfel Interpolation</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><mtext> </mtext><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">c(p) = \frac{\sum_i c_i \, w_i(p)}{\sum_i w_i(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.63em;vertical-align:-0.57em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.06em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1496em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.535em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1496em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.57em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<ul>
<li>Each surfel carries a kernel function spreading its contribution over neighboring points</li>
<li>The <em>splat function</em> defines the shape and intensity of this spread, often using a Gaussian kernel (where Gaussian Splatting comes from) or an elliptical kernel to simulate natural energy distribution</li>
<li>The value of a new point on the surface is interpolated using the kernel function of each neighboring surfel (think of weighted average, here we do normalization so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_i w_i(p) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)</li>
</ul>
<h2 id="point-based-rendering-pipeline">Point-based rendering pipeline</h2>
<h3 id="shading">Shading</h3>
<p>For each surfel, we shade its color using conventional shading models (e.g., phong shading) and then store its color on the surfel.</p>
<h3 id="warping-变形">Warping (变形)</h3>
<p>Warping in the point-based rendering pipeline refers to the transformation of surface colors from object space to image space using a reconstruction technique. It ensures that colors from surfels (surface elements) are accurately transferred to the final pixel representation in screen space.</p>
<h4 id="rendering-surfels-on-screen">Rendering Surfels on Screen</h4>
<ul>
<li>Considers surfels as discrete samples of a texture function on a surface in 3D <strong>object space</strong>. We can imagine a set of points (with colors, normals, etc.) scattered nonuniformly over an object. Conceptually, these surfels approximate some continuous function (like a texture or color distribution) on the 3D surface.</li>
<li>When we render an image, we have a uniform grid of pixels in 2D screen space. Each pixel is effectively a sample of the projected surface function. So there’s a change in coordinate system: from 3D object space to 2D screen space. A <em>Gaussian kernel (splat function)</em> is used to recover a continuous signal such that we can sample it in 2D <strong>screen space</strong>.</li>
<li>The rendering process can be thought of as a <strong>resampling process</strong> to reconstruct the signal in screen space.</li>
<li>To figure out each pixel’s color (or any other attribute), we need to “look up” how that pixel relates back to the surfels in object space. <strong>Resampling</strong> is the process of:
<ul>
<li>Reconstructing the continuous function from the nonuniform surfel samples (often via a smoothing kernel, e.g. a Gaussian “splat”)</li>
<li>Evaluating that reconstructed function at the uniform pixel grid in screen space.</li>
</ul>
</li>
</ul>
<p>PS: whenever see “resampling,” think:</p>
<p>“I have some discrete data in one domain. I want to produce discrete data in another domain. So I reconstruct (smooth/interpolate) and then sample again in the new domain.”</p>
<p><img src="obj2screen.png" alt="Object and Screen Mapping"></p>
<p><img src="warping.png" alt="Warping"></p>
<p><img src="warping_proc.png" alt="Illustration of Warping Process"></p>
<h4 id="point-based-shading-and-warping-algorithm">Point-based Shading and Warping Algorithm</h4>
<ul>
<li>Stage I: go over all surfels (Happens in the vertex shader)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> each surfel:<br>  shade its surface color<br>  splat (溅) <span class="hljs-keyword">with</span> warped reconstruction kernel<br>  accumulate splat <span class="hljs-keyword">and</span> weight<br></code></pre></td></tr></table></figure>
<ul>
<li>Stage II: go over all pixels (Happens in the fragment shader)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> each pixel:<br>    normalize <span class="hljs-comment"># Normalize the accumulated values to compute final pixel colors.</span><br></code></pre></td></tr></table></figure>
<h3 id="visibility">Visibility</h3>
<h4 id="visibility-test">Visibility test</h4>
<p>The visibility test ensures that only visible surface elements (surfels) contribute to the final pixel color.</p>
<p><img src="visibility_test.png" alt="Discard occluded splats"></p>
<ul>
<li>The z-threshold accumulate splats is a depth threshold that determines whether multiple splats should be accumulated or discarded.</li>
<li>If the depth difference between the incoming splat and the current depth buffer value is within the threshold, the splat is accumulated (blended with the existing color and weight at that pixel).</li>
<li>If the splat is too far from the existing depth value, it is discarded to avoid artifacts from occluded (被遮挡的) surfaces.</li>
</ul>
<p>See the psudocode of depth test.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// for each pixel (x,y)</span><br><span class="hljs-built_in">DepthTest</span>(x,y) &#123;<br>  <span class="hljs-comment">// splat z - The depth value of the surfel.</span><br>  <span class="hljs-comment">// z(x,y) - Stores the depth value of the closest splat already written to the pixel (x,y) in the Z-buffer.</span><br>  <span class="hljs-comment">// The Z-buffer keeps track of the depth of the closest visible surface to ensure correct occlusion.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(splat z - <span class="hljs-built_in">z</span>(x,y)) &lt; threshold) &#123;<br>    <span class="hljs-comment">// Accumulate the splat&#x27;s color if it is within a small depth threshold (i.e., close to current z).</span><br>    <span class="hljs-built_in">c</span>(x,y) = <span class="hljs-built_in">c</span>(x,y) + splat color<br>    <span class="hljs-built_in">w</span>(x,y) = <span class="hljs-built_in">w</span>(x,y) + splat <span class="hljs-built_in">w</span>(x,y)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (splat z &lt; <span class="hljs-built_in">z</span>(x,y)) &#123;<br>    <span class="hljs-comment">// Replace the current depth if the new splat is closer to the camera.</span><br>    <span class="hljs-built_in">z</span>(x,y) = splat z<br>    <span class="hljs-built_in">c</span>(x,y) = splat color<br>    <span class="hljs-built_in">w</span>(x,y) = splat <span class="hljs-built_in">w</span>(x,y) <span class="hljs-comment">// The weight determining the influence of the splat in blending.</span><br>  &#125;<br>  <span class="hljs-comment">// Discard the splat if it is behind an existing surfel.</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="alpha-blending">Alpha blending</h4>
<p><img src="alpha_blending.png" alt="alpha blending"></p>
<ol>
<li>Additive Blending (Left)</li>
</ol>
<ul>
<li>Computes pixel color as a weighted average of all surfel contributions.</li>
</ul>
<ol start="2">
<li>Absorption Blending (Right)</li>
</ol>
<ul>
<li>Models light absorption through a volume, similar to NeRF (Neural Radiance Fields).</li>
</ul>
<h3 id="filtering">Filtering</h3>
<p>Filtering in the point-based rendering pipeline is applied after surfels are warped to screen space to smooth accumulated colors before final sampling. This step ensures high-quality reconstruction by avoiding holes, reducing aliasing and preserving details. After the surfels are warped to screen, we will perform a low-pass filter onto the accumulated colors and sample on the output grid.</p>
<p><img src="filtering.png" alt="filtering"></p>
<p>In the figure above,</p>
<ul>
<li>Warping (Step 2): Surfels are projected from source space to destination space (screen space).</li>
<li>Filtering (Step 3): A low-pass filter is applied to the warped surfel contributions, typically using:
<ul>
<li>Reconstruction kernels to smooth scattered surfel data.</li>
<li>Convolution-based filtering to aggregate values before sampling.</li>
</ul>
</li>
<li>Sampling (Step 4): The final colors are resampled onto the pixel grid for output.</li>
</ul>
<h2 id="ps-the-meaning-of-splat-in-the-context-of-gaussian-splatting">PS: the meaning of “splat” in the context of Gaussian Splatting</h2>
<p>As a verb, it refers to the process of projecting and blending a Gaussian-shaped surfel (a small surface element) onto the image plane. As a noun, it refers to the projected contribution of a 3D Gaussian (or surfel) onto the 2D image plane during rendering.</p>
<ul>
<li>3D Gaussians Representation
<ul>
<li>Each surfel (point in 3D space) is represented as an anisotropic (direction-dependent) or isotropic (uniform) Gaussian blob.</li>
<li>These Gaussians have a position, scale, orientation, color, and opacity.</li>
</ul>
</li>
<li>Splatting Process (Projection &amp; Blending)
<ul>
<li>Each Gaussian is projected onto the 2D screen.</li>
<li>Instead of a single pixel, it contributes to multiple pixels based on its Gaussian distribution.</li>
<li>This creates a smooth and continuous blending effect.</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/" class="category-chain-item">Graphics</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/graphics/" class="print-no-link">#graphics</a>
      
        <a href="/tags/Gaussian-Splatting/" class="print-no-link">#Gaussian Splatting</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CS 8803 CGA - Point-based Rendering</div>
      <div>http://example.com/2025/02/22/CS8803-CGA-L11/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 22, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/25/CS8803-CGA-L12/" title="CS 8803 CGA - Differentiable Rasterization">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CS 8803 CGA - Differentiable Rasterization</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/20/CS8803-CGA-L10/" title="CS 8803 CGA - Advance topics for NeRF">
                        <span class="hidden-mobile">CS 8803 CGA - Advance topics for NeRF</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
