

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="I initially decided to put all reviews in one blog, but as I added more and more contents, it seemd to become too long for a single blog. Therefore, I sperate the cpp part (maybe also the computer net">
<meta property="og:type" content="article">
<meta property="og:title" content="Graphics Interview Review 2">
<meta property="og:url" content="http://example.com/2025/04/06/interview-review2/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="I initially decided to put all reviews in one blog, but as I added more and more contents, it seemd to become too long for a single blog. Therefore, I sperate the cpp part (maybe also the computer net">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-05T21:07:22.060Z">
<meta property="article:modified_time" content="2025-05-25T13:23:27.964Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="graphics">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Graphics Interview Review 2 - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Graphics Interview Review 2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-06 05:07" pubdate>
          April 6, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          346 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Graphics Interview Review 2</h1>
            
            
              <div class="markdown-body">
                
                <p>I initially decided to put all reviews in one blog, but as I added more and more contents, it seemd to become too long for a single blog. Therefore, I sperate the cpp part (maybe also the computer network and os part? Let’s see if we have enough room for these two parts in this blog, or we need another new blog for them …). Anyway, let’s review cpp basics. Again, this is for interviews in Chinese, so I’ll use English only when it’s necessary.</p>
<h1 id="c-basics">C++ Basics</h1>
<h2 id="1-多态虚函数">1. 多态/虚函数</h2>
<p>虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p>
<h3 id="1-多态">(1) 多态</h3>
<ul>
<li>定义：同一个接口可以表现出不同行为</li>
<li>分类：
<ul>
<li>静态多态（编译时）：函数重载、模板函数</li>
<li>动态多态（运行时）：虚函数机制 + 基类指针调用</li>
</ul>
</li>
<li>动态多态原理：
<ul>
<li>在派生类中重写基类中声明的虚函数，这样使用基类指针或引用指向派生类对象时，可以调用到派生类中重写的函数，从而实现多态。具体见下方虚函数实现原理。</li>
<li>必须满足条件：
<ul>
<li>基类需要有虚函数
<ul>
<li>PS: 用派生类的指针去访问/调用虚函数时，实际上并未发生动态多态，因为编译时就能确定对象类型为派生类型，然后直接生成调用派生类虚函数的代码即可，这种叫做静态绑定。这里静态绑定是指编译时就能确定函数调用地址，而动态绑定是指在运行时根据对象实际类型，通过 vptr-&gt;vtable 确定调用地址。</li>
</ul>
</li>
<li>子类使用 override 显式重写</li>
<li>通过<strong>基类</strong>指针或引用调用</li>
</ul>
</li>
</ul>
</li>
<li>模板函数多态：根据传递参数的不同类型，自动生成相应类型的函数代码。</li>
<li>重载函数多态：具体见下方</li>
</ul>
<h3 id="2-虚函数实现原理">(2) 虚函数实现原理</h3>
<p>参考：<br>
<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/vtable-and-vptr-in-cpp/">https://www.geeksforgeeks.org/vtable-and-vptr-in-cpp/</a><br>
<a target="_blank" rel="noopener" href="https://csguide.cn/cpp/object_oriented/virtual_function.html#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">https://csguide.cn/cpp/object_oriented/virtual_function.html#动态多态底层原理</a></p>
<p>虚函数的实现依赖于虚函数表（vtable）机制。</p>
<ul>
<li>当一个类中包含一个虚函数时，编译器会为该类创建一个虚函数表（Virtual Table）。这个表存储着该类的虚函数指针，这些指针指向实际实现该虚函数（most derived function）的代码地址。虚函数表实际类似一个虚函数指针数组。</li>
<li>每个对象实例（object）都隐含一个指向该类的虚函数表的指针（类成员），这个指针在对象创建时被初始化，通常是作为对象的第一个成员变量。注意仅当该类中有虚函数或继承了虚函数时，才会生成这个 <code>_vptr</code>。</li>
<li>当调用一个虚函数时，编译器会<strong>通过对象的虚函数指针查找到该对象所属的类的虚函数表</strong>，并<strong>根据函数的索引值（通常是函数在表中的位置，编译时就能确定）来找到对应的虚函数地址</strong>。然后将控制转移到该地址，实际执行该函数的代码。</li>
<li>对于派生类，其虚函数表通常是在基类的虚函数表的基础上扩展而来的。在派生类中，如果重写了基类的虚函数，那么该函数在派生类的虚函数表中的地址会被更新为指向派生类中实际实现该函数的代码地址。</li>
</ul>
<h3 id="3-虚表指针什么时候产生虚函数表如何生成是和类还是对象绑定创建-10-个实例有几个虚函数表">(3) 虚表指针什么时候产生？虚函数表如何生成？是和类还是对象绑定？创建 10 个实例有几个虚函数表？</h3>
<ul>
<li>
<p><strong>虚表指针</strong>什么时候产生？</p>
<ul>
<li>在<strong>对象创建时由构造函数自动写入</strong>。编译器会在每个含虚函数的类对象中插入一个隐藏成员指针 vptr，并赋值指向所属类的虚函数表。</li>
</ul>
</li>
<li>
<p>虚函数表如何生成？</p>
<ul>
<li>在<strong>编译时</strong>由编译器为每个含虚函数的类生成。每个含虚函数的<strong>类</strong>对应一个虚表。更准确地说，是编译器在分析了类的声明和继承关系后确定了 vtable 的结构和内容，然后在链接期 (link-time) 将这些信息整合并最终确定。</li>
<li>表中列出所有虚函数的实际地址，放在编译器生成的<strong>常量区</strong>（.rodata）</li>
</ul>
</li>
<li>
<p>虚函数表和类/对象的关系？</p>
<ul>
<li>vtable 类级别唯一，每个含虚函数的类有且仅有一张 vtable。每个类的虚函数表在内存中是全局唯一的，<strong>所有该类的对象共享同一个虚函数表</strong>。</li>
<li>vptr 对象级别 每个对象都存一份 vptr，指向对应类的 vtable</li>
</ul>
</li>
<li>
<p>创建 10 个实例，会有几个虚函数表？</p>
<ul>
<li>只有 1 个虚函数表，但每个对象各有 1 个 vptr（通常是 8 字节）</li>
<li>所有 vptr 都指向同一个类的 vtable</li>
</ul>
</li>
</ul>
<h3 id="4-虚函数表怎么构建的内存空间连续吗">(4) 虚函数表怎么构建的？内存空间连续吗？</h3>
<ul>
<li>
<p>虚函数表怎么构建的？</p>
<ul>
<li>构建方式 (编译器的工作):
<ul>
<li>识别虚函数: 编译器首先扫描类的声明，找出所有被声明为 virtual 的成员函数。</li>
<li>确定布局: 对于一个没有基类的类，或者一个继承链的顶端基类，其 vtable 通常<strong>按照虚函数在类中声明的顺序，依次存放这些虚函数的地址</strong>。对于派生类，会继承其基类的 vtable 布局。
<ul>
<li>如果派生类重写 (override) 了基类中的某个虚函数，那么在派生类的 vtable 中，对应<strong>基类虚函数的位置会被替换为派生类重写版本的函数地址</strong>。</li>
<li>如果派生类没有重写某个基类的虚函数，那么该 vtable 条目将继续指向基类中该虚函数的实现（即继承了基类的实现）。</li>
<li>如果派生类定义了新的虚函数（基类中没有的），这些新虚函数的地址通常会追加到从基类继承的 vtable 条目之后。</li>
<li>多重继承:<br>
如果一个类从多个基类继承（且这些基类都有虚函数），情况会更复杂。对象内部可能包含多个 vptr，分别指向对应基类部分的 vtable；或者只有一个 vptr 指向一个组合式的 vtable，其中包含了处理不同基类虚函数所需的信息和可能的调整“垫片 (thunks)”。</li>
<li>虚拟继承:<br>
虚拟继承使得 vtable 的结构更加复杂，vtable 中可能还需要存储用于<strong>定位共享虚拟基类子对象的偏移量</strong>。</li>
<li>纯虚函数: vtable 中对应纯虚函数的条目可能指向一个特殊的运行时错误处理函数（例如，在 GCC/Clang 中是 __cxa_pure_virtual），如果意外调用了未被重写的纯虚函数，就会触发这个错误。或者该条目可能为 nullptr。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内存空间连续吗？</p>
</li>
</ul>
<p>是的，单个类的 vtable 本身通常是一个连续的内存块，它本质上是一个函数指针数组（以及可能包含的其他数据）。这种连续性对于通过索引/偏移量快速查找虚函数地址至关重要。</p>
<ul>
<li>虚函数表除了虚函数地址还存了什么？<br>
除了虚函数地址，虚函数表可能还包含以下内容：
<ul>
<li>类型信息：某些编译器会在虚函数表中存储类型信息（如 <strong>RTTI</strong>，Run-Time Type Information），用于支持动态类型检查（如 dynamic_cast）。</li>
<li>析构函数地址：虚函数表中通常会包含类的析构函数地址，以确保<strong>通过基类指针删除派生类对象时能够正确调用派生类的析构函数</strong>。</li>
<li>虚拟基类相关的偏移量: 在使用虚拟继承时，为了能够从派生类对象中正确地定位到共享的虚拟基类子对象的实例，vtable 中可能包含相关的偏移量信息。</li>
<li>到对象顶部的偏移量: 在某些 ABI 中（如 Itanium C++ ABI，vtable[-1]），vtable 可能包含一个值，表示从当前 vptr 指向的 vtable 位置到对象完整实例起始地址的偏移量。这在多重继承或虚拟继承的情况下，当 vptr 可能不指向对象开头时，对于 dynamic_cast 等操作非常有用。</li>
</ul>
</li>
</ul>
<h3 id="4-如果一个基类函数不标明为-virtual子类重写了这个函数那指向子类对象的基类指针调用该函数会发生什么">(4) 如果一个基类函数不标明为 virtual，子类重写了这个函数，那指向子类对象的基类指针调用该函数会发生什么？</h3>
<p>调用的将是基类版本的函数，而不是子类版本的函数。这是因为对<strong>于非虚函数，编译器在编译时就确定了要调用哪个函数版本</strong>。这个决定是基于指针或引用的静态类型 (compile-time type)，而不是它在运行时实际指向的对象的动态类型 (run-time type)，即静态绑定。当派生类中定义了一个与基类中非虚函数同名（且通常参数列表也相同，或者满足隐藏规则）的函数时，派生类的函数会隐藏 (hide) 基类的同名函数。</p>
<h3 id="5-不实现虚函数会报错吗什么错">(5) 不实现虚函数会报错吗？什么错？</h3>
<ul>
<li>不是所有虚函数不实现都会报错，但纯虚函数（= 0）如果不实现，会报错。
<ul>
<li>普通虚函数未被派生类重写，如果基类指针调用虚函数的话就直接调用基类中的实现。</li>
<li>纯虚函数（= 0）表示类是抽象的，必须在派生类中重写，否则派生类也成为抽象类，不能实例化。<br>
如果你试图实例化未重写纯虚函数的类，会在编译时报“无法实例化抽象类”的错误。</li>
</ul>
</li>
</ul>
<h3 id="6-纯虚函数">(6) 纯虚函数</h3>
<ul>
<li>令普通的虚函数=0，从而得到特殊的虚函数，它没有实现，只声明接口，目的是强制派生类必须重写它。</li>
<li>一个类中 只要有一个纯虚函数，那么这个类就成为了一个 抽象类（abstract class）。
<ul>
<li><strong>抽象类不能实例化对象</strong></li>
<li>通常用于定义接口或基础模板行为</li>
<li>继承它的子类需要提供纯虚函数的实现，才能生成对象。如果子类没有实现基类中的纯虚函数，会导致子类本身也成为一个抽象类。这种情况下，子类无法被实例化。如果试图实例化一个没有实现所有纯虚函数的子类对象，编译器会报错提示该类是抽象类，不能实例化。</li>
</ul>
</li>
<li>作用：
<ul>
<li>抽象出一个接口（函数签名）</li>
<li>不能在该类中实现逻辑（除非你显式写定义，定义后仍不能实例化，但可以在派生类里调用）</li>
<li>必须在派生类中实现，否则派生类也变成抽象类，不能被实例化</li>
</ul>
</li>
</ul>
<h3 id="7-哪些函数不能是虚函数">(7) 哪些函数不能是虚函数</h3>
<p>构造、内联、静态成员、lamda 函数</p>
<h3 id="8-重载重写隐藏的区别">(8) 重载/重写/隐藏的区别</h3>
<ul>
<li>重载（Overload）
<ul>
<li>相同作用域(比如命名空间或者同一个类)内，拥有相同的方法名，但具有不同的参数类型和/或参数数量的方法，返回类型可以相同或不同。</li>
<li>编译期允许根据所提供的参数不同来调用不同的函数。</li>
</ul>
</li>
<li>重写（Override）
<ul>
<li>重写是指在派生类中，用相同签名实现基类中的虚函数。</li>
<li>当派生类需要改变或扩展基类方法的功能时，就需要用到重写。</li>
<li>重写的条件包括：
<ul>
<li>方法具有相同的名称。</li>
<li>方法具有相同的参数类型和数量。</li>
<li>方法具有相同的返回类型。</li>
</ul>
</li>
</ul>
</li>
<li>隐藏（name hiding）
<ul>
<li>隐藏是指在派生类中声明了一个与基类同名的函数（不管参数/返回类型是否相同），会遮蔽基类中所有同名函数，使其在派生类作用域中不可见。</li>
<li>怎么解决隐藏？
<ul>
<li>使用 using 声明将基类函数重新引入派生类作用域：</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-多继承菱形继承虚继承的影响">(9) 多继承/菱形继承/虚继承的影响</h3>
<ul>
<li>
<p>多继承</p>
<ul>
<li>
<p>每个带虚函数的基类会生成自己的 vtable</p>
</li>
<li>
<p><strong>派生类对象中有多个 vptr</strong></p>
</li>
<li>
<p>派生类的<strong>各个基类子对象在内存中排列是有偏移的</strong>，因此当派生类指针转换为基类指针时，编译器会插入偏移调整逻辑，确保指针准确指向该基类的子对象。<strong>指针偏移（pointer adjustment）</strong> 是 C++ 为了正确支持多态行为而做的底层处理之一。<br>
例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::fa()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::fb()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;C::fa()\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;C::fb()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    C c;<br>    A* ap = &amp;c;  <span class="hljs-comment">// A 是第一个基类，无需偏移</span><br>    B* bp = &amp;c;  <span class="hljs-comment">// B 是第二个基类，bp != &amp;c，发生了偏移！</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Address of c:  &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;A* points to:  &quot;</span> &lt;&lt; ap &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;B* points to:  &quot;</span> &lt;&lt; bp &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>假设输出类似（64 位地址）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Address</span> of c:  <span class="hljs-number">0</span>x7ffeefbff4b0<br><span class="hljs-attribute">A</span>* points to:  <span class="hljs-number">0</span>x7ffeefbff4b0<br><span class="hljs-attribute">B</span>* points to:  <span class="hljs-number">0</span>x7ffeefbff4b8<br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>&amp;c</code> 是 <code>C</code> 对象的起始地址</li>
<li><code>A*</code> 是第一个基类，子对象从偏移 <code>0</code> 开始</li>
<li><code>B*</code> 是第二个基类，子对象从偏移 <code>8</code> 开始（因为 vptr + 对象成员）</li>
</ul>
<p>所以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">B* bp = <span class="hljs-built_in">static_cast</span>&lt;B*&gt;(&amp;c);  <span class="hljs-comment">// 实际是: (void*)((char*)&amp;c + 8)</span><br></code></pre></td></tr></table></figure>
<p>这就是<strong>指针偏移</strong>，为了使 <code>B*</code> 指针指向 <code>B</code> 部分的子对象，确保访问到正确的 vptr / 成员变量。否则：</p>
<ul>
<li>虚函数调用找不到对应 vtable</li>
<li>成员访问可能读取错误地址</li>
</ul>
<p>对象内存布局（简化）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[C object]</span><br>┌──────────────┐<br>│ vptr_A       │ ← <span class="hljs-selector-tag">A</span> 子对象（起始地址）<br>└──────────────┘<br>┌──────────────┐<br>│ vptr_B       │ ← <span class="hljs-selector-tag">B</span> 子对象（偏移 +<span class="hljs-number">8</span>）<br>└──────────────┘<br></code></pre></td></tr></table></figure>
<ul>
<li><code>A*</code> 指向 <code>vptr_A</code></li>
<li><code>B*</code> 指向 <code>vptr_B</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>菱形继承（diamond inheritance）</p>
<ul>
<li>
<p>总结：菱形继承会导致基类出现多份拷贝，引发资源冗余和二义性。通过 虚继承（为解决多重继承中的菱形继承问题而设计的机制）保证<strong>只保留一份虚基类子对象</strong>（确保基类只会被继承一次，不管有多少条继承路径），并通过额外的虚基偏移表与多层虚表结构，保证在运行时仍可正确解析虚函数。这会增加对象的内部结构复杂度，但是支持多态继承的关键技术。</p>
</li>
<li>
<p>菱形继承就是派生类 D 的两个基类 B 和 C 都继承自同一个基类 A，也就是说 D 有两份 A 的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::f\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>PS：类的继承有 3 种方式，对应基类成员在派生类中的访问级别变化（派生类中如何公开基类的成员访问权限给外部）。</p>
<ul>
<li>public：保持原有访问权限不变</li>
<li>protected：public-&gt;protected</li>
<li>private：public/protected-&gt;private</li>
</ul>
</li>
<li>
<p>非虚继承下的影响</p>
<ul>
<li>D 对象中有 两份 A 的子对象</li>
<li>每份 A 都有独立的 vptr 和 vtable</li>
<li>D 对象体积变大，访问 A 成员/虚函数有二义性<br>
例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">D d;<br>d.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 编译报错：二义性（B::A 和 C::A 都有 f()）</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>解决方案：虚继承</p>
<ul>
<li>实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>D 中只保留 一份 A 子对象</li>
<li>B 和 C 中的 A 不再独立拥有 vptr</li>
<li>A 成为一个共享的虚基类（virtual base）</li>
<li>然而，不同于非虚继承的指针偏移是固定的，虚继承需在运行时动态调整偏移</li>
</ul>
</li>
<li>虚继承下 vtable 的特殊布局
<ul>
<li>虚基类的子对象可能不在派生类开头</li>
<li>编译器会生成一个特殊的 “虚基偏移表”（virtual base offset table，通常被实现为一个<strong>偏移量数组</strong>），这个表存储在每个含有虚继承的类的虚表（vtable）中，它是编译器在编译含有虚继承的类（如上例中的 B/C）时为该类生成的。注意这里没有单独存在的“虚基表对象”，而是在类的 vtable 中预留了指向虚基类偏移的槽位表中每个条目对应一个虚基类，条目的值是<strong>从派生类对象的起始位置到虚基类子对象起始位置的字节偏移量</strong>。实际的偏移值是由最底层的派生类（如 D）决定的。VBOT 在<strong>运行时</strong>用于动态调整指针，以便访问虚基类的成员。当指向派生类的指针被转换为指向虚基类的指针时，编译器使用 VBOT 来计算基类子对象的正确地址，确保指针指向内存中的正确位置。如果一个类使用了虚继承，则编译期在构造其对象时会自动插入一个隐藏成员虚基表指针（vbptr），在构造函数中另指针指向类的虚基偏移表。注意区别“表”是绑定类的，“指针”是绑定对象实例的。</li>
<li>内存结构示意：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[D object]</span><br>├── <span class="hljs-selector-tag">B</span> subobject<br>│   └── vptr_B → vtable_B<br>│             → <span class="hljs-attribute">offset</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">A</span><br>├── C subobject<br>│   └── vptr_C → vtable_C<br>│             → <span class="hljs-attribute">offset</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">A</span><br>├── shared <span class="hljs-selector-tag">A</span> subobject<br>│   └── vptr_A → vtable_A<br></code></pre></td></tr></table></figure>
</li>
<li><strong>不同于非虚继承，虚继承不能用固定指针偏移，必须运行时查表确定偏移</strong>。这是因为虚基类的内存位置在派生类中是“不固定”的。虚继承支持多路径继承、深度继承、多个派生类共享同一个虚基类，所以编译器不能在某个类定义时就固定虚基类的地址，只能等到最底层派生类生成对象时再确定。<br>
对于非虚继承：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123; <span class="hljs-type">int</span> b; &#125;;<br>B b;<br>A* p = &amp;b;  <span class="hljs-comment">// 偏移是 0（编译期已知 A 在 B 起始位置），直接赋值，无需查表，无运行时开销</span><br></code></pre></td></tr></table></figure>
而在上面例子的菱形继承+虚继承中，编译时 B/C 的 vtable 中生成偏移槽（虚基表项）；链接时/最终派生类构建时（如 D），编译器根据 D 的布局计算偏移量，并填入这些槽中；所以最终 D 实例的虚表中就含有完整的偏移信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-构造函数和析构函数能不能为虚函数">(10) 构造函数和析构函数能不能为虚函数？</h3>
<ul>
<li>
<p>构造函数不能声明为虚函数：</p>
<ul>
<li>对象尚未完全构建:虚函数调用的核心在于通过对象的虚函数表指针 (vptr) 找到相应的虚函数表 (vtable)，从而在<strong>运行时</strong>确定调用哪个版本的函数（基类的还是派生类的）。这个 vptr 是在对象构造过程中由构造函数设置的。具体来说，当一个对象的<strong>构造函数开始执行时，vptr 会被设置为指向该类自己的 vtable</strong>。如果存在继承链，<strong>基类的构造函数会先执行</strong>，将其 vptr 指向基类的 vtable；然后派生类的构造函数执行，再将其 vptr 更新为指向派生类的 vtable。如果构造函数本身是虚函数，那么在调用构造函数来创建对象时，对象本身还不存在或者说还没有完成初始化，vptr 尚未被正确设置到指向“最终”派生类型的 vtable。那么，系统将无法确定应该调用哪个“虚拟”版本的构造函数。这就形成了一个“鸡生蛋还是蛋生鸡”的问题：你需要一个完整的对象（包含有效的 vptr）来进行虚函数调用，但构造函数的目的正是去创建和初始化这个对象。</li>
<li>类型在构造时已确定:当创建一个对象时，我们显式地指定了要创建的对象的具体类型。编译器在编译时就已经确切知道应该调用哪个类的构造函数。虚函数机制是为了<strong>解决通过基类指针或引用调用派生类重写方法时的动态分派问题</strong>——即在编译时不知道指针/引用所指向对象的具体动态类型。但在对象创建的那一刻，类型是明确的，不需要动态分派来选择构造函数。</li>
</ul>
</li>
<li>
<p>析构函数一般声明为虚函数：析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果<strong>未将基类的析构函数定义成虚函数 或 子类析构函数未实现</strong>，则会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</p>
</li>
</ul>
<p>PS: 然而类中默认的析构函数并不是虚函数，这是因为：</p>
<ul>
<li>虚函数有运行时成本，需要<strong>额外的内存开销</strong>（生成 vtable、vptr）</li>
<li>编译器无法知道类是否会被当作基类使用</li>
<li>所以默认不会加 virtual，只有显式声明或继承虚函数时才会虚化</li>
</ul>
<h3 id="11-一个类既不继承也不是子类内部也没有虚函数那它的析构函数需要声明为虚函数吗">(11) 一个类既不继承也不是子类，内部也没有虚函数，那它的析构函数需要声明为虚函数吗？</h3>
<ul>
<li>虚析构函数是为了解决“通过基类指针删除派生类对象”时，能正确调用派生类的析构函数。</li>
<li>题述没有多态行为，也就不会通过基类指针删除派生类对象</li>
<li>使用虚析构函数的代价
<ul>
<li>虚函数会增加 vtable（虚函数表）和 vptr（虚函数指针），增加内存开销</li>
<li>调用析构函数时，会有额外的虚表查找开销。</li>
</ul>
</li>
<li>保持非虚析构函数可以减少对象大小和函数调用开销</li>
</ul>
<h2 id="2-智能指针">2. 智能指针</h2>
<ul>
<li>指针管理的困难
<ul>
<li>资源释放了，指针没有置空。即 p = new … ; delete p; 然后未使 p = nullptr，会造成结果：
<ul>
<li>野指针 （资源释放了指针未置空）</li>
<li>指针悬挂（多个指针指向同一块内存，资源释放掉之后置空了一个指针，但其他指针不知道）（悬空指针：指向已释放的内存）</li>
<li>踩内存 （上述两种情况都可能踩内存，就是资源已经释放了，原来的内存变成了别的东西，但仍然试图用野指针去操作它）</li>
</ul>
</li>
<li>没有释放资源，产生内存泄露（忘记释放动态分配的内存）
<ul>
<li>忘记 delete</li>
<li>if 判断后 return 在 delete 之前</li>
<li>delete 在抛出异常之后</li>
</ul>
</li>
<li>重复释放资源，引发 coredump</li>
</ul>
</li>
</ul>
<p>解决指针管理的困难就是使用 RAII 或者 智能指针。</p>
<p>RAII (Resource Acquisition Is Initialization) ensures that <strong>resources are properly acquired when an object is created and automatically released when the object goes out of scope or is destroyed</strong>.</p>
<p>简而言之，变量出了作用范围就调用析构函数，从而实现自动管理生命周期。</p>
<h3 id="1-智能指针类型及各自原理">(1) 智能指针类型及各自原理</h3>
<p>主要有三种，位于<code>&lt;memory&gt;</code>头文件中。</p>
<ul>
<li>
<p><code>std::unique_ptr&lt;T&gt;</code></p>
<ul>
<li>独占所有权</li>
<li>没有拷贝构造函数所以不允许拷贝，但是使用移动语义，允许移动（std::move）。也就是说不允许 <code>b = a</code>，但允许 <code>b = std::move(a)</code>。这样做就意味着 unique_ptr 一定是独占所有权的。</li>
<li>适用于独占资源管理（如文件、网络连接）、工厂函数返回值、pImpl (指向实现的指针) 模式</li>
<li>析构函数中自动删除所管理的对象</li>
<li>用  <code>std::make_unique&lt;T&gt;(args...)</code>  创建（C++14+）</li>
</ul>
</li>
<li>
<p><code>std::shared_ptr&lt;T&gt;</code></p>
<ul>
<li>共享所有权</li>
<li>采用<strong>引用计数</strong>，多个 shared_ptr 可共享同一对象（多个指针指向同一个资源），引用计数为 0 时调用析构函数，即最后一个销毁时释放资源</li>
<li>public 成员函数 use_count() 返回当前引用计数。这个函数是线程安全的因为 use_count 是原子地更新的。</li>
<li>存在<strong>循环引用</strong>风险，可配合  std::weak_ptr  解决</li>
<li>用  <code>std::make_shared&lt;T&gt;(args...)</code>  创建，减少内存分配开销</li>
</ul>
</li>
<li>
<p><code>std::weak_ptr&lt;T&gt;</code></p>
<ul>
<li>
<p>弱引用</p>
</li>
<li>
<p>依赖 shared_ptr，<strong>允许拷贝</strong>，但<strong>不会增加引用计数</strong>（没有 use_count() 函数）</p>
</li>
<li>
<p>用于解决 shared_ptr  循环引用问题，缓存中防止指针悬挂</p>
</li>
<li>
<p>可通过 lock() 获取 shared_ptr，判断对象是否仍然有效</p>
<ul>
<li>weak_ptr 是观察者，不拥有对象，不增加引用计数</li>
<li>如果原对象还活着，lock()返回有效 shared_ptr</li>
<li>如果对象已经被销毁，lock()返回空指针</li>
<li>避免了悬空指针访问，非常适用于缓存、监听器、资源管理等场景</li>
<li>始终使用 lock() 访问 weak_ptr 指向的对象，并检查返回值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::weak_ptr&lt;MyClass&gt; weakRef;<br><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 shared_ptr</span><br>        std::shared_ptr&lt;MyClass&gt; sharedRef = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br><br>        <span class="hljs-comment">// 赋值给 weak_ptr（不增加引用计数）</span><br>        weakRef = sharedRef;<br><br>        <span class="hljs-comment">// 尝试通过 lock() 安全访问对象</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> locked = weakRef.<span class="hljs-built_in">lock</span>()) &#123;  <span class="hljs-comment">// 返回 shared_ptr</span><br>            locked-&gt;<span class="hljs-built_in">greet</span>();  <span class="hljs-comment">// 输出：Hello from MyClass!</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Object already destroyed!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// sharedRef 作用域结束后，对象会被销毁</span><br>    &#125;<br><br>    <span class="hljs-comment">// 再次尝试访问已释放的对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> locked = weakRef.<span class="hljs-built_in">lock</span>()) &#123;<br>        locked-&gt;<span class="hljs-built_in">greet</span>();  <span class="hljs-comment">// 不会执行</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object already destroyed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>观察者模式</p>
<ul>
<li>一种常用的设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当一个对象（称为主题）改变状态时，所有依赖于它的对象（称为观察者）都会得到通知并自动更新。</li>
<li>这种模式的主要优点是:
<ul>
<li>它支持松耦合。主题不需要知道观察者的具体类，只需要知道它们实现了 Observer 接口。</li>
<li>它允许动态地添加或移除观察者，而无需修改主题。</li>
</ul>
</li>
<li>潜在的问题：
<ul>
<li>如果观察者过多，通知所有观察者可能会带来性能问题。</li>
<li>如果观察者和主题之间有循环依赖，可能会导致系统崩溃。</li>
<li>在多线程环境中使用时，需要特别注意同步问题。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>weak_ptr::expired()</code> 来检查判断你观察的对象是否已经被销毁（返回 bool）。只想检测是否过期可以用 expired()，想获取对象 + 安全检查 可以用 lock()。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-shared_ptr-的代码实现主要是构造-赋值和析构">(2) shared_ptr 的代码实现（主要是构造、赋值和析构）</h3>
<p>源码见：<br>
<a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/shared_ptr.h">https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/shared_ptr.h</a><br>
<a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h</a><br>
<a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_atomic.h">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_atomic.h</a></p>
<p>参考：<br>
<a target="_blank" rel="noopener" href="https://medium.com/analytics-vidhya/c-shared-ptr-and-how-to-write-your-own-d0d385c118ad">https://medium.com/analytics-vidhya/c-shared-ptr-and-how-to-write-your-own-d0d385c118ad</a><br>
<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384894475">https://zhuanlan.zhihu.com/p/384894475</a><br>
<a target="_blank" rel="noopener" href="https://csguide.cn/cpp/memory/shared_ptr.html#%E6%89%8B%E5%86%99-shared-ptr">https://csguide.cn/cpp/memory/shared_ptr.html#手写-shared-ptr</a></p>
<p>内部实现原理</p>
<ul>
<li>包含两个指针：一个指向对象，一个指向控制块</li>
<li>控制块包含引用计数和删除器</li>
<li>当 shared_ptr 被销毁（例如通过析构函数）或重置（通过 reset 方法）时，计数器减少。</li>
<li>当引用计数降为 0 时，删除对象和控制块</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// MySharedPtr&lt;int&gt; a(new int(100));</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MySharedPtr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">        : _m_ptr(ptr), _m_refcount(new size_t(<span class="hljs-number">1</span>)) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-built_in">MySharedPtr</span>(<span class="hljs-type">const</span> MySharedPtr&amp; other)<br>        : _m_ptr(other._m_ptr), _m_refcount(other._m_refcount) &#123;<br>        ++(*_m_refcount);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MySharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">release</span>();<br>            _m_ptr = other._m_ptr;<br>            _m_refcount = other._m_refcount;<br>            ++(*_m_refcount);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>        : _m_ptr(other._m_ptr), _m_refcount(other._m_refcount) &#123;<br>        other._m_ptr = <span class="hljs-literal">nullptr</span>;<br>        other._m_refcount = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值</span><br>    <span class="hljs-comment">// MySharedPtr&amp; operator=(MySharedPtr&amp;&amp; other) noexcept &#123;</span><br>    <span class="hljs-comment">//     if (this != &amp;other) &#123;</span><br>    <span class="hljs-comment">//         release();</span><br>    <span class="hljs-comment">//         _m_ptr = other._m_ptr;</span><br>    <span class="hljs-comment">//         _m_refcount = other._m_refcount;</span><br>    <span class="hljs-comment">//         other._m_ptr = nullptr;</span><br>    <span class="hljs-comment">//         other._m_refcount = nullptr;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 使用 swap 的移动赋值</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-built_in">MySharedPtr</span>(std::<span class="hljs-built_in">move</span>(other)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MySharedPtr</span>() &#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 返回裸指针</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _m_ptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放当前资源，并可选替换为新对象</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* new_ptr = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>        <span class="hljs-built_in">release</span>();  <span class="hljs-comment">// 释放旧资源</span><br>        <span class="hljs-keyword">if</span> (new_ptr) &#123;<br>            _m_ptr = new_ptr;<br>            _m_refcount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _m_ptr = <span class="hljs-literal">nullptr</span>;<br>            _m_refcount = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *_m_ptr; &#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> _m_ptr; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _m_refcount ? *_m_refcount : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// swap 成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MySharedPtr&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_m_ptr, other._m_ptr);<br>        std::<span class="hljs-built_in">swap</span>(_m_refcount, other._m_refcount);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T* _m_ptr = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">size_t</span>* _m_refcount = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_m_refcount_ &amp;&amp; --(*_m_refcount_) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">delete</span> _m_ptr;<br>            <span class="hljs-keyword">delete</span> _m_refcount;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<p><strong>解析</strong>：</p>
<ul>
<li>
<p>explicit 用于修饰（单参数）构造函数或转换函数，防止它们被隐式调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A constructed with &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 错误：不允许隐式转换</span><br>    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">A</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// 明确构造才允许</span><br>&#125;<br><br><span class="hljs-comment">// explicit 也可以用于修饰转换函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br>B b;<br><span class="hljs-keyword">if</span> (b) &#123; ... &#125;          <span class="hljs-comment">// 可以</span><br><span class="hljs-type">bool</span> x = b;             <span class="hljs-comment">// 错误，不能隐式转换</span><br></code></pre></td></tr></table></figure>
<ul>
<li>使用 explicit 修饰 shared_ptr 的构造函数是因为：
<ul>
<li>阻止隐式构造：避免误用裸指针构造，必须显式创建智能指针</li>
<li>明确表达所有权转移：让开发者明确知道“我把这块资源交给 shared_ptr 管了”</li>
<li>与 std::shared_ptr 行为一致</li>
</ul>
</li>
</ul>
</li>
<li>
<p>GCC 的源码（尤其是 libstdc++）中，经常会看到变量名像 _M_ptr, _M_refcount, _M_impl，这是习惯的命名风格：</p>
<ul>
<li><em>M</em> Member variable，表示类的私有成员</li>
<li><em>S</em> Static variable，表示静态成员变量</li>
<li>这样命名的好处可以在复杂实现中清晰地区分公共接口 vs 内部字段，避免变量名冲突</li>
</ul>
</li>
<li>
<p>构造函数中，使用<code>_m_refcount(new size_t(1))</code>而不是<code>_m_refcount(1)</code>，是因为要在<strong>堆</strong>上分配一块内存来存储引用计数，而不是把引用计数存在栈或对象内部。如果是后者，那 <code>_m_refcount</code> 是一个对象的成员变量本身（栈或类内存储），每个 MySharedPtr 对象都有自己独立的一份 refcount，这就不能实现多个智能指针共享同一个计数。当前代码中 <code>_m_refcount</code> 是一个指针(new 返回的是指向内存的指针)，指向共享控制块中的引用计数，当多个 MySharedPtr 拷贝构造或赋值时，共享同一块引用计数内存，这才实现了多个智能指针指向同一个资源时，它们共享引用计数，且能正确地一起控制释放资源。在真正的标准库实现中，会把强引用计数（多少个 shared_ptr）、弱引用计数(多少个 weak_ptr)、deleter 封装在一个控制块（control block）里，并且这块内存和被管理对象可能是一起分配的（如 make_shared）。当强引用计数减到 0 时，被管理的对象会被删除，控制块中的弱引用计数减到 0 时，控制块本身会被删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MySharedPtr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">      : _m_ptr(ptr), _m_refcount(new size_t(<span class="hljs-number">1</span>)) &#123;</span>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>当前代码里的引用计数不是线程安全的，但<code>std::shared_ptr</code>中的引用计数是线程安全的，其中使用了<code>_Atomic_word</code>类型来计数（The type _Atomic_word is a signed integral type supporting atomic operations）。然而，尽管引用计数是线程安全的，其中存储的裸指针并不是线程安全的。也即，<strong>多个线程增减 shared_ptr 的引用计数是线程安全的，但多个线程修改 shared_ptr 指向的对象不是线程安全的（除非对象本身被设计为线程安全的）</strong>。<code>std::shared_ptr</code>的核心职责是管理对象的生命周期（通过共享所有权和引用计数），它确保只要至少有一个 shared_ptr 指向对象，对象就不会被删除。它并不负责同步对<strong>被管理对象本身成员</strong>的访问。</p>
</li>
<li>
<p>当前的简化实现里赋值运算符先调用了 release 释放现有资源。为什么 std::shared_ptr 源代码(<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/libstdc++/api/a00605_source.html">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/libstdc++/api/a00605_source.html</a>)的赋值运算符不删除原有指针？不会有内存泄漏吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Yp&gt;<br>_Assignable&lt;_Yp&gt;<br><span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) <span class="hljs-keyword">noexcept</span><br>&#123;<br>  _M_ptr = __r._M_ptr;    <span class="hljs-comment">//这里不会内存泄露？</span><br>  _M_refcount = __r._M_refcount;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>__shared_ptr(__shared_ptr&amp;&amp; __r) <span class="hljs-keyword">noexcept</span><br>     : _M_ptr(__r._M_ptr), _M_refcount()<br>     &#123;<br>       _M_refcount._M_swap(__r._M_refcount);<br>       __r._M_ptr = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//这里不会内存泄露？</span><br>     &#125;<br></code></pre></td></tr></table></figure>
<p>这是因为，裸指针的生命周期是由引用计数器控制的, 所以在<code>__shared_ptr</code>的其他地方就不需要管理它了。当引用计数器被回收时指针才被销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Ptr, _Lock_policy _Lp&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Sp_counted_ptr</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> _Sp_counted_base&lt;_Lp&gt;<br>  &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">explicit</span><br>    _Sp_counted_ptr(_Ptr __p) <span class="hljs-keyword">noexcept</span><br>    : _M_ptr(__p) &#123; &#125; <span class="hljs-comment">//指针最后是存在了这里</span><br><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span><br>    _M_dispose() <span class="hljs-keyword">noexcept</span><br>    &#123; <span class="hljs-keyword">delete</span> _M_ptr; &#125; <span class="hljs-comment">//引用计数器回收的时候, 指针才会被删除掉</span><br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>另：为什么拷贝构造里不需要考虑释放资源？因为拷贝构造（<code>T b = a;</code> 或 <code>T b(a);</code>）和拷贝赋值（<code>T a; a = b;</code>）调用的时机不同。</p>
</li>
<li>
<p>移动构造/赋值中被移动的对象要被清空，对于 shared_ptr 是这样的，但对于其他的类不一定（如：<code>std::string</code>）。</p>
</li>
<li>
<p>为什么使用 swap+move 实现移动赋值而不是使用被注释掉的方式？当前的赋值运算符是这样实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">MySharedPtr</span>(std::<span class="hljs-built_in">move</span>(other)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 临时对象构造 + swap</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即：</p>
<ul>
<li>构造一个临时的 shared_ptr（从右值中移动而来）</li>
<li>与当前对象 swap()：交换所有权</li>
<li><strong>临时对象离开作用域，原来的资源会被析构释放</strong>。std::move(other) 本身是一个 xvalue（将亡值），MySharedPtr(std::move(other)) 是一个 prvalue（纯右值），它不绑定任何名称，是临时对象。</li>
</ul>
<p>这种实现是参考了 gcc 源码的（<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/libstdc++/api/a00605_source.html%EF%BC%89%E3%80%82%E8%BF%99%E6%A0%B7%E5%81%9A%E6%8F%90%E4%BE%9B%E4%BA%86%E5%BC%BA%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%EF%BC%88%E8%A6%81%E4%B9%88%E6%93%8D%E4%BD%9C%E6%88%90%E5%8A%9F%EF%BC%8C%E8%A6%81%E4%B9%88%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%EF%BC%9A%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E9%83%BD%E5%9C%A8%E6%9E%84%E9%80%A0%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E6%97%B6%E5%AE%8C%E6%88%90%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%EF%BC%8Cthis">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/libstdc++/api/a00605_source.html）。这样做提供了强异常安全（要么操作成功，要么对象不变：所有操作都在构造临时变量时完成，如果发生异常，this</a> 对象仍然保持原样；一旦临时构造成功，再通过 swap() 原子性地交换资源（不可能失败））保证，避免手动资源释放引发状态不一致，并符合 RAII 和 copy-and-swap 设计风格。<br>
另：源码中移动构造函数的实现类似，这里用<code>_M_swap</code>是因为<code>_M_refcount</code>是一个复杂的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">shared_ptr</span>(shared_ptr&amp;&amp; __r) <span class="hljs-keyword">noexcept</span><br>: _M_ptr(__r._M_ptr), _M_refcount() &#123;<br>    _M_refcount._M_swap(__r._M_refcount);<br>    __r._M_ptr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>当前的实现并不完整，它缺少了很多 std::shared_ptr 的高级功能，例如<code>shared_ptr&lt;T[]&gt;</code>数组支持、自定义删除器（deleter）、std::make_shared() 和 std::allocate_shared() 函数以及引用计数的线程安全性等。</p>
</li>
</ul>
<hr>
<p>PS: weak_ptr 的实现？<br>
下面代码来自 ChatGPT 尚未经过测试，仅提供一个思路。这里的核心思想就是加入一个弱引用计数<code>weak_count</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// for std::swap</span></span><br><br><span class="hljs-comment">// 控制块结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ControlBlock</span> &#123;<br>    <span class="hljs-type">size_t</span> shared_count = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">size_t</span> weak_count = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 前置声明</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MySharedPtr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">        : _m_ptr(ptr), _m_ctrl(ptr ? new ControlBlock() : nullptr) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-built_in">MySharedPtr</span>(<span class="hljs-type">const</span> MySharedPtr&amp; other)<br>        : _m_ptr(other._m_ptr), _m_ctrl(other._m_ctrl) &#123;<br>        <span class="hljs-keyword">if</span> (_m_ctrl) _m_ctrl-&gt;shared_count++;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MySharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            MySharedPtr <span class="hljs-built_in">tmp</span>(other);<br>            <span class="hljs-built_in">swap</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>        : _m_ptr(other._m_ptr), _m_ctrl(other._m_ctrl) &#123;<br>        other._m_ptr = <span class="hljs-literal">nullptr</span>;<br>        other._m_ctrl = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值（使用 swap 技巧）</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-built_in">MySharedPtr</span>(std::<span class="hljs-built_in">move</span>(other)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MySharedPtr</span>() &#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *_m_ptr; &#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> _m_ptr; &#125;<br><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _m_ptr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _m_ctrl ? _m_ctrl-&gt;shared_count : <span class="hljs-number">0</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* new_ptr = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>        <span class="hljs-built_in">release</span>();<br>        <span class="hljs-keyword">if</span> (new_ptr) &#123;<br>            _m_ptr = new_ptr;<br>            _m_ctrl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ControlBlock</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _m_ptr = <span class="hljs-literal">nullptr</span>;<br>            _m_ctrl = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MySharedPtr&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_m_ptr, other._m_ptr);<br>        std::<span class="hljs-built_in">swap</span>(_m_ctrl, other._m_ctrl);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span>;<br><br>    T* _m_ptr = <span class="hljs-literal">nullptr</span>;<br>    ControlBlock* _m_ctrl = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_m_ctrl) &#123;<br>            <span class="hljs-keyword">if</span> (--_m_ctrl-&gt;shared_count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> _m_ptr;<br>                _m_ptr = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-keyword">if</span> (_m_ctrl-&gt;weak_count == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">delete</span> _m_ctrl;<br>            &#125;<br>        &#125;<br>        _m_ptr = <span class="hljs-literal">nullptr</span>;<br>        _m_ctrl = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 弱指针</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyWeakPtr</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 构造：从 shared_ptr 构造 weak_ptr</span><br>    <span class="hljs-built_in">MyWeakPtr</span>(<span class="hljs-type">const</span> MySharedPtr&lt;T&gt;&amp; shared)<br>        : _m_ptr(shared._m_ptr), _m_ctrl(shared._m_ctrl) &#123;<br>        <span class="hljs-keyword">if</span> (_m_ctrl) _m_ctrl-&gt;weak_count++;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-built_in">MyWeakPtr</span>(<span class="hljs-type">const</span> MyWeakPtr&amp; other)<br>        : _m_ptr(other._m_ptr), _m_ctrl(other._m_ctrl) &#123;<br>        <span class="hljs-keyword">if</span> (_m_ctrl) _m_ctrl-&gt;weak_count++;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值</span><br>    MyWeakPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyWeakPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            MyWeakPtr <span class="hljs-built_in">tmp</span>(other);<br>            <span class="hljs-built_in">swap</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构</span><br>    ~<span class="hljs-built_in">MyWeakPtr</span>() &#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MyWeakPtr&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_m_ptr, other._m_ptr);<br>        std::<span class="hljs-built_in">swap</span>(_m_ctrl, other._m_ctrl);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _m_ctrl ? _m_ctrl-&gt;shared_count : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !_m_ctrl || _m_ctrl-&gt;shared_count == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function">MySharedPtr&lt;T&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">expired</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">MySharedPtr</span>&lt;T&gt;(*<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 调用私有构造</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">MySharedPtr</span>&lt;T&gt;();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span>&lt;T&gt;;<br><br>    T* _m_ptr = <span class="hljs-literal">nullptr</span>;<br>    ControlBlock* _m_ctrl = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_m_ctrl) &#123;<br>            <span class="hljs-keyword">if</span> (--_m_ctrl-&gt;weak_count == <span class="hljs-number">0</span> &amp;&amp; _m_ctrl-&gt;shared_count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> _m_ctrl;<br>            &#125;<br>        &#125;<br>        _m_ptr = <span class="hljs-literal">nullptr</span>;<br>        _m_ctrl = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 供 shared_ptr(lock) 使用的私有构造</span><br>    <span class="hljs-function">MySharedPtr&lt;T&gt; <span class="hljs-title">make_shared</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">MySharedPtr</span>&lt;T&gt;(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 允许 lock() 构造 shared_ptr</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span>&lt;T&gt;;<br><br>    <span class="hljs-comment">// 私有构造 shared_ptr from weak_ptr</span><br>    <span class="hljs-built_in">MySharedPtr</span>(<span class="hljs-type">const</span> MyWeakPtr&lt;T&gt;&amp; weak)<br>        : _m_ptr(weak._m_ptr), _m_ctrl(weak._m_ctrl) &#123;<br>        <span class="hljs-keyword">if</span> (_m_ctrl) _m_ctrl-&gt;shared_count++;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-stdmake_shared相比stdshared_ptrlttgtnew-targs-有什么好处">(3) <code>std::make_shared</code>相比<code>std::shared_ptr&lt;T&gt;(new T(args...))</code>  有什么好处？</h3>
<p>参考：<br>
<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/std-make-shared-in-cpp/">https://www.geeksforgeeks.org/std-make-shared-in-cpp/</a></p>
<p>当我们创建一个指向已存在对象的共享指针时，会发生 3 次不同的内存分配。一次用于控制块，一次用于对象，一次用于 shared_ptr 本身。但是使用 std::make_shared()，只有两次内存分配。一次用于 shared_ptr，另一次用于控制块和对象。这比传统的共享指针效率更高。</p>
<ul>
<li>避免额外的内存分配+提高缓存命中率：<code>std::make_shared</code>会在一次内存分配中把对象本体和控制块(引用计数)放在一个内存块里，只调用一次 new，而<code>std::shared_ptr&lt;T&gt;(new T(args...))</code>需要两次分别分配。这不仅减少了 malloc/free 的开销，还能提高缓存命中率（前者控制块和对象连续）。</li>
<li>减少异常安全问题：<code>std::shared_ptr&lt;T&gt;(new T(args...))</code>是两个独立的操作，new T(args…)  可能会抛出异常，造成对象已构造，控制块未构造，从而内存泄漏的结果。<code>std::make_shared</code>进行的是原子操作，先分配统一内存，再构造对象和控制块，构造失败直接回滚，不存在这个问题。</li>
<li>代码更简洁：<code>auto ptr = std::make_shared&lt;T&gt;(args...)</code>比<code>auto ptr = std::shared_ptr&lt;T&gt;(new T(args...))</code>更简短，可读性更好。前者还避免了手写 new。</li>
</ul>
<h3 id="4-shared_ptr-线程安全">(4) shared_ptr 线程安全</h3>
<p>std::shared_ptr 的线程安全性由内部引用计数的原子操作来保证（类似<code>std::atomic&lt;size_t&gt;</code>的无锁原子操作完成，不需要全局或 mutex 加锁）。</p>
<ul>
<li>shared_ptr 的引用计数递增/递减是线程安全的
<ul>
<li>多个 shared_ptr 拷贝同一个对象(增/减引用计数是线程安全的)</li>
<li>多个 shared_ptr 同时析构(引用计数为 0 时释放资源只发生一次)</li>
</ul>
</li>
<li>每个 shared_ptr 实例是非线程安全的，不要在多个线程中同时修改同一个对象(需加锁)</li>
</ul>
<h3 id="5-shared_ptr-怎么实现多指针指向同一个地址引用计数如何保证不同类实例的指针之间共享同步">(5) shared_ptr 怎么实现多指针指向同一个地址/引用计数如何保证不同类实例的指针之间共享同步</h3>
<p>所有共享同一个对象的 shared_ptr 实例内部都持有指向同一个控制块的<strong>指针</strong>。</p>
<h3 id="6-循环引用会在什么情况下产生如何解决解决的原理">(6) 循环引用会在什么情况下产生，如何解决，解决的原理</h3>
<ul>
<li><strong>循环引用</strong>是指多个对象通过智能指针互相引用，导致引用计数永远不为零，进而导致内存泄漏。</li>
<li><strong><code>std::shared_ptr</code></strong> 的引用计数机制导致循环引用问题。</li>
<li>使用 <strong><code>std::weak_ptr</code></strong> 可以打破循环引用，因为它不会增加引用计数，从而避免了内存泄漏。</li>
</ul>
<p>如下例，假设有两个类 <code>A</code> 和 <code>B</code>，它们互相持有对方的 <code>std::shared_ptr</code>，形成了循环引用。当 <code>main</code> 函数返回时，<code>a</code> 和 <code>b</code> 虽然超出了作用域，但因为两者仍通过智能指针互相引用，导致引用计数无法归零，因此它们的析构函数不会被调用，不会释放相应的内存，导致内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; ptrB;  <span class="hljs-comment">// A 持有 B 的智能指针</span><br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;A&gt; ptrA;  <span class="hljs-comment">// B 持有 A 的智能指针</span><br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B created\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>    std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>    a-&gt;ptrB = b;  <span class="hljs-comment">// A 持有 B</span><br>    b-&gt;ptrA = a;  <span class="hljs-comment">// B 持有 A</span><br><br>    <span class="hljs-comment">// 到这里，a 和 b 形成了循环引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>循环引用的解决方案是引入 <strong><code>std::weak_ptr</code></strong>。<code>std::weak_ptr</code> 是一种<strong>非拥有</strong>（non-owning）的智能指针，它不增加引用计数，仅仅作为对所指对象的一个弱引用。</li>
</ul>
<p>如下所示将上例中 <code>B</code> 中的 <code>ptrA</code> 修改为 <code>std::weak_ptr</code>，就可以打破循环引用。<code>B</code> 持有 <code>A</code> 的 <code>std::weak_ptr</code>，这不会增加 <code>A</code> 的引用计数，因此，当 <code>a</code> 和 <code>b</code> 超出作用域后，它们的引用计数会归零，从而正常析构，避免了内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; ptrB;  <span class="hljs-comment">// A 持有 B 的智能指针</span><br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::weak_ptr&lt;A&gt; ptrA;  <span class="hljs-comment">// B 持有 A 的弱引用</span><br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B created\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>    std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>    a-&gt;ptrB = b;  <span class="hljs-comment">// A 持有 B</span><br>    b-&gt;ptrA = a;  <span class="hljs-comment">// B 通过 weak_ptr 持有 A</span><br><br>    <span class="hljs-comment">// 循环引用已被打破，内存将正常释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-智能指针构造与析构时间">(7) 智能指针构造与析构时间</h3>
<p>智能指针的构造时间 = 创建时（或从另一个智能指针拷贝/移动时）<br>
智能指针的析构时间 = 作用域结束 或 手动 reset() / = nullptr 时</p>
<p>但注意：<br>
智能指针的析构 不等于 管理的对象立即被释放。</p>
<ul>
<li>如果是 unique_ptr，不共享资源所以只要自身析构就立刻释放资源；</li>
<li>如果是 shared_ptr，管理的对象/资源只有在 最后一个 shared_ptr 析构时才释放；</li>
</ul>
<h3 id="8-野指针-悬挂指针的产生原因解决方法">(8) 野指针、悬挂指针的产生原因，解决方法</h3>
<ul>
<li>野指针（wild pointer）：指针指向一块未初始化或非法的内存（垃圾地址）
<ul>
<li>解决：
<ul>
<li>定义指针立刻初始化</li>
<li>尽量用智能指针</li>
</ul>
</li>
</ul>
</li>
<li>悬挂指针（dangling pointer）：指针曾经指向合法对象，但该对象已经被销毁或释放
<ul>
<li>产生原因：
<ul>
<li>释放对象后还尝试使用指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;<br>*p = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 悬挂指针：访问已释放内存</span><br></code></pre></td></tr></table></figure>
</li>
<li>函数返回局部变量地址返回给外部使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">return</span> &amp;x;  <span class="hljs-comment">// 出作用域后 x 已经销毁</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>容器元素引用被无效化（如 vector 扩容重新分配内存）</li>
</ul>
</li>
<li>解决：
<ul>
<li>删除对象后立即把指针置空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> p<br>p = <span class="hljs-literal">nullptr</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-gc-语义">(9) GC 语义</h3>
<p>GC 语义（Garbage Collection Semantics，垃圾回收语义）是指一种自动内存管理机制，用于自动跟踪和释放程序中不再使用的内存资源。与手动内存管理（如 C++中的<code>new</code>/<code>delete</code>）不同，具有 GC 语义的编程语言通过垃圾回收器（Garbage Collector，GC）来自动处理内存回收，从而减少内存泄漏和悬挂指针的风险。</p>
<ul>
<li>
<p>GC 语义的核心概念：</p>
<ul>
<li>自动内存管理：垃圾回收器会自动识别那些不再被程序使用的对象，并回收它们占用的内存，而无需程序员显式释放。</li>
<li>可达性分析：GC 通过追踪哪些对象仍然可以通过变量或其他对象访问来判断对象是否“活跃”（仍然被使用）。无法访问的对象被视为不再需要，可以被回收。</li>
<li>内存回收：当 GC 检测到某些对象不再被引用时，它会回收这些对象所占的内存，从而避免内存泄漏。</li>
</ul>
</li>
<li>
<p>常见的 GC 算法：</p>
<ul>
<li><strong>标记-清除算法</strong>：GC 首先标记出所有可达的对象，然后清除未被标记的对象，从而回收它们占用的内存。</li>
<li><strong>引用计数法</strong>：通过维护一个引用计数，每当有一个指针指向对象时，计数增加；当指针不再指向时，计数减少。如果对象的引用计数为零，则可以回收。</li>
<li><strong>标记-压缩算法</strong>：在标记-清除的基础上，还会进行内存压缩以减少内存碎片。</li>
<li><strong>分代回收算法</strong>：将内存划分为“新生代”和“老年代”，新分配的对象在新生代进行回收操作，存活较久的对象则移到老年代。</li>
</ul>
</li>
<li>
<p>GC 语义的优缺点：</p>
<ul>
<li>优点：
<ul>
<li><strong>减少内存管理的复杂性</strong>：程序员无需显式地管理内存的分配和释放，降低了手动释放内存时可能出现的错误。</li>
<li><strong>减少内存泄漏</strong>：通过自动回收内存，降低了内存泄漏的概率。</li>
<li><strong>避免悬挂指针</strong>：当对象被回收时，GC 会确保它不再被访问，避免了悬挂指针（访问已被释放的内存）。</li>
</ul>
</li>
<li>缺点：
<ul>
<li><strong>性能开销</strong>：GC 的运行会消耗 CPU 资源，有时会导致程序性能下降，尤其是在 GC 暂停程序执行进行内存回收的时候（即“GC 停顿”）。</li>
<li><strong>不可控性</strong>：程序员无法完全控制内存回收的时间点，可能导致内存使用高峰时 GC 延迟，增加内存消耗。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常见具有 GC 语义的编程语言：</p>
<ul>
<li>Java</li>
<li>C#：.NET 框架中提供了内置的 GC 机制。</li>
<li>Python：Python 使用<em>引用计数和标记-清除</em>的 GC 方法。</li>
</ul>
</li>
</ul>
<h2 id="3-类型转换static_cast-dynamic_cast-const_cast-reinterpret_cast">3. 类型转换：static_cast / dynamic_cast / const_cast / reinterpret_cast</h2>
<h3 id="1-static_castlttgtexpr">(1) <code>static_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>编译时静态类型转换，主要用于：
<ul>
<li>已知安全的类型转换（如基本数据类型的转换，例如 int 转为 float）。它比 C 风格 (T)value 更加安全，具有更明确的语义，并在编译时进行类型检查。</li>
<li>子类转换为父类（向上转换）。这是因为子类中继承父类所有的成员，转换时只需要切割掉不需要的部分。</li>
<li>void 指针与其他类型指针转换</li>
<li>禁止转换 const 属性</li>
</ul>
</li>
<li>不推荐将父类转为子类（向下转换）。如果子类中有父类中没有的成员，后续使用时将无法正常访问成员。</li>
<li>编译期转换，不做运行时检查，转换成功与否完全靠人负责。</li>
</ul>
<h3 id="2-dynamic_castlttgtexpr">(2) <code>dynamic_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>运行时安全类型转换（<strong>仅适用于有虚函数的多态类型</strong>），用于多态继承体系中 安全地将基类指针/引用转换为派生类类型。向下转换时，会做 RTTI（运行时类型信息）检查。</li>
<li>要求：
<ul>
<li>类型必须是多态类型（即基类有至少一个虚函数）</li>
<li>失败时返回 nullptr（指针）或抛出 std::bad_cast（引用）</li>
</ul>
</li>
<li>特点：
<ul>
<li>安全但慢，有运行时开销</li>
<li>适用于运行时需要判断类型的场景（如事件系统、脚本接口）</li>
</ul>
</li>
</ul>
<h3 id="3-const_castlttgtexpr">(3) <code>const_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>
<p>不涉及类型变换，只是对类型的修饰属性进行调整，用于添加或移除 const/volatile 限定符。</p>
</li>
<li>
<p>用于移除 const 进行非常量操作（<strong>要保证源对象非 const</strong>否则是未定义行为）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确示例：原变量非const（https://mp.weixin.qq.com/s/F8DOLpP6oaZE0V5ay-84jA）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> </span>&#123;    <span class="hljs-comment">// 修改非 const 字符数组是安全的    </span><br>  <span class="hljs-type">char</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(str);   <br>  p[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>  <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;    <br>  <span class="hljs-built_in">modify</span>(str);   <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Modified string: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：Hello    </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-reinterpret_castlttgtexpr">(4) <code>reinterpret_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>底层位级别强制转换（最危险）。</li>
<li>在不同类型的指针/整数间强制转换。
<ul>
<li>正确用法如把<code>int*</code>转为<code>char*</code></li>
<li>错误用法如把<code>int*</code>转为<code>double*</code>(以<code>double*</code>方式访问内存，可能破坏内存布局)</li>
</ul>
</li>
<li>不安全，可能破坏类型系统。避免在普通程序中滥用，通常用于特殊用途（内存布局、设备驱动等）。</li>
</ul>
<h2 id="4-move">4. move</h2>
<h3 id="1-左值右值">(1) 左值右值</h3>
<ul>
<li>
<p>值语义和引用语义</p>
<ul>
<li>值语义通常应用在基础类型（如<code>int</code>、<code>double</code>）和自定义类型（如类和结构体，如果类没有进行特殊处理（如自定义拷贝构造函数和赋值运算符），默认情况下会进行成员逐一拷贝）中。对象在赋值或传递给函数时，会进行深拷贝，新的对象有自己<strong>独立的内存空间</strong>，修改该对象不会影响原始对象。值语义的优势在于它能避免副作用，修改副本不会影响原始对象。但是它也有性能开销，尤其是当对象较大时，频繁的深拷贝可能会影响效率。</li>
<li>引用语义意味着对象只是共享某个值或资源的引用（地址），多个变量指向同一份数据。例如，裸指针，shared_ptr 等。避免大对象拷贝的开销，实现共享状态、多对象同步等。</li>
<li>值语义表示对象是值本身，复制即独立；引用语义表示对象共享数据，修改互相影响。</li>
</ul>
</li>
<li>
<p>左值（Lvalue）</p>
<ul>
<li>有名字，具有地址，存储在内存中</li>
<li>可以出现在赋值号  =  的左侧</li>
<li>可以取地址  &amp;</li>
<li>变量、对象、数组元素都是左值。</li>
</ul>
</li>
<li>
<p>右值（Rvalue）</p>
<ul>
<li>通常没有地址，存储在寄存器或临时内存中</li>
<li>不能出现在赋值号  =  的左侧</li>
<li>不能取地址  &amp;（除非绑定到  const  左值引用）</li>
<li>字面量、表达式计算结果都是右值。</li>
<li>纯右值（PRvalue）：真正的右值，如  10, x + y</li>
<li>亡值（Xvalue）：即将销毁但仍占有资源的对象，如  std::move(obj)</li>
</ul>
</li>
<li>
<p>左值引用 (<code>T&amp;</code>)</p>
<ul>
<li>左值引用绑定到一个可以明确命名、且存在生命周期的对象，即所谓的“左值”。</li>
<li>特点：
<ul>
<li>可以修改所引用的对象。</li>
<li>必须引用一个已存在的变量，且该变量有确定的内存地址。</li>
</ul>
</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; ref = x; <span class="hljs-comment">// 左值引用绑定到变量 x</span><br>ref = <span class="hljs-number">20</span>;     <span class="hljs-comment">// 修改 ref 相当于修改 x</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>右值引用 (<code>T&amp;&amp;</code>)</p>
<ul>
<li>右值引用专门用于绑定到右值，右值通常是没有名字的临时对象，其生命周期短暂。例如，表达式<code>5</code>或返回的临时值就是右值。</li>
<li>特点：
<ul>
<li>右值引用允许对临时对象进行操作，如修改或移动。</li>
<li>主要用于实现，从而提高程序的性能
<ul>
<li><strong>移动语义</strong></li>
<li><strong>避免不必要的拷贝</strong>.<code>std::move</code>用于<strong>将左值强制转换为右值引用</strong>，从而触发移动语义而非拷贝。
<ul>
<li><code>newString = std::move(origString) &lt;-&gt; newString = std::static_cast&lt;std::string&amp;&amp;&gt;(origString)</code></li>
</ul>
</li>
<li><strong>完美转发</strong>. 将函数参数精确地传递给另一个函数，无论它是左值还是右值。通过结合<code>std::forward</code>和模板，能够编写泛型函数，避免不必要的拷贝。</li>
</ul>
</li>
</ul>
</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>&amp;&amp; rref = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 右值引用可以绑定到临时右值</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>判断左/右值引用：std::is_rvalue_reference() / std::is_lvalue_reference()</p>
</li>
</ul>
<h3 id="2-move-原理-移动语义的概念和优势">(2) move 原理 / 移动语义的概念和优势</h3>
<ul>
<li>
<p><code>std::move</code>  的底层原理</p>
<ul>
<li><code>std::move()</code>  只是显式地将左值转换为右值，从而触发移动构造或移动赋值，<code>static_cast&lt;T&amp;&amp;&gt;</code>，不会改变对象的生命周期。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><code>std::move(a)</code>  只是告诉编译器把对象变成右值（“我允许你偷走这个对象的资源”），但不会修改对象本身。实际移动操作是移动构造函数或移动赋值运算符完成的。</li>
<li>用完 std::move 的对象还可以用，但状态不再可靠（比如数据被置空），只能销毁或重新赋值。</li>
</ul>
</li>
<li>
<p><code>std::move</code>的作用</p>
<ul>
<li>将左值转换为右值，以触发移动语义</li>
<li>不会真正“移动”数据，只是改变对象的属性</li>
<li>用于触发移动构造和移动赋值，避免深拷贝，提高性能。</li>
</ul>
</li>
<li>
<p><code>std::move_if_noexcept</code> 是 C++ 标准库中的一种安全优化工具，用于在移动构造可能抛异常的情况下，优先选择拷贝构造。常用于 STL 容器实现中，以保证容器在扩容/搬移元素过程中具有强异常安全性。</p>
</li>
</ul>
<h3 id="3-引用折叠">(3) 引用折叠</h3>
<p><code>std::forward&lt;T&gt;(arg)</code>  通过  <em>引用折叠</em>（Reference Collapsing）和  <em>类型推导</em>  来决定参数是否应该保留右值特性</p>
<p>例如，通过引用折叠，T&amp;&amp; 自动变成合适的左值引用或右值引用。根据引用折叠规则，只有 T 是非引用类型时，T&amp;&amp; 才真正是右值引用。</p>
<ul>
<li>
<p>如果传左值，T = int&amp;，T&amp;&amp; = int&amp; &amp;&amp;，折叠为 int&amp;；</p>
</li>
<li>
<p>如果传右值，T = int，T&amp;&amp; = int&amp;&amp;</p>
</li>
<li>
<p>std::move(x) 总是转成右值引用 强制“偷资源”（移动语义）；<code>std::forward&lt;T&gt;(x)</code> 保留 T 的值类别（左值或右值）实现完美转发。</p>
</li>
</ul>
<h3 id="4-完美转发-使用场景">(4) 完美转发 (使用场景)</h3>
<ul>
<li>
<p>完美转发 是指在泛型模板函数中，以参数的原始形式（左值或右值）传递给目标函数，从而避免不必要的拷贝或移动操作。<br>
如下例，在<code>forwarder</code>函数中，参数<code>T&amp;&amp; arg</code>是一个<strong>万能引用</strong>，可以同时接受左值和右值。如果不用 forward，所有右值都会被当成左值，导致额外拷贝或移动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// for std::forward</span></span><br><br><span class="hljs-comment">// 普通的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Lvalue reference: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Rvalue reference: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 模板函数，使用完美转发</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forwarder</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-comment">// std::forward 保持 arg 的原始值类别</span><br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(arg));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><br>    forwarder(a);        <span class="hljs-comment">// 传递左值</span><br>    forwarder(<span class="hljs-number">10</span>);       <span class="hljs-comment">// 传递右值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>应用场景：完美转发用于模板函数中，需要将函数参数原样传递给另一个函数（如构造函数、重载函数、系统接口等）。</p>
<ul>
<li>
<p>封装底层系统调用或资源对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log_call</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">actual_api</span>(std::forward&lt;Args&gt;(args)...); <span class="hljs-comment">// 避免额外构造/拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<ul>
<li>封装 OpenGL/DirectX 调用</li>
<li>CUDA kernel 参数</li>
<li>网络接口封装器等</li>
</ul>
</li>
<li>
<p>转发到重载函数（如上述 process()的例子）/ std 函数对象</p>
</li>
<li>
<p>传递构造函数参数（继承构造或成员构造）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span>&amp;&amp;);   <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;); <span class="hljs-comment">// 拷贝构造</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(Args&amp;&amp;... args) : <span class="hljs-built_in">Base</span>(std::forward&lt;Args&gt;(args)...) &#123;&#125; <span class="hljs-comment">// 转发给父类构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>意义</p>
<ul>
<li><strong>避免不必要的拷贝和移动</strong>：通过完美转发，我们可以根据参数的实际类型（左值或右值）来决定如何处理，从而避免不必要的对象拷贝或移动操作，提升程序性能。</li>
<li><strong>提升泛型函数的灵活性</strong>：完美转发使得模板函数能够接受各种类型的参数，并且在不影响效率的前提下将参数传递给其他函数。</li>
</ul>
</li>
</ul>
<h3 id="5-拷贝构造函数和移动构造函数的区别">(5) 拷贝构造函数和移动构造函数的区别？</h3>
<ul>
<li>定义方式：拷贝构造 T(const T&amp; other)，移动构造 T(T&amp;&amp; other)</li>
<li>参数类型：拷贝构造接收左值引用（const T&amp;），移动构造接收右值引用（T&amp;&amp;）</li>
<li>调用时机：拷贝构造用已有对象初始化新对象，移动构造用临时对象 / 将亡值初始化新对象</li>
<li>行为：拷贝构造是复制所有资源，而移动构造是资源转移（偷取资源，避免复制）</li>
<li>例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; other) &#123;<br>      data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data); <span class="hljs-comment">// 深拷贝</span><br>  &#125;<br>  <span class="hljs-built_in">A</span>(A&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-comment">// 如果是 const A&amp;&amp;，就不能修改 other 的内容，那就无法移动，只能拷贝</span><br>      data = other.data;       <span class="hljs-comment">// 直接“偷走”指针</span><br>      other.data = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// 置空原始对象</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span>* data;<br>&#125;;<br></code></pre></td></tr></table></figure>
PS: noexcept 是用于声明一个函数不会抛出异常的关键字，用来告诉编译器：“这个函数保证不会抛出异常”。那为什么移动构造函数/移动赋值函数要加 noexcept？因为标准容器（如 std::vector）在扩容时优先使用 noexcept 的移动构造函数。例如当执行 push_back(A)时，会优先用移动构造，如果这里移动构造不是 noexcept，退而求其次才会用拷贝构造。</li>
</ul>
<h2 id="5-哈希冲突">5. 哈希冲突</h2>
<p>STL 中的 <code>std::unordered_map</code>, <code>std::unordered_set</code>, <code>std::unordered_multimap</code>, <code>std::unordered_multiset</code>底层使用哈希表实现的，可能会发生哈希冲突。哈希冲突是哈希表这种数据结构在实际应用中几乎不可避免的现象。</p>
<ul>
<li>
<p><strong>为什么会发生哈希冲突</strong></p>
<ul>
<li><strong>哈希函数的特性</strong>：哈希函数的作用是<strong>将任意长度的键 (key) 映射为一个固定大小的整数（哈希值）</strong>。理想情况下，不同的键会映射到不同的哈希值，但实际上很难找到一个“完美”的哈希函数能够对所有可能的输入都产生唯一的哈希值，尤其是当键的可能取值范围非常大，而哈希值的范围（通常对应内部桶数组的索引）相对有限时。</li>
<li><strong>桶数量有限</strong>：<code>std::unordered_map</code> 内部使用一个数组（称为<strong>桶数组</strong>）来存储元素。这个数组的大小是有限的。哈希值通常会通过取模运算（<code>hash_value % bucket_count</code>）转换成桶数组的索引。不同的哈希值在取模后可能得到相同的索引。</li>
<li><strong>鸽巢原理 (Pigeonhole Principle)</strong>：当要存储的键的数量超过了哈希表内部桶 (bucket) 的数量时，根据鸽巢原理，必然至少有两个键会映射到同一个桶，从而产生冲突。即使键的数量少于桶的数量，由于哈希函数分布的不完美，也可能发生冲突。</li>
</ul>
</li>
<li>
<p><strong>如果发生了哈希冲突，<code>std::unordered_map</code> 如何解决？</strong></p>
</li>
</ul>
<p>目前主流的 C++ 标准库实现（如 libstdc++/GCC, libc++/Clang, MSVC STL）通常采用<strong>拉链法 (Separate Chaining)</strong> 来解决哈希冲突：</p>
<ul>
<li>
<p><strong>拉链法 (Separate Chaining)</strong>：</p>
<ul>
<li><strong>原理</strong>：在拉链法中，哈希表的每个“桶” (bucket) 并<strong>不直接存储单个元素，而是存储一个指向数据结构（通常是链表 (linked list)）的指针或头部</strong>。所有<strong>哈希到同一个桶索引的键值对 (key-value pair) 都会被存储在该桶对应的链表中</strong>。</li>
</ul>
</li>
<li>
<p><strong>负载因子 (Load Factor) 与动态扩容 (Rehashing)</strong>：</p>
<ul>
<li>虽然拉链法可以处理任意数量的冲突，但<strong>如果单个链表过长，查找效率就会从 O(1) 退化到 O(N)（其中 N 是链表长度，最坏情况下是所有元素都在一个链表里）</strong>。</li>
<li>为了维持较好的平均性能，<code>std::unordered_map</code> 会监控其<strong>负载因子 (load factor)</strong>。负载因子定义为：<code>元素数量 / 桶的数量</code>。</li>
<li>当负载因子超过一个阈值（可以通过 <code>max_load_factor()</code> 查询和设置，默认值通常在 1.0 左右）时，<code>std::unordered_map</code> 会自动进行<strong>重新哈希 (rehash)</strong> 或称为<strong>扩容</strong>的操作：
<ul>
<li>创建一个新的、更大的桶数组（通常是原大小的两倍左右或下一个素数）。</li>
<li>遍历旧桶数组中的所有元素。</li>
<li>对于每个元素，<strong>使用新的桶数量重新计算其哈希索引</strong>，并将其插入到新桶数组的对应位置。</li>
</ul>
</li>
<li>重新哈希是一个成本较高的操作（时间复杂度为 O(N)，其中 N 是元素总数），但它能有效缩短链表的平均长度，从而保证后续操作的平均 O(1) 复杂度。这个开销在多次操作中被分摊掉了。</li>
</ul>
</li>
<li>
<p><strong>实践</strong></p>
<ul>
<li><strong>提供好的哈希函数</strong>：对于<strong>自定义类型作为键</strong>，用户需要特化 <code>std::hash&lt;YourType&gt;</code> 模板，并提供一个高质量的哈希函数。一个好的哈希函数应该能将键尽可能均匀地分布到不同的哈希值，以减少冲突。</li>
<li><strong>提供正确的 <code>operator==</code></strong>：<code>std::unordered_map</code> 在处理哈希冲突（即在链表中查找具体键）时，依赖于键类型的 <code>operator==</code> 来判断两个键是否相等。</li>
</ul>
</li>
</ul>
<h2 id="6-如何设计一个内存池">6. 如何设计一个内存池</h2>
<h2 id="7-lamda-函数">7. lamda 函数</h2>
<h3 id="1-lambda-引用陷阱">(1) lambda 引用陷阱</h3>
<p>Lambda 函数捕获了外部作用域中的一个或多个变量的引用，但是当这个 Lambda 函数稍后被调用执行时，这些被引用的原始变量已经超出了其生命周期（即已经被销毁）。此时，Lambda 函数内部持有的引用就变成了悬垂引用，访问这些引用将导致未定义行为 (Undefined Behavior)，通常表现为程序崩溃、数据损坏或不可预测的结果。</p>
<h2 id="8-类">8. 类</h2>
<h3 id="1-空类中默认的成员函数">(1) 空类中默认的成员函数</h3>
<ul>
<li>空类默认有 6 个函数（构造、析构、拷贝/移动构造、拷贝/移动赋值）。
<ul>
<li>默认构造函数：Empty::Empty()，创建空对象</li>
<li>拷贝构造函数：Empty::Empty(const Empty&amp;)，用另一个对象初始化</li>
<li>拷贝赋值运算符：Empty&amp; operator=(const Empty&amp;)，拷贝对象</li>
<li>移动构造函数：Empty::Empty(Empty&amp;&amp;)，从另一个临时对象移动（C++11）</li>
<li>移动赋值运算符：Empty&amp; operator=(Empty&amp;&amp;)，移动赋值（C++11）</li>
<li>析构函数：Empty::~Empty()，对象销毁时调用</li>
</ul>
</li>
<li>C++11 之后，如果显式定义了任意构造/赋值/析构函数，有些默认函数不会再自动生成。例如假如手写了析构函数，那么编译器就不会自动生成移动构造和移动赋值函数（需要自己定义）。</li>
<li>用 = default 显式让编译器生成默认版本，例如：<code>Empty() = default;</code></li>
</ul>
<h3 id="2-类的大小决定因素">(2) 类的大小决定因素</h3>
<p>总览：</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>是否影响类的大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>非静态成员变量</td>
<td>是</td>
<td>实际参与对象内存布局</td>
</tr>
<tr>
<td>内存对齐 / 填充</td>
<td>是</td>
<td>编译器会插入 padding</td>
</tr>
<tr>
<td>虚函数表指针（vptr）</td>
<td>是</td>
<td>有虚函数的类，每个对象需一个 vptr</td>
</tr>
<tr>
<td>静态成员变量</td>
<td>否</td>
<td><strong>属于类，不属于对象</strong>，不计入对象大小</td>
</tr>
<tr>
<td>成员函数（非虚）</td>
<td>否</td>
<td>属于类代码段，不影响对象内存布局</td>
</tr>
<tr>
<td>继承层级本身</td>
<td>取决于是否虚继承</td>
<td>普通继承只把父类数据拷进子类布局，虚继承产生虚基表指针</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>其他的都很直观，这里给出一个虚表指针和一个多继承和虚继承的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// sizeof(C) = 8（64 位系统下），因为多了一个虚函数表指针 vptr</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base1</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base2</span> &#123; <span class="hljs-type">int</span> b; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : Base1, Base2 &#123; <span class="hljs-type">int</span> c; &#125;;<br><span class="hljs-comment">// size = 12（3个int），可能是 16 due to alignment</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">virtual</span> Base1 &#123; <span class="hljs-type">int</span> x; &#125;;<br><span class="hljs-comment">// size = 16+（2个int+虚表指针），因为要存虚基表指针（vbptr）</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>空类的大小是 1 字节（尽管有 6 个默认函数也不是 6，尽管什么成员变量都没有也不是 0），因为 C++ 标准规定<strong>每个对象必须有唯一地址</strong>，哪怕没有成员也必须至少占 1 字节，<strong>避免多个对象占用同一地址</strong>。</p>
</li>
<li>
<p><code>sizeof()</code>查看类的大小，或者用 <code>alignof()</code> 查看对齐情况，使用 <code>std::is_empty&lt;T&gt;</code> 检查是否为空类。</p>
</li>
</ul>
<h2 id="9-c内存对齐机制">9. c++内存对齐机制</h2>
<ul>
<li>内存对齐是指 编译器在给结构体或变量分配内存时，按照特定规则将变量放在特定地址上的过程，通常这个地址是变量大小或平台对齐要求的整数倍。</li>
<li>例如，下面结构体分配内存时，不是紧凑排布成 5 字节，而是 a 占用第 0 字节，b 会被放到第 4 字节（从第 4 字节开始）对齐地址（地址 % 4 == 0），所以总大小是 8 字节。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-type">char</span> a;   <span class="hljs-comment">// 1 byte</span><br>  <span class="hljs-type">int</span> b;    <span class="hljs-comment">// 4 bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>为什么要内存对齐？
<ul>
<li>硬件访问效率：大部分硬件架构（x86, ARM）要求变量必须对齐访问，否则性能下降甚至抛异常</li>
<li>避免硬件异常：某些 CPU 不支持非对齐内存访问，比如 <code>int*</code> 不能从奇地址读取</li>
<li>提高缓存效率：对齐能提高 cache line 命中率</li>
<li>满足 ABI 要求：编译器/链接器/系统 ABI 规定数据结构布局方式，必须对齐</li>
</ul>
</li>
<li>编译器如何处理对齐？
<ul>
<li>编译器会自动插入 padding 字节（填充），确保每个成员的地址满足它的对齐需求</li>
</ul>
</li>
<li>如何查看结构体对齐信息？
<ul>
<li>使用 <strong>sizeof()</strong> 观察结构体大小。如上例中 sizeof(A)的结果是 8。</li>
</ul>
</li>
<li>C++11 起可用 alignas 强制让 S 的实例按 16 字节对齐（常用于 SIMD 优化、AVX）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">16</span>) S &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="10-struct-大小">10. struct 大小</h2>
<h3 id="1-定义一个-struct有-int-xchar-c-两个成员这个结构体的大小">(1) 定义一个 struct，有 int x，char c 两个成员，这个结构体的大小？</h3>
<ul>
<li>int x 占 4 字节，char c 占 1 字节</li>
<li>但由于 对齐要求（int 对齐为 4 字节，整个结构体也需要是最大成员类型的对齐倍数）， 编译器会 在末尾补 3 字节填充（padding）</li>
</ul>
<h3 id="2-如果增加一个-static-int-这个结构体大小怎么变化">(2) 如果增加一个 static int 这个结构体大小怎么变化？</h3>
<ul>
<li>static 成员不属于对象本身，属于类本身，所以它不参与实例的内存布局，编译器不会为 static 成员在对象中分配空间。</li>
<li>总大小仍是：8 字节</li>
</ul>
<h3 id="3-如果在结构体里定义一个虚函数结构体大小怎么变化">(3) 如果在结构体里定义一个虚函数，结构体大小怎么变化？</h3>
<ul>
<li>添加虚函数后，结构体拥有一个隐藏的虚函数表指针（vptr）</li>
<li>vptr 是一个指针，通常在 64 位系统上为 8 字节，通常 vptr 占位于对象的开头（但不强制）</li>
<li>对齐仍然会生效，总大小为：8 + 4 + 1 + 3 = 16 字节</li>
</ul>
<h2 id="11-c的动态链接静态链接">11. c++的动态链接静态链接</h2>
<ul>
<li>C++ 程序编译过程分为三步：预处理、编译、链接</li>
<li>链接的目的：将多个 目标文件 (.o) 和 库文件 合成最终的可执行文件</li>
<li>链接分为两种：静态链接 和 动态链接</li>
</ul>
<h3 id="1-静态库static-library">(1) 静态库（Static Library）</h3>
<ul>
<li>编译时直接把 .lib(windows)/.a(linux) 库的代码（对象文件内容）链接进目标程序</li>
<li>最终生成的 .exe 或 .out 文件中包含所有库代码，不再依赖外部 .lib / .a</li>
<li>优点：
<ul>
<li>程序部署方便（无额外依赖）</li>
<li>启动时加载快</li>
</ul>
</li>
<li>缺点：
<ul>
<li>可执行文件体积大</li>
<li>多个程序使用同一库会重复占用空间</li>
<li>更新库需重新编译所有依赖它的程序</li>
</ul>
</li>
</ul>
<h3 id="2-动态库shared-dynamic-library">(2) 动态库（Shared / Dynamic Library）</h3>
<ul>
<li>程序运行时再加载 .dll / .so 文件</li>
<li>二进制可执行文件中只保留符号引用，不包含实际实现</li>
<li>优点：
<ul>
<li>可执行文件体积小</li>
<li>多个程序共享同一份库文件</li>
<li>可热更新（替换库不需重新编译）</li>
</ul>
</li>
<li>缺点：
<ul>
<li>程序运行时必须找到正确的库（需要安装配置）</li>
<li>加载稍慢，部署略复杂</li>
</ul>
</li>
</ul>
<h3 id="3-cmake">(3) cmake</h3>
<p>笼统地说，cmake 通过 add_library 创建库（static/shared），target_link_libraries() 链接。</p>
<h2 id="12-c的运行内存分区">12. c++的运行内存分区</h2>
<ul>
<li>
<p>栈：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的<strong>局部变量、函数参数、返回地址</strong>等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。</p>
</li>
<li>
<p>堆：动态申请的内存空间，就是由 malloc / new 分配的内存块，由 delete / free 手动控制释放，可以在程序运行周期内随时进行申请和释放（生命周期由开发者管理），如果进程结束后还没有释放，操作系统会自动回收。</p>
</li>
<li>
<p>全局区（Global Area）/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放（生命周期：从程序开始到结束）。</p>
<ul>
<li>已初始化的全局/静态变量（Data 段）</li>
<li>未初始化的全局/静态变量（BSS 段）</li>
</ul>
</li>
<li>
<p>常量存储区：存放的是<strong>常量</strong>（const），不允许修改，程序运行结束自动释放。</p>
<ul>
<li>全局常量、字符串常量（.rodata 常量区）（虚函数表存储在这里）</li>
</ul>
</li>
<li>
<p>代码区：存放程序的机器指令，<strong>只读</strong>不允许修改，但可以执行。编译后的二进制文件存放在这里。</p>
</li>
</ul>
<h3 id="1-如何在栈上分配一定的内存会有什么问题">(1) 如何在栈上分配一定的内存？会有什么问题？</h3>
<ul>
<li>直接使用局部变量/数组。</li>
<li>问题：
<ul>
<li>栈空间大小有限（一般几百 KB 到几 MB），分配太大可能引发栈溢出（stack overflow）。例如递归中误分配过多栈内存会 crash。</li>
<li>作用域结束就被释放，不能跨函数或返回出去使用局部数组（指针悬空）。</li>
</ul>
</li>
<li>解决：
<ul>
<li>使用<code>std::vector</code>：自动管理内存（默认分配在堆上）</li>
<li>使用<code>std::array&lt;T, N&gt;</code>：固定长度数组，标准安全的栈上分配</li>
</ul>
</li>
</ul>
<h3 id="2-常见内存泄漏的情况">(2) 常见内存泄漏的情况</h3>
<p>内存泄漏：程序中<em>申请了内存但没有释放</em>，导致内存长期占用，最终消耗完系统资源。</p>
<ul>
<li>
<p>使用 new / malloc 后没有调用 delete / free （堆内存泄露）</p>
</li>
<li>
<p>类的析构函数中没有释放</p>
</li>
<li>
<p>函数内多路径提前 return / 抛出异常，因此没有跑后面清理资源的部分（使用智能指针解决）</p>
</li>
<li>
<p>指针被重新赋值，导致原内存无法访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">50</span>];     <span class="hljs-comment">// 原来的 100 个 int 泄漏</span><br><span class="hljs-keyword">delete</span>[] p;          <span class="hljs-comment">// 只释放了新分配的 50 个</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>容器中的裸指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>*&gt; vec;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>));<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">// 容器析构不会自动释放指针元素，泄漏</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>数组泄漏原因，使用  new[]  分配数组但未使用  delete[]  释放</p>
</li>
<li>
<p>循环引用，shared_ptr 之间相互引用，引用计数无法归零，无法释放（解决：将其中一方改成 std::weak_ptr）</p>
</li>
<li>
<p>未释放系统资源（文件句柄、网络连接、线程）导致资源泄漏，如 fopen() / fclose() 未配对（解决：使用 RAII 封装资源，例如  std::ifstream  自动管理文件资源）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(threadFunc)</span></span>;<br>    <span class="hljs-comment">// t.join(); // 若不调用 join 或 detach，会导致线程泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>多线程中资源释放时机混乱 一个线程 new，另一个线程未 delete</p>
</li>
</ul>
<h3 id="3-如何检查和处理内存泄露的问题">(3) 如何检查和处理内存泄露的问题？</h3>
<ul>
<li>
<p>使用智能指针</p>
</li>
<li>
<p>Windows：Visual Studio 自带检测</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRTDBG_MAP_ALLOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    _CrtDumpMemoryLeaks();  <span class="hljs-comment">// 程序结束时输出泄漏信息</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Linux：Valgrind</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">valgrind --leak-check=full ./your_program<br></code></pre></td></tr></table></figure>
<p>输出所有内存分配和未释放位置</p>
</li>
</ul>
<h2 id="13-如何构造一个只能在堆上创建对象的类如何构造一个只能在栈上创建对象的类">13. 如何构造一个只能在堆上创建对象的类？如何构造一个只能在栈上创建对象的类？</h2>
<ul>
<li>
<p>若要构造只能在堆上创建的类，应将构造函数设为私有并通过静态工厂函数（工厂方法是一种创建对象的设计模式，<br>
它将对象的创建过程封装在一个静态函数中，而不是让用户直接 new 或构造对象）创建对象；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOnly</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 构造函数私有，外部不能直接 new 或定义对象</span><br>    <span class="hljs-built_in">HeapOnly</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">HeapOnly</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供静态工厂方法，在堆上创建对象</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> HeapOnly* <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapOnly</span>();<br>        <span class="hljs-comment">// return std::shared_ptr&lt;MyClass&gt;(new MyClass()); // 或者返回智能指针从而只能通过智能指针创建</span><br>        <span class="hljs-comment">// std::shared_ptr&lt;T&gt;(new T(...)) 是在类内部调用构造函数，有权限访问私有构造；</span><br>        <span class="hljs-comment">// 而 std::make_shared&lt;T&gt;() 是标准库函数模板，在类外部调用构造函数，无法访问私有成员</span><br>    &#125;<br><br>    <span class="hljs-comment">// 提供释放接口（防止 delete 出错）</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(HeapOnly* ptr)</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> ptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>若要构造只能在栈上创建的类，应将 operator new 删除或私有，防止通过 new 分配内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOnly</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StackOnly</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">StackOnly</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span> </span>= <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOnly</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StackOnly</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">StackOnly</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="14-c异常处理机制try-catch的工作原理">14. C++异常处理机制（try-catch）的工作原理</h2>
<ul>
<li>异常处理的基本语法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>    <span class="hljs-built_in">risky_function</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>    <span class="hljs-comment">// 捕获并处理异常</span><br>    std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>工作原理概览
<ul>
<li>编译阶段：
<ul>
<li>编译器记录每个 try 块关联的 catch 块及其捕获类型。</li>
<li>同时会在函数中插入清理代码表（unwind table），用于异常时调用析构函数。</li>
<li>所有能够抛出异常的函数会被标记（除非是 noexcept）。</li>
</ul>
</li>
<li>运行阶段（出现异常时）：<br>
当 throw 被执行时：
<ul>
<li>程序开始<strong>栈展开</strong>（stack unwinding）：
<ul>
<li>从当前函数向上传递异常
<ul>
<li>throw 会创建一个临时异常对象（可能复制或移动）</li>
<li>异常类型匹配靠运行时类型识别（RTTI）</li>
<li>catch 块通过引用或值接受该对象</li>
</ul>
</li>
<li>查找匹配的 catch 语句</li>
</ul>
</li>
<li>展开过程中：
<ul>
<li><strong>自动调用已构造的局部对象的析构函数</strong>（避免内存泄漏）</li>
<li>跳过中间代码逻辑</li>
</ul>
</li>
<li>找到合适的 catch 后：
<ul>
<li>跳转执行 catch 块中的代码</li>
</ul>
</li>
<li>若未找到任何 catch 块：
<ul>
<li>调用 std::terminate() 结束程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>开销
<ul>
<li>常运行时几乎无性能损失</li>
<li>只有发生异常时才会触发异常处理流程（包括栈展开、类型匹配等）</li>
<li>所以异常是为处理罕见错误路径而设计，不应用于常规流程控制</li>
</ul>
</li>
</ul>
<h2 id="15-自动类型推断auto-decltype">15. 自动类型推断：auto / decltype</h2>
<h3 id="1-auto">(1) auto</h3>
<ul>
<li>
<p>编译器在编译期根据变量的初始值自动确定其数据类型。</p>
</li>
<li>
<p>只能用于变量声明、函数返回类型（C++14 起）</p>
<ul>
<li>
<p>最常用：遍历容器、for 循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;   <br>  std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : vec) &#123;   <br>  std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>不支持无初始化的变量声明</p>
</li>
<li>
<p>会移除顶层 const 和引用</p>
<ul>
<li>
<p>但可以使用<code>auto&amp;</code>推导引用，使用<code>const auto</code>保留常量性。值得注意的是，<code>auto</code>推导的是值类型，而 <strong><code>auto&amp;</code>推导的是引用类型</strong>。引用的目的是提供对原始变量的直接访问，因此它需要保留原始变量的所有类型信息。因此，引用的类型必须与原始变量的类型完全匹配，包括 const 修饰符。这也就是说如果原始变量是 const 的，auto&amp; 推导出的类型会是 const T&amp;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span>&amp; y = a;   <span class="hljs-comment">// y: const int&amp;</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span>&amp; z = b;   <span class="hljs-comment">// z: int&amp;</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">auto</span> c = x;       <span class="hljs-comment">// c 的类型是 int，不是 const int</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> c = x; <span class="hljs-comment">// c 的类型是 const int</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>auto&amp;&amp;</code>万能引用：会根据初始化表达式的值类别，折叠成适当的引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span>&amp;&amp; a = x;       <span class="hljs-comment">// int&amp; 初始值为左值，推断为 T&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; b = <span class="hljs-number">5</span>;       <span class="hljs-comment">// int&amp;&amp; 初始值为右值，推断为 T&amp;&amp;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-decltype">(2) decltype</h3>
<ul>
<li>
<p><code>decltype(expr)</code> 返回 表达式 <code>expr</code> 的类型，不求值、不构造、不执行</p>
</li>
<li>
<p>可用于函数返回类型推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 a, T2 b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span> </span>&#123;   <br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>可获取表达式的完整类型（包括 const、引用等）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-keyword">decltype</span>(b) x = a;     <span class="hljs-comment">// x 是 int&amp;</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-keyword">decltype</span>(b) c = <span class="hljs-number">3</span>; <span class="hljs-comment">// c 是 const int &amp; (可以去 https://cppinsights.io/ 验证)</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>decltype(auto)</code>：<code>decltype(auto)</code> 是 <code>decltype(expr)</code> 的语法糖，但只能用于变量和函数返回值的类型自动推导。<br>
这样就可以“像 auto 一样写代码”，但保留 decltype 的完整类型语义（包括引用和 const）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getRef</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRef</span>(); <span class="hljs-comment">// 返回 int（拷贝）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRef</span>(); <span class="hljs-comment">// 返回 int&amp;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里用 auto 推断返回类型会丢失引用，用 decltype(auto)，则无需显式写出 decltype(getRef())，还能保留其完整类型（引用）。</p>
</li>
</ul>
<h3 id="3-为什么不鼓励使用-auto">(3) 为什么不鼓励使用 auto？</h3>
<ul>
<li>
<p>可读性下降</p>
</li>
<li>
<p>容易忽略引用和 const 修饰符：auto 会移除顶层 const 和引用修饰，如果忘记加 auto&amp; 或 const auto&amp;，可能导致拷贝开销或逻辑错误。</p>
</li>
<li>
<p>隐式类型错误：某些情况下 auto 推导出的类型并不是理想的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> x = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">auto</span> i = x / <span class="hljs-number">2</span>;  <span class="hljs-comment">// i 是 double，但可能本来想截断取整得到int</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>降低 API 明确性（特别是公共接口）</p>
</li>
</ul>
<h2 id="16-c-11-新特性">16. c++ 11 新特性</h2>
<h2 id="17-是否了解函数的调用约定">17. 是否了解函数的调用约定？</h2>
<ul>
<li>调用函数与被调用函数之间堆栈的平衡是如何实现的？</li>
<li>函数调用的堆栈平衡具体如何实现？</li>
<li>栈帧是调用函数生成还是被调用函数生成？</li>
</ul>
<h2 id="18-new-和-malloc-的区别-delete-和-free-有什么区别">18. new 和 malloc 的区别 / delete 和 free 有什么区别</h2>
<ul>
<li>
<p>new 和 malloc 的区别</p>
<ul>
<li>new 在申请内存的同时，会调用对象的构造函数，对象会进行初始化，malloc 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。</li>
<li>new 是 c++ 中的一个操作符，而 malloc 是 C 中的一个函数。</li>
<li>new 作为一个运算符可以进行重载，而 malloc 作为一个函数不支持重载。</li>
<li>new 内存分配成功，返回该对象类型的指针，分配失败，抛出 bad_alloc 异常；而 malloc 成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。</li>
<li>new 的空间大小由编译器会自动计算，而 malloc 则需要指定空间大小。</li>
</ul>
</li>
<li>
<p>delete 和 free 有什么区别</p>
<ul>
<li>delete 是 C++ 中的一个操作符，可以进行重载；而 free 是 C 中的一个函数，不能进行重载。</li>
<li>free 只会释放指向的内存，不会执行对象的析构函数；delete 则可以执行对象的析构函数。</li>
</ul>
</li>
</ul>
<h2 id="19-lambda-函数">19. Lambda 函数</h2>
<h2 id="20-指针和引用的区别">20. 指针和引用的区别</h2>
<ul>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是一个东西，只不过是原变量的一个别名而已。</li>
<li>可以有 const 指针，但是没有 const 引用；</li>
<li>指针可以有多级，但是引用只能是一级；</li>
<li>指针的值可以为空，但是引用的值不能为 NULL，并且引用在定义的时候必须初始化；</li>
<li>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变。</li>
</ul>
<h2 id="21-指针常量-和-常量指针">21. 指针常量 和 常量指针</h2>
<ul>
<li>
<p>记忆方法</p>
<ul>
<li>指针常量：指针本身是一个常量。<code>const</code> <strong>靠近指针名</strong>，说明指针本身是常量，地址不能变。</li>
<li>常量指针：常量的指针。<code>const</code> <strong>靠近数据类型</strong>，说明指针指向的内容是常量，内容不能变。</li>
</ul>
</li>
<li>
<p>指针常量</p>
<ul>
<li>定义：指针本身是一个常量，它的地址不能改变，但可以改变它指向的内容。</li>
<li>语法：<code>数据类型 *const 指针名;</code></li>
<li><code>const</code> 关键字修饰的是指针本身。</li>
<li>特点：
<ul>
<li>指针的地址在初始化后不能更改。</li>
<li>指针指向的内容可以修改。</li>
</ul>
</li>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> ptr = &amp;a;  <span class="hljs-comment">// ptr 是一个指针常量，指向 a</span><br>*ptr = <span class="hljs-number">30</span>;            <span class="hljs-comment">// 允许修改 a 的值为 30</span><br><span class="hljs-comment">// ptr = &amp;b;          // 错误：不能改变 ptr 的地址</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>常量指针</p>
<ul>
<li>定义：指针指向的内容是常量，不能修改，但指针本身的地址可以改变。</li>
<li>语法：<code>const 数据类型 *指针名;</code> 或 <code>数据类型 const *指针名;</code></li>
<li><code>const</code> 关键字修饰的是指针指向的内容。</li>
<li>特点：
<ul>
<li>指针的地址可以更改。</li>
<li>指针指向的内容不能修改。</li>
</ul>
</li>
<li>例子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr = &amp;a;  <span class="hljs-comment">// ptr 是一个常量指针，指向 a</span><br><span class="hljs-comment">// *ptr = 30;         // 错误：不能修改 a 的值</span><br>ptr = &amp;b;             <span class="hljs-comment">// 允许：可以改变 ptr 的地址，指向 b</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>应用场景</p>
<ul>
<li>指针常量：当需要一个固定指向某个地址的指针时，比如硬件寄存器的地址。</li>
<li>常量指针：当需要保护数据不被意外修改时，比如传递给函数的参数。</li>
</ul>
</li>
</ul>
<h2 id="22-重定义问题extern-inline-static">22. 重定义问题（extern / inline / static）</h2>
<p>函数重定义的背景：如果头文件中直接定义函数，且被多个.cpp 文件包含，会导致链接时重定义错误（multiple definition）。</p>
<h3 id="1-extern">(1) extern</h3>
<ul>
<li>
<p>用于声明一个变量或函数是在其他文件中定义的，告知编译器“这个符号的定义在别处”，当前只作声明，不要在当前文件重新分配内存或生成代码。</p>
<ul>
<li>用于跨源文件共享变量/函数</li>
<li>避免重复定义（multiple definition）错误</li>
<li>控制链接属性（external linkage）</li>
</ul>
</li>
<li>
<p>示例 1：假设有两个 cpp 文件。<br>
config.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> globalValue = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure>
<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalValue; <span class="hljs-comment">// 在 main.cpp 中用 extern 声明它，避免重复定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, globalValue); <span class="hljs-comment">// 输出 42</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果在 .h 中定义 const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> CONST_VALUE = <span class="hljs-number">5</span>; <span class="hljs-comment">// 每个翻译单元都会生成一个副本</span><br><span class="hljs-comment">// 改成这样：</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> CONST_VALUE;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-extern-c">(2) extern “C”</h3>
<ul>
<li><code>extern &quot;C&quot;</code>是 cpp 提供的关键字，用于告诉编译器按照 C 语言方式<strong>编译和链接</strong>函数或变量，已解决 C++ <strong>名称修饰</strong>（name mangling）带来的兼容性问题。</li>
<li>为什么需要 extern “C”?
<ul>
<li>C++ <strong>支持函数重载</strong>，所以编译器会在<strong>编译时修改函数名</strong>，加入参数类型信息；C 语言不支持重载，其函数名在编译后不会被修饰。如果 C++ 直接调用 C 语言函数（没有  extern “C”），链接时找不到匹配的名称，会报  undefined reference  错误。</li>
<li>PS：VS2022 可以打开 Tools-Command line-Developer command prompt，cd 进入.obj（.o）文件所在的文件夹来分析编译的结果，例如查看符号表。</li>
</ul>
</li>
<li>使用（代码实例见：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/oJDsfqiVLdWTLtcnHKL_tQ%EF%BC%89%EF%BC%9A">https://mp.weixin.qq.com/s/oJDsfqiVLdWTLtcnHKL_tQ）：</a>
<ul>
<li>C++调用 C 函数</li>
<li>C 语言调用 C++ 代码</li>
<li>适用于：（多个）函数、变量、整个头文件。</li>
<li>不适用于：C++ 类（C 语言不支持类）、函数重载（C 语言不支持重载）</li>
<li>C++ 调用 C 库、封装 C 接口给其他语言</li>
<li>extern “C”  只能用于全局作用域，不能嵌套到局部变量或函数内部。</li>
<li>用  #ifdef __cplusplus （#endif）确保头文件可在 C 和 C++ 两端兼容。</li>
<li>适用于 函数和变量，但不能用于 类和重载函数</li>
</ul>
</li>
</ul>
<h3 id="3-inline-和-extern">(3) inline 和 extern</h3>
<p>由前述可知，extern 修饰某个函数/变量，可以表明该函数/变量的定义在其他文件中，从而避免重复定义。<br>
假设有 test.h, test.cpp, and main.cpp 三个文件。test.h 中定义（实现）一个 func1，test.cpp 和 main.cpp 中都 include 了 test.h，并使用 func1。此时编译 main.cpp 会出现错误。</p>
<p>由前可知，此错误可以用 extern 或 inline 解决，在 test.cpp 中用 extern 声明外部函数 func1。</p>
<p>而新特性下的 inline 已经不在表明是否内联，是否内联现在完全由编译器决定。新特性下的 inline 允许函数在多个文件中定义，编译时合并为一份，避免多重定义错误。每个文件中出现的定义都被认为是“同一个函数的多次定义”，链接器不会报错。这样用法主要用于函数，也可用于变量（C++17 起）。在上述例子中，可以在头文件里用 inline 修饰 func1。值得注意的是，不同文件里的多个定义应该完全一样，因为如果定义不同不同编译器可能随机使用某个定义。</p>
<p>extern 和 inline 的对比：</p>
<ul>
<li>编译器行为：extern 是声明符号，定义在别处；inline 允许多次定义（每个 翻译单元 TU 都有）</li>
<li>是否生成多次拷贝：extern 只在定义处生成；inline 则每个 .cpp 中可能各自展开。注意如果在头文件中使用 inline 定义了一个函数，并在多个 .cpp 文件中包含了这个头文件，不会生成多个冲突的拷贝，也不会导致链接错误。因为编译器+链接器会识别 inline 函数的“唯一定义”，只保留一份。编译器在多个 .cpp 中确实会生成对应的函数体（可能优化为内联），但链接器会做合并处理：只保留一份最终定义。如果启用 LTO（链接时优化），可能根本不生成函数体，而直接内联展开。“生成函数体”是指编译器在每个 .cpp（翻译单元）中把 inline 函数编译为机器码（或中间表示），为后续链接或内联做准备。但“多个拷贝”是指链接时在最终可执行文件或静态库中，保留多个独立的全局符号定义，从而导致重复定义错误或浪费空间。</li>
<li>使用场景：extern 用于声明全局变量（跨多个文件共享一个全局变量）/ 外部接口；inline 定义 header-only 工具函数 / 模板函数</li>
</ul>
<p>PS: 用 static 修饰函数也可以解决重复定义问题，但其原理和使用场景与 extern 和 inline 完全不同。用 static 修饰函数的本质是表明该函数具有内部链接，即该函数<strong>只在当前翻译单元（.cpp 文件）中可见</strong>，不会导出到外部。即使多个 .cpp 文件中有相同名字的 static 函数，它们在编译期也不会冲突，因为它们在链接器眼中是不同的、局部的符号。但是不推荐在头文件中用 static 修饰函数，因为这样会在每个.cpp 都生成一个副本。因此，static 函数的典型用途是：定义仅供当前 .cpp 文件内部使用的辅助函数；避免函数被导出给其他模块使用（隐藏实现细节）；提升封装性、限制可见性。总结就是 static 修饰函数可以解决重定义，但无法共享函数定义；inline  则告诉链接器多个翻译单元中出现相同函数定义是可以的，链接时只保留一个函数定义。</p>
<h3 id="4-内联函数-和-宏define的区别">(4) 内联函数 和 宏（#define）的区别</h3>
<p>内联函数是语义完整、类型安全的函数，由编译器在编译阶段决定是否内联；而宏是<strong>预处理器文本替换</strong>，不进行类型检查，容易引发副作用和调试困难。除非必要，现代 C++ 推荐使用 inline 函数代替函数类宏。</p>
<h2 id="23-vector">23. vector</h2>
<h3 id="1-vector-底层实现">(1) vector 底层实现</h3>
<p>基类<code>_Vector_base</code><br>
内部有一个 struct，其中有三个重要的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_impl</span><br>: <span class="hljs-keyword">public</span> _Tp_alloc_type<br>&#123;<br>  pointer _M_start; <span class="hljs-comment">// 指向数据起始位置</span><br>  pointer _M_finish; <span class="hljs-comment">// 指向当前元素末尾（size）</span><br>  pointer _M_end_of_storage; <span class="hljs-comment">// 指向当前可用容量的末尾（capacity）</span><br><span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过 <code>_M_start</code> 到 <code>_M_finish</code> 管理已有元素，<code>_M_end_of_storage - _M_start</code> 就是容量。</p>
<ul>
<li>
<p>内存管理（动态数组）</p>
<ul>
<li>所有元素存储在<strong>连续的堆内存块</strong>中</li>
<li>初始容量通常为 0，插入时自动扩容</li>
</ul>
</li>
<li>
<p>插入元素</p>
<ul>
<li>插入在最后的位置 (<code>push_back()</code>/<code>emplace_back()</code>)：
<ul>
<li>均摊 O(1)</li>
<li>不是严格保证 O(1)，因为如果发生扩容，要分配一块新的更大的内存（通常是当前容量的两倍），将原内存中的元素复制或移动到新的内存中，然后释放原内存。扩容操作的时间复杂度是 O(n)（其中 n 是当前元素的数量），因为需要复制或移动所有现有元素。</li>
</ul>
</li>
<li>插入不是最后的位置 (<code>insert(pos, x)</code>)：
<ul>
<li>把待插入位置之后的元素全部向后平移一位，再插入元素</li>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除元素</p>
<ul>
<li>删除最后位置的元素 (<code>pop_back()</code>)：
<ul>
<li><code>_M_finish</code> 往前移动一位</li>
<li>调用析构删除元素，不释放现有已经申请的内存</li>
<li>O(1)</li>
</ul>
</li>
<li>删除不是最后 (<code>erase(pos)</code>)：
<ul>
<li>待删除后面所有元素均向前平移一位</li>
<li>删除元素，不释放现有已经申请的内存</li>
<li>O(n)</li>
</ul>
</li>
<li>删除所有 (<code>clear()</code>):
<ul>
<li>对所有元素调用析构，但不释放内存</li>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>读取元素</p>
<ul>
<li>操作符<code>[]</code></li>
<li>.at({index}) (比<code>[]</code>多了一个检查界的越界动作，如果越界了直接返回一个无效的位置)<br>
以上两种都是返回具体元素的引用，可以帮助修改元素</li>
</ul>
</li>
<li>
<p>修改元素</p>
<ul>
<li>vector 不支持直接修改某个位置的元素，只能通过读取元素获取引用再修改，或者删除之后再加入（效率低）</li>
</ul>
</li>
</ul>
<h3 id="2-vector-扩容机制">(2) vector 扩容机制</h3>
<ul>
<li>当使用 push_back/emplace_back 添加元素时，如果容量 capacity() 已满，就会触发自动扩容，将容量扩展为当前容量的 1.5 到 2 倍（具体实现依编译器而异）。</li>
<li>扩容会：
<ul>
<li>分配新内存（当前内存的 1.5 到 2 倍）(<code>allocator&lt;T&gt;</code>（默认是 std::allocator）)</li>
<li>拷贝（或移动）旧元素到新内存</li>
<li>释放旧内存</li>
</ul>
</li>
<li>优化：如果已知需要存储大量数据，可使用<code>vec.reserve(n)</code>预分配 n 个元素的空间，避免多次扩容。</li>
<li>在扩容过程中，由于分配了新的内存空间，原内存中的元素被复制或移动到新的位置。这意味着<strong>原来指向 std::vector 中元素的迭代器、指针和引用都会失效，因为它们指向的是旧的内存地址</strong>。例如，假设我们有一个 std::vector，并获取了一个指向其中某个元素的迭代器。然后我们不断向 std::vector 添加元素，导致其扩容。扩容后，原来的迭代器就不再有效，因为它所指向的内存地址已经被释放或覆盖。</li>
</ul>
<h3 id="3-emplace_back-vs-push_back-区别与性能">(3) emplace_back() vs push_back() 区别与性能</h3>
<ul>
<li>push_back() 接收对象实例，也就是说先构造临时对象，再拷贝/移动进 vector</li>
<li>emplace_back() 接收构造参数，直接在 vector 的尾部<strong>就地构造</strong>对象</li>
<li>emplace_back(args…)  原地构造对象，<strong>避免了不必要的拷贝/移动</strong>，相比  push_back(a)  更高效，特别适用于存储复杂对象。</li>
<li>对于简单数据类型，push_back()和 emplace_back()差别不大；对于复杂对象（如 string、自定义类等），优先使用  emplace_back()  以提升性能。</li>
</ul>
<h3 id="4-vector-里加入-10-万数据游戏中有对象的指针指向这些数据这可能有什么问题">(4) vector 里加入 10 万数据，游戏中有对象的指针指向这些数据，这可能有什么问题？</h3>
<p>vector 发生扩容时会分配更大的内存，将原内存数据拷贝过来，然后释放之前的内存，如果有指针指向此前的地址，释放之后，指针将不能正常访问到此前的数据。</p>
<h3 id="5-clear-后-capacity-是否改变如何释放多余内存">(5) clear() 后 capacity() 是否改变？如何释放多余内存？</h3>
<ul>
<li><code>vec.clear()</code> 只销毁所有元素（调用析构），即 size() 变为 0，但不会释放容量，即 capacity() 不变</li>
<li>如何释放多余内存：
<ul>
<li><strong>shrink_to_fit()</strong> 释放多余内存（C++11 起）。但注意<strong>不是强制释放</strong>，只是建议行为，不同 STL 实现可能不生效（如某些 libc++ 实现中）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">capacity</span>() &gt; vec.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>) &#123;   <br>  vec.<span class="hljs-built_in">shrink_to_fit</span>(); <span class="hljs-comment">// 仅在容量远大于实际使用时调用</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>交换清空法（最稳妥）:创建一个临时空 vector，与 v 交换，原内存立即释放，100% 生效，用来释放大容量 vector 内存 （临时 vector 在语句结束后立即被销毁，释放了内存）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">swap</span>(v);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="6-vector-如何快速删除内部某个元素-要求-o1时间复杂度">(6) vector 如何快速删除内部某个元素。（要求 O(1)时间复杂度）</h3>
<p>将要删除的对象和尾部对象 swap，然后直接 pop_back 即可。</p>
<h2 id="24-多线程锁">24. 多线程/锁</h2>
<p>见 <a href="/2024/12/30/multi-threads/"> CPP 多线程通信/锁/死锁 相关</a></p>
<h2 id="25-从-cpp-源代码到-exe-经过了哪些过程">25. 从 cpp 源代码到 exe 经过了哪些过程？</h2>
<ul>
<li>预处理：处理所有以 # 开头的指令。包括：
<ul>
<li>展开 #include</li>
<li>替换 #define 宏</li>
<li>判断 #ifdef/#endif</li>
<li>删除注释等</li>
</ul>
</li>
<li>编译：将预处理后的源码编译成 汇编代码
<ul>
<li>语法检查</li>
<li>变量和函数作用域检查</li>
<li>类型检查</li>
<li>优化（如 inline 展开、常量折叠）</li>
<li>生成 .s 汇编文件（人类可读）</li>
</ul>
</li>
<li>汇编（Assembly）：汇编器把 .s 汇编代码变成 机器码（二进制目标文件 .obj 或 .o）
<ul>
<li>一个 .cpp 文件生成一个 .obj</li>
<li>每个 .obj 文件是单独编译的</li>
<li>含有未解析的符号（函数、全局变量等）</li>
</ul>
</li>
<li>链接：链接器将多个 .obj 文件（以及库文件 .lib/.a）组合为一个 .exe/.out 可执行程序
<ul>
<li>解析符号引用（函数调用、变量地址等）</li>
<li>分配内存地址</li>
<li>合并多个代码段（data/text/bss）</li>
<li>加入启动代码（如 main 的入口 _start）</li>
</ul>
</li>
</ul>
<h2 id="26-const-constexpr-mutable">26. const / constexpr / mutable</h2>
<h3 id="1-const">(1) const</h3>
<ul>
<li>const 表示“值不能修改”，是运行时常量（编译时无法保证是常量），可用于常量指针、常量函数等。</li>
<li>可用于任意可赋值表达式。</li>
<li>不能用于静态数组大小</li>
<li>性能较低，需运行时计算。</li>
</ul>
<h3 id="2-constexpr">(2) constexpr</h3>
<ul>
<li>constexpr 表示“在编译期就已知的常量”，是编译时常量（必须在编译期间求值）。</li>
<li>表达式必须是编译期可求值。</li>
<li>可用于静态数组大小。</li>
<li>性能较高，计算结果直接嵌入到编译后的代码中。</li>
<li>不能使用 constexpr 的情况（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O2FPCCBlGUckXjfjcwzryA%EF%BC%89%EF%BC%9A">https://mp.weixin.qq.com/s/O2FPCCBlGUckXjfjcwzryA）：</a>
<ul>
<li>如果函数的返回值不是编译期常量，则其类型不能是 constexpr。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;  <span class="hljs-comment">// 运行时返回</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">()</span> </span>&#123;    <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getValue</span>() * <span class="hljs-built_in">getValue</span>();  <span class="hljs-comment">// 编译错误：getValue() 不是常量表达式</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>如果函数里包含动态内存的分配（new），则其返回值不能是 constexpr</li>
<li>表达式里包含运行时输入的变量</li>
</ul>
</li>
</ul>
<h3 id="3-mutable">(3) mutable</h3>
<ul>
<li>
<p>在 const 成员函数中，编译器默认阻止修改任何成员变量。但有些成员变量实际上是缓存、标记、日志开关等行为上的“非状态性成员”，这时就需要 mutable。</p>
</li>
<li>
<p>mutable 用于允许某个类成员变量在 const 成员函数中被修改 和 修饰 lambda 表达式捕获的变量。注意，mutable 是专为此设计的，即除了用于修饰 lambda 捕获的变量，mutable 只能用于类的非静态成员变量，<em>不能用于普通局部变量或全局变量</em>。同时，mutable  也不能用于静态成员变量，因为  static  变量是全局共享的，不受  const  限制。</p>
</li>
<li>
<p>绕过 const 修饰的唯一合法方式，用于明确标记：这个成员变量不是逻辑上的 const。</p>
</li>
<li>
<p>使用场景：</p>
<ul>
<li>
<p>缓存机制 / 延迟计算（懒加载）（lazy evaluation）：等到真正需要某个值时才进行计算，否则就跳过这次计算。避免提前执行浪费资源，真正需要的时候再计算并缓存结果，避免重复计算（缓存机制）。如下例，getValue() 是 const，但缓存字段用 mutable 修饰，只有第一次调用才会执行计算，后续调用直接返回上次结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyValue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cached) &#123;<br>            value = <span class="hljs-built_in">expensiveCompute</span>();  <span class="hljs-comment">// 只执行一次</span><br>            cached = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">expensiveCompute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Computing...&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;  <span class="hljs-comment">// 假设这是一个复杂计算</span><br>    &#125;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> cached = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>访问计数/日志记录</p>
</li>
<li>
<p>lambda 表达式中修饰被捕获的变量。lambda 默认捕获的值是<strong>只读副本</strong>，加上 mutable 后可以修改 lambda 内部的副本（<strong>不影响外部</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> f = [x]() <span class="hljs-keyword">mutable</span> &#123;<br>    x++;         <span class="hljs-comment">// 合法：捕获值可修改副本</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="27-如何在-main-之前执行一个函数">27. 如何在 main 之前执行一个函数</h2>
<ul>
<li>
<p>方法一：全局/静态对象的构造函数。C++ 会在 main() 调用之前 自动调用全局/静态对象的构造函数。</p>
<ul>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitBeforeMain</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">InitBeforeMain</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;初始化代码在 main() 前执行！&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>InitBeforeMain run_before_main;  <span class="hljs-comment">// 全局对象</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="28-字节序大端序小端序">28. 字节序：大端序/小端序</h2>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YobhzS5gYBfYC5DXFXpLRw">https://mp.weixin.qq.com/s/YobhzS5gYBfYC5DXFXpLRw</a></p>
<h2 id="29-浅拷贝-和-深拷贝">29. 浅拷贝 和 深拷贝</h2>
<h3 id="1-浅拷贝shallow-copy">(1) 浅拷贝（Shallow Copy）</h3>
<p>浅拷贝是指在拷贝对象时，仅复制对象的成员变量的值，而不复制其指向的资源。对于指针成员变量，浅拷贝会复制指针的值（即地址），使得<strong>原对象和新对象指向同一块内存区域</strong>。这种方式在对象中没有指针或资源管理需求时是可行的，但在涉及动态内存分配时可能导致问题，如多个对象共享同一资源，进而在析构时出现重复释放(double free)的问题。</p>
<p>C++ 默认的拷贝构造函数是<strong>浅拷贝</strong>。</p>
<h3 id="2-深拷贝deep-copy">(2) 深拷贝（Deep Copy）</h3>
<p>深拷贝是在拷贝对象时，不仅复制对象的成员变量的值，还会<strong>为指针成员变量分配新的内存</strong>，并复制原指针指向的数据。这样，原对象和新对象拥有各自独立的资源，互不影响。深拷贝通常通过<strong>自定义拷贝构造函数和赋值运算符</strong>来实现，确保在对象复制时正确管理资源，避免资源共享带来的问题。</p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShallowCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 默认拷贝构造函数（浅拷贝）</span><br>    <span class="hljs-comment">// ShallowCopy(const ShallowCopy&amp; other) = default;</span><br><br>    ~<span class="hljs-built_in">ShallowCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义拷贝构造函数（深拷贝）</span><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> DeepCopy&amp; other) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载赋值运算符（https://mp.weixin.qq.com/s/8-ov2PxY91k2YhCxqqezRQ）</span><br>    DeepCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DeepCopy&amp; other) &#123;    <br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123;        <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <br>      &#125;   <br>      <span class="hljs-keyword">delete</span> data;  <span class="hljs-comment">// 释放已有内存，防止内存泄漏。如果不释放直接new，会导致原来的 data 指针被覆盖，之前指向的内存失去控制，从而导致内存泄漏。    </span><br>      data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));  <span class="hljs-comment">// 深拷贝</span><br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">DeepCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ShallowCopy <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    ShallowCopy obj2 = obj1; <span class="hljs-comment">// 浅拷贝，obj1.data 和 obj2.data 指向同一内存</span><br><br>    <span class="hljs-function">DeepCopy <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    DeepCopy obj4 = obj3; <span class="hljs-comment">// 深拷贝，obj3.data 和 obj4.data 指向不同内存</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述示例中，<code>ShallowCopy</code> 类使用默认的拷贝构造函数，导致 <code>obj1</code> 和 <code>obj2</code> 共享同一块内存，这样 obj2  析构时会释放  data，obj1  访问  data  可能出现   悬垂指针（dangling pointer）；而 <code>DeepCopy</code> 类通过自定义拷贝构造函数，实现了对指针成员的深拷贝，使得 <code>obj3</code> 和 <code>obj4</code> 拥有独立的内存.</p>
<h3 id="智能指针解决问题">智能指针解决问题</h3>
<p>C++11 提供了  std::shared_ptr  和  std::unique_ptr  以管理资源，避免手动拷贝管理。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartCopy</span> &#123;<br>  <span class="hljs-keyword">public</span>:   <br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; data;    <br>    <span class="hljs-built_in">SmartCopy</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(val)) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="30-模板-template">30. 模板 template</h2>
<h3 id="1-模板的内部实现原理">(1) 模板的内部实现原理</h3>
<p>模板是一个编译时的过程。核心思想是代码生成 (Code Generation) 和实例化 (Instantiation)。在<strong>实例化</strong>期间，编译器会获取模板的定义，并将模板参数（如 T 或非类型参数）替换为程序员提供的具体类型（如 int、double）或值。这个过程会生成一个针对这些特定参数的普通类或函数的定义。例如，对于<code>std::vector&lt;int&gt;</code>，编译器会生成一个类似于 <code>class vector_int &#123; ... &#125;</code> 的具体类定义（名称是经过修饰的，下面会提到）。对于 <code>std::vector&lt;std::string&gt;</code>，则会生成另一个独立的类定义。由于一个模板可以被多种不同的类型实例化（例如 <code>MyClass&lt;int&gt;</code> 和 <code>MyClass&lt;double&gt;</code>），编译器需要<strong>为每个实例化版本生成唯一的内部名称，以便链接器能够正确区分和链接它们</strong>。这个过程称为<strong>名称修饰</strong>。例如，<code>void foo&lt;int&gt;(int)</code> 和 <code>void foo&lt;char&gt;(char)</code> 在编译后会有不同的符号名。</p>
<p>这些由模板实例化产生的具体类和函数定义随后会被正常编译，就像手写了这些特定版本的代码一样。编译器会为每个不同的实例化版本生成相应的机器码。模板的定义（不仅仅是声明）通常需要对编译器可见，以便在需要时进行实例化。这就是为什么模板的实现通常放在头文件中。如果编译器在某个编译单元中看到了模板的使用但找不到其定义，它就无法进行实例化（每个 cpp 是独立的 translation unit 分开编译的，如果在一个 cpp 里定义而在另一个 cpp 中使用，就无法找到其定义，具体见<a href="/2025/05/21/cpp-templates/"> cpp-templates</a>）。</p>
<p>编译器处理模板时，名称查找分两个阶段进行：</p>
<ul>
<li>第一阶段 (定义时/解析时): 在模板定义被解析但尚未实例化时，编译器会查找非依赖名称 (non-dependent names)。这些是不依赖于模板参数的名称（例如，全局函数名、在模板外部定义的类型名）。此时会进行基本的语法检查。</li>
<li>第二阶段 (实例化时): 当模板使用具体类型进行实例化时，编译器会查找依赖名称 (dependent names)。这些是依赖于模板参数的名称（例如，T::member_type 或调用一个参数类型为 T 的函数）。此时会进行涉及具体类型的语义检查。</li>
</ul>
<p>这个机制确保了模板在定义时就能捕捉一些错误，同时又能灵活处理依赖于具体实例化类型的操作。</p>
<p>实例化可以分为显式实例化 (Explicit Instantiation) 与隐式实例化 (Implicit Instantiation):</p>
<ul>
<li>隐式实例化: 当在代码中使用一个模板并提供参数时，编译器会自动实例化它（如果尚未实例化）。</li>
<li>显式实例化: 可以明确指示编译器为特定的模板参数集生成代码。如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::vector&lt;MyClass&gt;; <span class="hljs-comment">// 显式实例化整个类</span><br><span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-built_in">myFunc</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-type">double</span>); <span class="hljs-comment">// 显式实例化一个函数模板</span><br></code></pre></td></tr></table></figure>
<p>这可以用于控制代码生成的位置，有时用于减少编译时间或管理代码大小，尤其是在库的实现中。<code>extern template</code> 声明则可以防止在多个编译单元中重复实例化，以加快编译。</p>
<h3 id="2-模板声明与实现如何能不在同一个头文件">(2) 模板声明与实现如何能不在同一个头文件</h3>
<ul>
<li><strong>将实现放在一个单独的、被声明头文件包含的实现文件（通常是 <code>.tpp</code> 或 <code>.ipp</code> 文件）</strong></li>
</ul>
<p>这是一种常见的组织方式，尤其对于复杂的模板类。实际上，它们仍然被“合并”到了同一个编译单元中（通过 <code>#include</code>），但物理上文件是分开的。</p>
<ul>
<li>
<p><strong><code>my_template.h</code> (声明文件):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_TEMPLATE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_TEMPLATE_H</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T value);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    T value_;<br>&#125;;<br><br><span class="hljs-comment">// 在声明文件的末尾包含实现文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_template.tpp&quot;</span> <span class="hljs-comment">// 或者 .ipp, .impl 等</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MY_TEMPLATE_H</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>my_template.tpp</code> (实现文件):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 通常不需要包含守卫，因为它被 .h 文件包含</span><br><span class="hljs-comment">// 但如果它可能被直接包含（不推荐），则可能需要</span><br><span class="hljs-comment">// #include &quot;my_template.h&quot; // 确保声明可见，如果单独处理此文件</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>MyClass&lt;T&gt;::<span class="hljs-built_in">MyClass</span>(T value) : <span class="hljs-built_in">value_</span>(value) &#123;<br>    <span class="hljs-comment">// 实现</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> MyClass&lt;T&gt;::<span class="hljs-built_in">printValue</span>() &#123;<br>    <span class="hljs-comment">// 实现</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; value_ &lt;&lt; std::endl; // 假设包含了 &lt;iostream&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用户代码 (<code>main.cpp</code>):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_template.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj.<span class="hljs-built_in">printValue</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>工作原理:</strong><br>
当 <code>main.cpp</code> 包含 <code>my_template.h</code> 时，预处理器会首先处理 <code>my_template.h</code>。在 <code>my_template.h</code> 的末尾，<code>#include &quot;my_template.tpp&quot;</code> 指令会把 <code>my_template.tpp</code> 文件的全部内容“粘贴”到 <code>my_template.h</code> 的那个位置。因此，当编译器实际编译 <code>main.cpp</code> 这个翻译单元时，它看到了模板的声明和定义，就好像它们都在一个文件里一样。</p>
</li>
<li>
<p><strong>优点:</strong></p>
<ul>
<li>保持头文件（接口部分）的整洁。</li>
<li>物理上分离了声明和实现，便于管理。</li>
</ul>
</li>
<li>
<p><strong>缺点:</strong></p>
<ul>
<li>严格来说，这并没有解决“定义必须在编译时可见”的问题，只是换了一种组织方式。最终定义还是通过 <code>#include</code> 进入了使用模板的编译单元。</li>
</ul>
</li>
<li>
<p><strong>使用显式实例化 (Explicit Instantiation) 将定义放在 <code>.cpp</code> 文件中</strong></p>
</li>
</ul>
<p>真正意义上将模板定义与声明分离到不同编译单元（声明在 <code>.h</code>，定义在 <code>.cpp</code>）的方法。</p>
<ul>
<li>
<p><strong><code>my_template.h</code> (声明文件):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_TEMPLATE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_TEMPLATE_H</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyData</span>(T data);<br>    <span class="hljs-function">T <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    T data_;<br>&#125;;<br><br><span class="hljs-comment">// 对于函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span></span>;<br><br><span class="hljs-comment">// (可选) 显式实例化声明 (extern template)</span><br><span class="hljs-comment">// 告诉编译器这些实例化版本会在别处定义，不要在此处隐式实例化</span><br><span class="hljs-comment">// extern template class MyData&lt;int&gt;;</span><br><span class="hljs-comment">// extern template int add&lt;int&gt;(int, int);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MY_TEMPLATE_H</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>my_template.cpp</code> (实现和显式实例化定义文件):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_template.h&quot;</span></span><br><span class="hljs-comment">// #include &lt;iostream&gt; // 如果需要</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>MyData&lt;T&gt;::<span class="hljs-built_in">MyData</span>(T data) : <span class="hljs-built_in">data_</span>(data) &#123;<br>    <span class="hljs-comment">// 实现</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T MyData&lt;T&gt;::<span class="hljs-built_in">getData</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> data_;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// !!! 关键部分：显式实例化定义 !!!</span><br><span class="hljs-comment">// 为你希望支持的每一种类型提供一个显式实例化</span><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>&lt;<span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>&lt;<span class="hljs-type">double</span>&gt;;<br><span class="hljs-comment">// template class MyData&lt;std::string&gt;; // 如果需要支持 std::string</span><br><br><span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-built_in">add</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-keyword">template</span> <span class="hljs-type">double</span> <span class="hljs-built_in">add</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>);<br><span class="hljs-comment">// template std::string add&lt;std::string&gt;(std::string, std::string);</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用户代码 (<code>main.cpp</code>):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_template.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">// For std::string example</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyData&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intObj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">// MyData&lt;std::string&gt; strObj(&quot;hello&quot;); // 如果 MyData&lt;std::string&gt; 没有在 my_template.cpp 中显式实例化，这里会链接失败</span><br><br>    <span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);       <span class="hljs-comment">// 使用 add&lt;int&gt;</span><br>    <span class="hljs-comment">// add(5.5, 10.2); // 如果 add&lt;double&gt; 没有显式实例化，这里会链接失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>工作原理:</strong></p>
<ul>
<li>用户代码 (<code>main.cpp</code>) 只包含 <code>my_template.h</code>，它只有模板的声明。</li>
<li>当编译器编译 <code>main.cpp</code> 并看到 <code>MyData&lt;int&gt; intObj(10);</code> 时，它知道 <code>MyData</code> 是个模板。如果 <code>my_template.h</code> 中有 <code>extern template class MyData&lt;int&gt;;</code>，编译器会假设 <code>MyData&lt;int&gt;</code> 的完整定义和编译后的代码会在其他地方提供，因此它不会在 <code>main.o</code> 中尝试生成 <code>MyData&lt;int&gt;</code> 的代码。如果没有 <code>extern template</code> 声明，编译器可能会尝试隐式实例化，但如果找不到定义，后续链接会失败（除非其他地方有定义）。</li>
<li><code>my_template.cpp</code> 文件包含了模板的完整定义。更重要的是，它通过 <code>template class MyData&lt;int&gt;;</code> 这样的语句，<strong>显式地指示编译器在此处为 <code>MyData&lt;int&gt;</code> (以及其他列出的类型) 生成完整的代码</strong>。这些生成的代码会被编译到 <code>my_template.o</code> 这个对象文件中。</li>
<li>在链接阶段，当链接器处理 <code>main.o</code> 并发现它需要 <code>MyData&lt;int&gt;</code> 的实现时，它会在 <code>my_template.o</code> (或其他对象文件) 中找到预先编译好的 <code>MyData&lt;int&gt;</code> 的代码。</li>
</ul>
</li>
<li>
<p><strong>优点:</strong></p>
<ul>
<li><strong>真正的分离</strong>: 模板的实现细节可以完全隐藏在 <code>.cpp</code> 文件中，不暴露给用户。</li>
<li><strong>可能减少编译时间</strong>: 用户代码不需要在每次编译时都重新处理和实例化模板定义，因为它们是预编译的。</li>
<li><strong>可能减少最终可执行文件的大小</strong>: 通过 <code>extern template</code> 和集中的显式实例化，可以避免在多个编译单元中生成相同的模板实例化副本（尽管现代链接器通常也能很好地处理副本合并）。</li>
</ul>
</li>
<li>
<p>*缺点:**</p>
<ul>
<li><strong>不灵活</strong>: 模板的作者必须预先知道并显式实例化所有用户可能用到的类型组合。如果用户尝试使用一个未被显式实例化的类型（例如 <code>MyData&lt;float&gt;</code>），将会导致链接错误。这使得模板的通用性大大降低。</li>
<li><strong>维护负担</strong>: 每次添加对新类型的支持，都需要修改 <code>.cpp</code> 文件并添加相应的显式实例化。</li>
</ul>
</li>
<li>
<p><strong>总结:</strong></p>
<ul>
<li>将模板实现放在单独的 <code>.tpp</code> 文件并由声明头文件包含，是最常见的“物理分离但逻辑统一”的方法，它不改变模板的基本实例化机制。</li>
<li>使用显式实例化，将模板定义放在 <code>.cpp</code> 文件中，是实现真正编译单元分离的方法，但以牺牲通用性和增加维护负担为代价。它适用于模板的使用场景和类型集非常固定和已知的情况（例如，在一些库的内部实现中）。</li>
</ul>
<p>对于大多数通用模板库，第一种方法（或直接将简短定义放在声明头文件中）更为常见。第二种方法则更像是一种特化技术。</p>
</li>
</ul>
<h3 id="3-宏和模板的差异">(3) 宏和模板的差异</h3>
<p>宏 (Macros) 和模板 (Templates) 都允许编写某种形式的通用代码，但其效率、影响等也有所差异：</p>
<ul>
<li>
<p><strong>处理阶段与机制</strong>:</p>
<ul>
<li><strong>宏</strong>: 由 <strong>预处理器</strong> 在编译之前处理。预处理器执行的是纯粹的<strong>文本替换</strong>。它不理解 C++ 的语法或类型，只是简单地查找和替换标识符。</li>
<li><strong>模板</strong>: 由 <strong>编译器</strong> 在编译期间处理。模板是 C++ 语言的一部分，编译器会理解模板的语义，并根据提供的模板参数 <strong>实例化</strong> (生成) 具体的、类型正确的代码。</li>
</ul>
</li>
<li>
<p><strong>类型安全</strong>:</p>
<ul>
<li><strong>宏</strong>: <strong>不类型安全</strong>。由于是文本替换，<strong>预处理器不会进行任何类型检查</strong>。使用不当的类型可能会导致编译错误（有时是难以理解的错误），或者更糟的是，在运行时产生未定义行为。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="hljs-comment">// MAX(&quot;apple&quot;, &quot;orange&quot;) // 文本比较，可能不是预期行为</span><br><span class="hljs-comment">// MAX(1, &quot;text&quot;) // 编译错误，但错误信息可能指向展开后的代码</span><br></code></pre></td></tr></table></figure>
</li>
<li><strong>模板</strong>: <strong>类型安全</strong>。编译器在实例化模板时会检查类型。如果类型不匹配或不支持所需的操作，编译器会产生错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">max_val</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;<br>&#125;<br><span class="hljs-comment">// max_val(&quot;apple&quot;, &quot;orange&quot;); // 编译错误，C-style strings don&#x27;t work with &gt; as expected for content.</span><br>                              <span class="hljs-comment">// std::string would work.</span><br><span class="hljs-comment">// max_val(1, &quot;text&quot;); // 编译错误，类型不匹配</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>作用域与命名空间</strong>:</p>
<ul>
<li><strong>宏</strong>: <strong>不遵循 C++ 的作用域规则或命名空间</strong>。宏通常具有全局作用域（从定义点到文件尾，或直到 <code>#undef</code>）。这很容易导致名称冲突，特别是与库中的名称或其他代码段中的宏冲突。</li>
<li><strong>模板</strong>: <strong>遵循 C++ 的作用域和命名空间规则</strong>。模板可以定义在命名空间内，其名称像其他 C++ 实体一样受到作用域的限制，从而减少了名称冲突的可能性。</li>
</ul>
</li>
<li>
<p><strong>调试</strong>:</p>
<ul>
<li><strong>宏</strong>: <strong>调试困难</strong>。因为宏是文本替换，编译器看到的实际代码是宏展开后的代码。调试时，<strong>错误信息可能指向展开后的、程序员并未直接编写的代码，使得追踪问题源头变得困难</strong>。单步调试也会跳过宏本身，直接进入展开后的代码。</li>
<li><strong>模板</strong>: <strong>调试相对容易</strong>。虽然模板的编译错误信息有时可能冗长（尤其是在复杂的模板元编程中），但它们通常与类型和模板参数相关。调试器能够理解模板实例化后的函数和类，可以像调试普通 C++代码一样进行调试。</li>
</ul>
</li>
<li>
<p><strong>参数求值</strong>:</p>
<ul>
<li><strong>宏</strong>: <strong>参数可能被多次求值</strong>。如果宏参数在宏体中出现多次，并且该参数带有副作用（如 <code>i++</code>），那么副作用会发生多次，这通常不是期望的行为。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x)*(x))</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">SQUARE</span>(a++); <span class="hljs-comment">// 展开为 ((a++)*(a++)) -&gt; ((2)*(3)) -&gt; a 变为 4, b 得到 6 (行为可能依赖编译器求值顺序)</span><br></code></pre></td></tr></table></figure>
</li>
<li><strong>模板</strong>: <strong>函数参数只求值一次</strong>，就像普通函数调用一样。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">square_tpl</span><span class="hljs-params">(T x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><span class="hljs-type">int</span> a_tpl = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> b_tpl = <span class="hljs-built_in">square_tpl</span>(a_tpl++); <span class="hljs-comment">// a_tpl++ (2) 求值一次, a_tpl 变为 3, square_tpl(2) 被调用, b_tpl 得到 4</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>递归</strong>:</p>
<ul>
<li><strong>宏</strong>: <strong>不能直接递归</strong>（预处理器通常会阻止宏的直接递归展开以避免无限循环）。</li>
<li><strong>模板</strong>: <strong>支持递归</strong>（模板元编程中常见），包括递归的类模板和函数模板实例化。</li>
</ul>
</li>
<li>
<p><strong>代码生成与可内联性</strong>:</p>
<ul>
<li><strong>宏</strong>: 简单的代码复制粘贴。如果宏体很大，多次使用会导致代码膨胀。宏定义的函数式宏通常会被内联（因为它们是文本替换）。</li>
<li><strong>模板</strong>: 编译器为每个不同的模板参数集生成一个独立的实例。这也可能导致代码膨胀（“template bloat”），但编译器和链接器有机制来优化，例如合并相同的实例化代码。模板函数也可以被编译器内联。</li>
</ul>
</li>
<li>
<p><strong>语法和语言集成度</strong>:</p>
<ul>
<li><strong>宏</strong>: 使用预处理器语法，与 C++ 语法规则不同。需要小心处理括号以避免操作符优先级问题。</li>
<li><strong>模板</strong>: 使用标准的 C++ 语法，是语言的头等公民。</li>
</ul>
</li>
<li>
<p><strong>能力范围</strong>:</p>
<ul>
<li><strong>宏</strong>: 可以做一些模板做不到的事情，如：
<ul>
<li><strong>字符串化 (<code>#</code>)</strong>: 将宏参数转换为字符串字面量。</li>
<li><strong>符号连接 (<code>##</code>)</strong>: 将两个符号连接成一个新的符号。</li>
<li><strong>条件编译 (<code>#ifdef</code>, <code>#if</code>)</strong>: 根据宏定义来包含或排除代码块。</li>
<li>定义简单的常量而无需类型。</li>
</ul>
</li>
<li><strong>模板</strong>: 更擅长于：
<ul>
<li><strong>泛型编程</strong>: 创建类型无关的算法和数据结构。</li>
<li><strong>模板元编程 (TMP)</strong>: 在编译时执行计算。</li>
<li><strong>特化与偏特化</strong>: 为特定类型提供定制的实现。</li>
<li><strong>SFINAE (Substitution Failure Is Not An Error)</strong>: 允许基于类型特性进行复杂的重载决策。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>优先使用模板</strong>: 对于泛型编程、创建可重用的类型安全组件，模板是现代 C++ 的首选。它们更安全、更强大，并且更好地集成了 C++ 语言特性。</p>
</li>
<li>
<p><strong>宏的适用场景</strong>:</p>
<ul>
<li><strong>头文件保护符</strong> (<code>#ifndef H_MYHEADER_H ... #endif</code>)。</li>
<li><strong>条件编译</strong> (<code>#ifdef DEBUG ... #endif</code>)。</li>
<li>简单的、不涉及复杂逻辑或类型的常量定义（尽管 <code>constexpr</code> 通常更好）。</li>
<li>需要字符串化或符号连接等预处理器特有功能的场景。</li>
<li>在极少数情况下，用于简化非常重复的、与类型无关的纯文本代码模式（需谨慎）。</li>
</ul>
</li>
</ul>
<h3 id="4-宏和模板的效率差异">(4) 宏和模板的效率差异</h3>
<ul>
<li>
<p><strong>运行时效率</strong>:</p>
<ul>
<li>对于简单的、可内联的操作，宏（函数式宏在预处理阶段被直接文本替换。这意味着如果宏体简单，相当于代码被直接内联，没有函数调用的开销。）和模板在理想情况下（简单的模板被成功内联）的运行时效率可以非常相似，因为两者最终都可能变成直接嵌入的机器码。</li>
<li>模板由于其类型感知能力，使编译器有更多机会<strong>进行特定于类型的优化</strong>，因此模板生成的代码质量在复杂情况下往往更高，可能带来更好的运行时性能。例如，一个通用的数学运算模板，当用 int 实例化时，编译器可以使用整数指令；当用 double 实例化时，可以使用浮点指令，并进行相应的特定优化。如果模板函数由于其复杂性、大小或调用方式（例如通过函数指针）而未被内联，那么它将产生正常的函数调用开销。</li>
<li>宏的多次参数求值问题可能导致性能下降和错误。</li>
</ul>
</li>
<li>
<p><strong>编译时效率</strong></p>
<ul>
<li>
<p>宏 (Macros):</p>
<ul>
<li>处理速度快: 预处理器执行的是相对简单的文本查找和替换操作。这个阶段通常非常快。</li>
</ul>
</li>
<li>
<p>模板 (Templates):</p>
<ul>
<li>处理开销大: 模板的处理要复杂得多，涉及到：
<ul>
<li>解析: 编译器需要解析模板定义。</li>
<li>实例化: 为每个用到的不同模板参数集生成具体的类或函数定义。</li>
<li>名称查找与绑定 (两阶段查找): 解析依赖名称和非依赖名称。</li>
<li>类型检查: 对每个实例化版本进行严格的类型检查。</li>
<li>SFINAE (替换失败并非错误): 如果用于重载决议，可能涉及多次尝试实例化。</li>
<li>模板元编程 (TMP): 如果使用了 TMP，编译器实际上是在执行计算，这可能非常耗时。</li>
<li>错误信息生成: 复杂模板的错误信息可能很长，生成和解析它们也需要时间。</li>
</ul>
</li>
<li>结果: 大量使用模板，特别是<strong>复杂的模板或深度嵌套的模板，会显著增加编译时间</strong>。这是模板的一个主要缺点，通常被称为“编译时开销”。</li>
</ul>
</li>
<li>
<p>总结编译时效率:</p>
</li>
</ul>
<p>宏的编译时（预处理时）效率远高于模板。模板的编译时开销是为其类型安全、表达能力和运行时优化潜力付出的代价。</p>
<p>综合来看:</p>
<ul>
<li>如果首要考虑的是极快的编译速度，且操作非常简单，不涉及复杂类型逻辑，宏可能更快（在编译时）。</li>
<li>如果考虑的是运行时性能、类型安全、代码可维护性和利用编译器高级优化能力，模板通常是更好的选择。现代编译器在优化模板实例化代码方面做得非常好。</li>
</ul>
</li>
</ul>
<h2 id="31-平衡二叉树红黑树avl-树">31. 平衡二叉树/红黑树/AVL 树</h2>
<h3 id="1-平衡二叉树">(1) 平衡二叉树</h3>
<p>平衡二叉树 (Balanced Binary Tree) 是一种特殊的二叉树，它通过一定的机制来维持其自身结构的平衡，以确保树的高度（或深度）大致保持在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的级别，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是树中节点的数量。在普通的二叉搜索树 (Binary Search Tree, BST) 中，如果插入或删除操作的顺序不当，树可能会变得非常“倾斜”或“不平衡”。在最坏的情况下，二叉搜索树可能退化成一个链表（例如，按顺序插入已排序的数据）。在这种情况下，搜索、插入和删除等基本操作的时间复杂度会从理想的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 下降到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这会严重影响性能。平衡二叉树的核心目的就是<strong>防止这种退化，确保树的各种操作都能在可预测的、高效的对数时间内完成</strong>。</p>
<p>“平衡”的确切定义会根据具体的平衡二叉树类型而有所不同。一些常见的衡量标准或约束包括：</p>
<ul>
<li><strong>高度差约束 (Height Difference Constraint)</strong>: 这是 <strong>AVL 树</strong> (Adelson-Velsky and Landis tree) 的核心特性。<strong>对于 AVL 树中的任何节点，其左子树和右子树的高度差（称为平衡因子）不能超过 1</strong>。</li>
<li><strong>路径长度约束 (Path Length Constraint)</strong> 或 <strong>颜色约束 (Color Constraint)</strong>: <strong>红黑树 (Red-Black Tree)</strong> 通过对节点施加特定的颜色属性（红色或黑色）以及一系列规则来确保<em>从根节点到任何叶子节点的最长路径不会超过最短路径的两倍</em>。这些规则间接保证了树的近似平衡和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的高度。<code>std::map</code> 和 <code>std::set</code> 在很多 C++ 标准库实现中就使用了红黑树。</li>
<li><strong>其他机制</strong>:
<ul>
<li><strong>B 树 (B-Tree)</strong> 及其变种 (如 B+ 树、B* 树) 也是平衡树，但它们通常不是二叉树（一个节点可以有多个子节点）。它们常用于数据库和文件系统中，通过确保<strong>所有叶子节点都在同一层</strong>，并要求内部节点有一定数量的子节点来保持平衡。</li>
<li><strong>伸展树 (Splay Tree)</strong> 是一种自平衡的二叉搜索树，它通过在每次访问后将访问的节点通过一系列“伸展”操作（旋转）移动到根部，从而在均摊意义上达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的性能。</li>
<li><strong>Treap (Tree Heap)</strong> 通过为每个节点随机分配一个优先级，并同时维持二叉搜索树的顺序属性（按键值）和堆的顺序属性（按优先级），从而以较高的概率保持平衡。</li>
</ul>
</li>
</ul>
<h3 id="2-红黑树">(2) 红黑树</h3>
<ul>
<li>特性（左根右，根叶黑，不红红，黑路同）：
<ul>
<li>二叉搜索树（左 &lt; 根 &lt; 右）。</li>
<li>一个节点要么是黑色要么是红色，<strong>根节点和叶子节点（NULL，叶子节点不存储数据）都是黑色</strong>。</li>
<li>如果一个节点是红色的，那么它的两个子节点都必须是黑色的。这意味着在从根到任何叶子的任何路径上，都不能有两个连续的红色节点。</li>
<li>对于树中的任何一个节点，从该节点到其所有后代叶子节点（NIL 节点）的每条简单路径上，都包含<strong>相同数量的黑色节点</strong>。这个数量被称为节点的“黑高 (black-height)”。</li>
<li>这些属性共同保证了红黑树的一个关键特性：从任一节点到最远的叶子节点的路径长度，不会超过从该节点到最近的叶子节点路径长度的两倍（最长路径不超过最短路径的两倍）。</li>
</ul>
</li>
</ul>
<h3 id="3-红黑树查找插入删除">(3) 红黑树查找/插入/删除</h3>
<p>好的，我们来详细展开红黑树的查找、插入和删除操作。这些操作的核心在于，它们首先执行标准的二叉搜索树操作，然后通过一系列的旋转和颜色调整来恢复红黑树的五个属性，从而保持树的平衡。</p>
<ul>
<li>
<p><strong>查找</strong></p>
<p>红黑树的查找操作与普通二叉搜索树 (BST) 的查找操作<strong>完全相同</strong>。</p>
<ul>
<li>
<p><strong>步骤</strong>:</p>
<ol>
<li>从根节点开始。</li>
<li>比较目标键值与当前节点的键值：
<ul>
<li>如果相等，则找到了节点，返回该节点。</li>
<li>如果目标键值小于当前节点的键值，则在当前节点的左子树中继续查找（即，移动到左孩子）。</li>
<li>如果目标键值大于当前节点的键值，则在当前节点的右子树中继续查找（即，移动到右孩子）。</li>
</ul>
</li>
<li>如果当前节点是 NIL（叶子节点，表示空），则说明树中不存在该键值的节点。</li>
</ol>
</li>
<li>
<p><strong>颜色</strong>: 节点的颜色在查找过程中不起任何直接作用。红黑属性确保了树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因此查找操作的时间复杂度也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
</li>
</ul>
</li>
<li>
<p><strong>插入</strong></p>
<p>插入操作稍微复杂一些，因为它可能破坏红黑树的属性。</p>
<ul>
<li>
<p><strong>步骤 1: 标准 BST 插入</strong></p>
<ul>
<li>首先，<strong>按照普通二叉搜索树的规则找到新节点的插入位置</strong>，并将新节点插入。</li>
<li><strong>将新插入的节点 <code>z</code> 标记为红色 (RED)</strong>。
<ul>
<li><strong>为什么是红色？</strong> 如果将新节点标记为黑色，几乎肯定会改变从其祖先到叶子节点的路径上的黑色节点数量，从而违反“属性：任一节点的”。如果标记为红色，则不会影响任何路径的黑色高度。然而，标记为红色可能会导致“属性：红色节点的子节点必须是黑色”被违反（如果新节点的父节点也是红色），或者如果树为空，新节点成为根节点，可能会违反“属性：根节点是黑色”。所以需要一个修复颜色的过程。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>步骤 2: 修复红黑属性</strong><br>
在插入红色节点 <code>z</code> 后，调用一个修复过程来恢复可能被破坏的红黑属性。此过程主要处理由于 <code>z</code> 和其父节点 <code>p</code> 可能都是红色而导致的违规。修复过程的核心思想是通过一系列的颜色翻转和旋转来解决问题。我们主要关注节点 <code>z</code>、其父节点 <code>p</code>、其祖父节点 <code>g</code>，以及其叔叔节点 <code>y</code> (即 <code>g</code> 的另一个孩子)。如果插入节点是根节点，直接把插入节点变黑。</p>
<p>修复循环 (<strong>只要 <code>z</code> 不是根节点且 <code>z</code> 的父节点 <code>p</code> 是红色就继续</strong>):</p>
<ul>
<li>
<p><strong>确定叔叔节点 <code>y</code></strong>:</p>
<ul>
<li>如果 <code>p</code> 是 <code>g</code> 的左孩子，则 <code>y</code> 是 <code>g</code> 的右孩子。</li>
<li>如果 <code>p</code> 是 <code>g</code> 的右孩子，则 <code>y</code> 是 <code>g</code> 的左孩子。</li>
</ul>
</li>
<li>
<p><strong>根据叔叔节点 <code>y</code> 的颜色分情况处理</strong>:</p>
<ul>
<li>
<p><strong>情况 1: 叔叔 <code>y</code> 是红色 (RED)</strong></p>
<ul>
<li><strong>操作</strong>（叔父爷变色，爷爷变插入节点）:
<ul>
<li>将父节点 <code>p</code> 设为黑色 (BLACK)。</li>
<li>将叔叔节点 <code>y</code> 设为黑色 (BLACK)。</li>
<li>将祖父节点 <code>g</code> 设为红色 (RED)。</li>
<li>将当前节点 <code>z</code> 指向祖父节点 <code>g</code> (<code>z = g</code>)。</li>
</ul>
</li>
<li><strong>解释</strong>: 这个操作将两个红色节点（<code>p</code> 和 <code>y</code>）的“红色属性” 向上推给了祖父 <code>g</code>。现在 <code>g</code> 可能是新的问题节点（如果 <code>g</code> 的父节点也是红色），所以循环需要继续从 <code>g</code> 开始。</li>
</ul>
</li>
<li>
<p><strong>情况 2: 叔叔 <code>y</code> 是黑色 (BLACK) 或 NIL</strong></p>
<ul>
<li><strong>操作</strong>：根据 AVL 一节中叙述的方式判断是 LL/RR/LR/RL，然后把爷爷当作失衡节点进行相应的旋转。旋转结束后对失衡节点（旋转点）和被当作旋转轴的点交换颜色。具体见：【红黑树 - 定义, 插入, 构建】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xm421x7Lg/?share_source=copy_web&amp;vd_source=456629902e57c5630924f693427a46da">https://www.bilibili.com/video/BV1Xm421x7Lg/?share_source=copy_web&amp;vd_source=456629902e57c5630924f693427a46da</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>循环结束后</strong>:</p>
<ul>
<li>将树的根节点设为黑色 (BLACK)，因为情况 1 中根节点可能被设为红色。</li>
</ul>
<p>插入操作通过这几种情况的处理，<strong>最多只需要两次旋转</strong>就能恢复平衡。</p>
</li>
</ul>
</li>
<li>
<p><strong>删除</strong></p>
<ul>
<li>
<p>删除操作是红黑树中最复杂的操作，具体见：【红黑树 - 删除】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16m421u7Tb/?share_source=copy_web&amp;vd_source=456629902e57c5630924f693427a46da">https://www.bilibili.com/video/BV16m421u7Tb/?share_source=copy_web&amp;vd_source=456629902e57c5630924f693427a46da</a></p>
</li>
<li>
<p><strong>最多只需要三次旋转就能恢复平衡</strong>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-avl-树">(4) AVL 树</h3>
<p><strong>AVL 树</strong>是以其发明者 G.M. Adelson-Velsky 和 E.M. Landis (在 1962 年) 的名字命名的，它是<strong>最早被发明的自平衡二叉搜索树 (Self-Balancing Binary Search Tree)</strong>。</p>
<ul>
<li>首先，AVL 树必须满足二叉搜索树的基本性质：对于树中的任何节点，其左子树中所有节点的值都小于该节点的值，而其右子树中所有节点的值都大于该节点的值。</li>
<li><strong>平衡条件</strong>:
<ul>
<li>这是 AVL 树的关键。对于 AVL 树中的<strong>每一个节点</strong>，其<strong>左子树的高度</strong>与<strong>右子树的高度</strong>之差（绝对值）<strong>最多为 1</strong>。</li>
<li>这个高度差通常被称为节点的<strong>平衡因子 (Balance Factor)</strong>。 平衡因子 = <code>高度(右子树) - 高度(左子树)</code> (或者反过来，只要保持一致即可)。因此，AVL 树中每个节点的平衡因子必须是 <strong>-1、0 或 1</strong>。如果任何节点的平衡因子变成了 -2 或 +2，那么树就失去了 AVL 平衡，需要进行调整（注：节点的高度通常定义为从该节点到其最远叶子节点路径上的边数。空树的高度通常定义为 -1，叶子节点的高度为 0）。</li>
</ul>
</li>
<li><strong>性能保证</strong>:
<ul>
<li>由于这种严格的平衡条件，AVL 树的高度被严格限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是节点的数量。具体来说，AVL 树的高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>&lt;</mo><mn>1.44</mn><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>0.328</mn></mrow><annotation encoding="application/x-tex">h &lt; 1.44 \log_2(n+2) - 0.328</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1.44</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.328</span></span></span></span>。</li>
<li>这保证了查找 (search)、插入 (insertion) 和删除 (deletion) 操作的<strong>最坏情况时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong>。</li>
</ul>
</li>
<li><strong>如何维持平衡 (Rebalancing)</strong>:
<ul>
<li>当检测到不平衡时，AVL 树会通过执行一种或多种<strong>树旋转</strong>(Tree Rotations)操作来恢复平衡。这些旋转操作会重新组织树的局部结构，以满足平衡条件，同时保持二叉搜索树的性质。</li>
<li>主要的旋转类型有四种，它们是针对导致不平衡的节点（通常是第一个平衡因子为 ±2 的节点）及其子孙节点进行的：
<ul>
<li><strong>RR 不平衡 / 左旋</strong>：当不平衡是由于插入节点是在不平衡节点的右孩子的右子树造成的需要进行左旋，特点是失衡节点的平衡因子为 -2，失衡节点右孩子的平衡因子为 -1。左旋就是把不平衡的节点<strong>以其右孩子为轴逆时针旋转为其右孩子的左孩子</strong>，旋转前后的中序遍历结果相同，但后者树的高度变低了。如果不平衡的节点本身有左孩子，那这个冲突的左孩子变成不平衡节点旋转后的右孩子（图示见【平衡二叉树(AVL 树)】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ421q72h/?share_source=copy_web&amp;vd_source=456629902e57c5630924f693427a46da">https://www.bilibili.com/video/BV1tZ421q72h/?share_source=copy_web&amp;vd_source=456629902e57c5630924f693427a46da</a> ）。</li>
<li><strong>LL 不平衡 / 右旋</strong>: 当不平衡是由于插入节点是在不平衡节点的左孩子的左子树造成的需要进行右旋，特点是失衡节点的平衡因子为 2，失衡节点左孩子的平衡因子为 1。右旋的方式和左旋相反。</li>
<li><strong>LR 不平衡</strong>: 当不平衡是由于在节点的左孩子的右子树中插入造成的。特点是失衡节点的平衡因子是 2，失衡节点的左孩子的平衡因子为-1。解决方式是先对左孩子进行一次左旋，然后再对失衡节点进行一次右旋。</li>
<li><strong>RL 不平衡</strong>: 当不平衡是由于在节点的右孩子的左子树中插入造成的。特点是失衡节点的平衡因子是 -2，失衡节点的右孩子的平衡因子为 1。这相当于先对右孩子进行一次右旋，然后再对失衡节点进行一次左旋。</li>
<li><strong>插入</strong>结点后如果导致多个祖先结点失衡，只需调整距离插入结点最近的失衡结点，其他失衡结点会自然平衡。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-红黑树和-avl-树的差异">(5) 红黑树和 AVL 树的差异</h3>
<p>虽然红黑树和 AVL 树都是自平衡二叉搜索树，保证 O(logn) 的操作时间，但它们在平衡策略、性能特性和实现复杂度上有所不同：</p>
<ul>
<li>平衡的严格程度:
<ul>
<li>AVL 树: <strong>更严格地平衡</strong>。它要求任何节点的左右子树高度差最多为 1。</li>
<li>红黑树: 平衡性相对宽松。它通过颜色属性确保最长路径不超过最短路径的两倍，但不直接限制左右子树的高度差。因此，红黑树可能没有 AVL 树那么“扁平”。</li>
</ul>
</li>
<li>树的高度:
<ul>
<li>AVL 树: 由于更严格的平衡，其最大高度通常比红黑树更接近理论最小值 (≈logn)。</li>
<li>红黑树: 最大高度可能略高于 AVL 树 (≈2log(n+1))。</li>
</ul>
</li>
<li>查找操作性能:
<ul>
<li>AVL 树: 因为树的高度通常更低，查找操作的平均和最坏情况下的比较次数可能更少，因此理论上查找速度略快。</li>
<li>红黑树: 查找也是 O(logn)，但常数因子可能略大于 AVL 树。</li>
</ul>
</li>
<li>插入和删除操作性能:
<ul>
<li>AVL 树: 为了维持其严格的平衡条件，AVL 树在插入和删除时可能需要进行<strong>多次旋转</strong>（最坏情况下是 O(logn) 次旋转，但通常是一次或两次）。</li>
<li>红黑树: 插入操作最多需要两次旋转，删除操作最多需要三次旋转。颜色翻转操作非常快。因此，<strong>红黑树的插入和删除操作通常比 AVL 树更快，尤其是在写操作频繁的场景下</strong>。</li>
</ul>
</li>
<li>实际应用:
<ul>
<li>红黑树: 由于其插入和删除操作的良好性能（尤其是较少的旋转次数），在实际中应用更为广泛。例如，C++ STL 中的 std::map, std::set, std::multimap, std::multiset 通常是用红黑树实现的。Java 中的 TreeMap 和 TreeSet 也是。</li>
<li>AVL 树: 在<strong>查找密集型</strong>且修改较少的应用中可能更有优势。但在通用库中的普及程度不如红黑树。</li>
</ul>
</li>
</ul>
<h2 id="32-函数指针">32. 函数指针</h2>
<ul>
<li>
<p>函数指针 (Function Pointer) 是一个<strong>指向内存中特定函数起始地址</strong>的指针变量。就像数据指针存储变量的内存地址一样，函数指针存储的是某个函数的入口点（即其第一条指令的地址）。可用于：</p>
<ul>
<li>将函数作为参数传递给其他函数（例如回调函数）。例如，GUI 事件处理器、排序算法中的比较函数、异步任务完成时的通知函数。</li>
<li>将函数存储在数据结构中（例如数组或映射）。虚函数表就类似一个存储虚函数指针的数组。</li>
<li>在运行时动态地决定调用哪个函数。</li>
<li>从函数返回函数。</li>
</ul>
</li>
<li>
<p><strong>声明</strong>:<br>
声明一个函数指针需要指定它所指向的函数的<strong>返回类型</strong>和<strong>参数列表类型</strong>。<br>
语法格式：<br>
<code>return_type (*pointer_name)(parameter_type1, parameter_type2, ...);</code></p>
<ul>
<li><code>return_type</code>: 被指向函数的返回类型。</li>
<li><code>(*pointer_name)</code>: <code>pointer_name</code> 是函数指针变量的名称。这里的括号 <code>()</code> 至关重要，它确保了 <code>*</code> 操作符优先与 <code>pointer_name</code> 结合，表明这是一个指针。如果没有括号，例如 <code>return_type *pointer_name(...)</code>，则会被解释为一个返回 <code>return_type*</code> 类型的普通函数声明。</li>
<li><code>(parameter_type1, parameter_type2, ...)</code>: 被指向函数的参数类型列表。</li>
<li>示例:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-built_in">double</span> (*mathOp)(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><strong>使用 <code>typedef</code> 或 <code>using</code> 简化声明</strong>：函数指针的声明语法可能显得冗长和不直观。使用 <code>typedef</code> (C 风格) 或 <code>using</code> (C++11 及以后) 可以<strong>创建类型别名</strong>，提高代码的可读性和可维护性。
<ul>
<li><strong>使用 <code>typedef</code></strong>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*IntOperationCallback)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>IntOperationCallback addCallback; <span class="hljs-comment">// addCallback 是一个函数指针</span><br></code></pre></td></tr></table></figure>
</li>
<li><strong>使用 <code>using</code> (更推荐的现代 C++ 做法)</strong>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> DoubleMathFunc = <span class="hljs-built_in">double</span> (*)(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>);<br>DoubleMathFunc multiplyFunc; <span class="hljs-comment">// multiplyFunc 是一个函数指针</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>初始化与赋值</strong>:</p>
<ul>
<li>可以直接使用函数名（函数名在多数表达式中会自动“衰变”为指向该函数的指针）：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 实现 ...</span><br>&#125;<br>funcPtr = my_function; <span class="hljs-comment">// 将 my_function 的地址赋给 funcPtr</span><br></code></pre></td></tr></table></figure>
</li>
<li>也可以显式使用取地址符 <code>&amp;</code> (虽然通常不是必需的)：<code>funcPtr = &amp;my_function;</code></li>
<li>赋值的函数其返回类型和参数列表必须与函数指针声明的类型完全匹配</li>
</ul>
</li>
<li>
<p><strong>调用</strong>:</p>
<ul>
<li><strong>显式解引用 (C 风格)</strong>:<code>(*funcPtr)(10, 20); // 解引用指针，然后调用函数</code></li>
<li><strong>隐式解引用 (C++ 中更常见)</strong>:<code>funcPtr(10, 20);    // 直接像函数名一样使用指针</code></li>
</ul>
</li>
<li>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 目标函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">greet</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br><span class="hljs-comment">// 使用 typedef 定义函数指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*ArithmeticFunc)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 声明并初始化函数指针 greetPtr</span><br>    <span class="hljs-built_in">void</span> (*greetPtr)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*);<br>    greetPtr = greet; <span class="hljs-comment">// 或 greetPtr = &amp;greet;</span><br><br>    <span class="hljs-comment">// 通过函数指针调用 greet</span><br>    <span class="hljs-built_in">greetPtr</span>(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 输出: Hello, World!</span><br>    (*greetPtr)(<span class="hljs-string">&quot;Universe&quot;</span>); <span class="hljs-comment">// 输出: Hello, Universe!</span><br><br>    <span class="hljs-comment">// 使用 typedef 声明的函数指针</span><br>    ArithmeticFunc operation;<br><br>    operation = add;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Addition: &quot;</span> &lt;&lt; <span class="hljs-built_in">operation</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Addition: 15</span><br><br>    operation = subtract;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Subtraction: &quot;</span> &lt;&lt; <span class="hljs-built_in">operation</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Subtraction: 5</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>与 <code>std::function</code> 的比较 (现代 C++)</strong></p>
<p>在 C++11 及更高版本中，标准库提供了 <code>std::function</code> (在 <code>&lt;functional&gt;</code> 头文件中)，它是一个<strong>更通用、类型安全</strong>的多态函数包装器。</p>
</li>
<li>
<p>类型安全：<code>std::function</code> 会在编译时检查可调用对象的签名是否匹配</p>
</li>
<li>
<p>通用性：<code>std::function</code> 可以存储</p>
<ul>
<li>普通函数指针</li>
<li>Lambda 表达式</li>
<li>函数对象 (Functors)</li>
<li>指向成员函数的指针 (配合 <code>std::bind</code> 或 lambda)</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func = add; <span class="hljs-comment">// 存储普通函数</span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;; <span class="hljs-comment">// 存储 lambda 表达式</span><br><span class="hljs-comment">// 使用 std::bind 可以将函数的参数部分绑定，生成一个新的可调用对象</span><br><span class="hljs-keyword">auto</span> bound_func = std::<span class="hljs-built_in">bind</span>(add, std::placeholders::_1, <span class="hljs-number">3</span>);<br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; func = bound_func; <span class="hljs-comment">// 存储绑定表达式</span><br>Calculator calc;<br><span class="hljs-comment">// 存储成员函数指针</span><br>std::function&lt;<span class="hljs-type">int</span>(Calculator*, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func = &amp;Calculator::add;<br></code></pre></td></tr></table></figure>
</li>
<li>函数指针只能固定签名，无法动态替换,<code>std::function</code>可以动态替换存储的可调用对象；函数指针不支持复制，<code>std::function</code>支持。</li>
</ul>
<p>虽然 <code>std::function</code> 带来了更大的灵活性和便利性，但它通常比原始函数指针<strong>有一定的性能开销</strong>（因为它可能需要在堆上分配内存或进行虚函数调用）。<code>std::function</code> 在未绑定任何可调用对象时调用会引发未定义行为，需通过 if (func) 检查是否为空。原始函数指针在性能要求极高或与 C 代码交互时仍有其用武之地。</p>
</li>
<li>
<p><strong>指向成员函数的指针</strong></p>
<p>值得注意的是，指向类的<strong>非静态成员函数</strong>的指针与上面讨论的普通函数指针是不同的，因为它们需要一个类的实例来调用（即需要 <code>this</code> 指针）。例如：<code>int (MyClass::*memberFuncPtr)(int);</code>。</p>
</li>
</ul>
<h1 id="计算机网络">计算机网络</h1>
<h2 id="1-osi-七层协议模型">1. OSI 七层协议模型</h2>
<p>国际标准化组织（ISO）提出的网络通信模型，用来描述网络系统中通信的分层结构，使得不同厂商设备或系统之间可以实现互联互通。</p>
<ul>
<li>
<p>七层结构从上到下</p>
<ul>
<li>每一层 <strong>只与上下两层通信</strong>，实现“模块化设计”</li>
<li>下层为上层提供服务，上层使用下层服务</li>
<li>每层协议通过“协议数据单元（PDU）”交换数据</li>
</ul>
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
<th>功能简述</th>
<th>对应现实中的例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层 Application</td>
<td>用户交互、服务接口（如 HTTP、FTP）</td>
<td>浏览器、邮件客户端</td>
</tr>
<tr>
<td>6</td>
<td>表示层 Presentation</td>
<td>数据编码/解码、加密/解密、压缩/解压</td>
<td>SSL/TLS、JPEG、MP3 编码</td>
</tr>
<tr>
<td>5</td>
<td>会话层 Session</td>
<td>会话管理、连接建立与断开、同步控制</td>
<td>RPC、会话恢复、数据库连接池</td>
</tr>
<tr>
<td>4</td>
<td>传输层 Transport</td>
<td>可靠传输、分段重组、流量控制</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>3</td>
<td>网络层 Network</td>
<td>路由、寻址、路径选择</td>
<td>IP、ICMP、路由器</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层 Data Link</td>
<td>成帧、错误检测、MAC 地址识别</td>
<td>以太网、ARP、交换机</td>
</tr>
<tr>
<td>1</td>
<td>物理层 Physical</td>
<td>比特流传输、物理信号、接口标准</td>
<td>网线、电压、电流、调制解调器</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>封装与解封装</p>
<ul>
<li>封装：发送方 向下封装，每层加头部（header）</li>
<li>解封装：接收 方向上解封装，逐层解析头部信息</li>
</ul>
<p>例如发送网页请求：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">HTTP</span>数据<br>↓（加HTTP头）应用层<br>↓（加TLS头） 表示层<br>↓（加TCP头） 传输层<br>↓（加<span class="hljs-built_in">IP</span>头）  网络层<br>↓（加MAC头） 数据链路层<br>↓ 比特流      物理层<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>与现实协议栈的关系</p>
</li>
<li>
<p>OSI 是教学用模型，实际使用的是 TCP/IP 四层模型：</p>
<table>
<thead>
<tr>
<th>TCP/IP 层级</th>
<th>映射到 OSI 层级</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>应用层 + 表示层 + 会话层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>网络接口层（链路）</td>
<td>数据链路层 + 物理层</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="2-tcp-和-udp-原理和区别">2. TCP 和 UDP 原理和区别</h2>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-tcp-%E5%8D%8F%E8%AE%AE-tcp-%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#为什么需要-tcp-协议-tcp-工作在哪一层</a><br>
<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#udp-%E5%92%8C-tcp-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2-%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#udp-和-tcp-有什么区别呢-分别的应用场景是</a><br>
<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#为什么是三次握手-不是两次、四次</a></p>
<ul>
<li>
<p>TCP（Transmission Control Protocol）</p>
<ul>
<li>原理：TCP 是一种<strong>面向连接、可靠、有序、基于字节流</strong>的传输协议。</li>
<li>工作机制：
<ul>
<li><strong>三次握手建立连接</strong>（三-way handshake）：
<ul>
<li>客户端发送 SYN</li>
<li>服务端回复 SYN-ACK</li>
<li>客户端回复 ACK</li>
</ul>
</li>
<li><strong>有序传输</strong>：数据按顺序编号，接收方按序重组</li>
<li><strong>可靠传输</strong>：
<ul>
<li>确认机制（ACK）</li>
<li>重传机制（超时/丢包自动重发）</li>
</ul>
</li>
<li><strong>流量控制</strong>：根据接收方处理能力调整发送速率（窗口大小）</li>
<li><strong>拥塞控制</strong>：避免网络拥堵（慢启动、拥塞避免等）</li>
<li><strong>四次挥手关闭连接</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>UDP（User Datagram Protocol）</p>
<ul>
<li>原理：UDP 是一种**无连接、不可靠、无序、基于报文（数据报）**的传输协议。</li>
<li>特点：
<ul>
<li><strong>不建立连接</strong>，发送即发（无需握手）</li>
<li><strong>每个报文独立</strong>，顺序和可靠性不保证</li>
<li><strong>无确认、无重传</strong>，但传输开销小，速度快</li>
<li><strong>适用于实时、丢包容忍的场景</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>对比总结</p>
<ul>
<li>TCP 是面向连接、可靠、有序的传输协议，适用于数据完整性要求高的场景；</li>
<li>UDP 是无连接、不可靠、快速的协议，适用于实时性要求高、对丢包容忍的场景。它们各自权衡了通信效率与传输保障。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接导向</td>
<td>是（需三次握手）</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是（有 ACK + 重传）</td>
<td>否（无确认、无重传）</td>
</tr>
<tr>
<td>是否有序</td>
<td>是（顺序编号 + 重组）</td>
<td>否</td>
</tr>
<tr>
<td>是否面向字节流</td>
<td>是（连续数据流）</td>
<td>否（基于独立数据报）</td>
</tr>
<tr>
<td>头部开销</td>
<td>大（20 字节以上）</td>
<td>小（仅 8 字节）</td>
</tr>
<tr>
<td>是否有流量控制</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>是否有拥塞控制</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>适合场景</td>
<td>文件传输、网页、邮件、SSH</td>
<td>音视频流、DNS、在线游戏、语音通话</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="3-moba-设计-udp-tcp-的选择">3. moba 设计 UDP TCP 的选择</h2>
<ul>
<li>moba 的通信需求
<ul>
<li>低延迟：操作需尽快生效（移动、技能施放、打断等）</li>
<li>高频次小包：每秒多次发送/接收状态、位置信息</li>
<li>丢包容忍：丢 1~2 帧状态包没关系，后续帧能纠正</li>
<li>状态过时即无效：不需要补发旧包，比如“移动到旧位置”</li>
<li>有些数据必须可靠：聊天、选人阶段、房间同步、游戏开始、重连等</li>
</ul>
</li>
</ul>
<p>因此，MOBA 游戏大多采用 UDP 作为主通信协议，以获得低延迟、高并发性能，并通过应用层补偿机制（如状态预测、丢包恢复）提升容错性；对于聊天、登录等可靠性要求高的非实时场景，则使用 TCP 或辅助可靠通道。</p>
<ul>
<li>双通道设计
<ul>
<li>一个 TCP 连接用于登录/聊天/选人</li>
<li>一个 UDP 连接用于游戏数据同步</li>
<li>各自在独立端口/线程中处理</li>
</ul>
</li>
<li>只用 UDP + 自定义可靠协议</li>
</ul>
<h2 id="4-tcp-粘包">4. TCP 粘包</h2>
<h2 id="5-可靠-udp-的实现思路">5. 可靠 UDP 的实现思路</h2>
<h2 id="6-https-和-http-区别">6. https 和 http 区别</h2>
<h1 id="操作系统">操作系统</h1>
<h2 id="1-线程和进程区别">1. 线程和进程区别</h2>
<ul>
<li>进程（Process）：
<ul>
<li>程序在操作系统中独立运行的基本单位</li>
<li>是资源分配和保护的最小单位</li>
<li>拥有独立的地址空间、代码段、堆、栈、文件描述符等资源</li>
<li>一个进程崩溃不影响其他进程</li>
<li>通信方式使用 IPC（管道、消息队列、共享内存）</li>
</ul>
</li>
<li>线程（Thread）：
<ul>
<li>是进程内的执行单元</li>
<li>是程序执行调度的最小单位</li>
<li>同一进程内的多个线程共享地址空间和资源<br>
同一进程的多个线程共享以下内容：
<ul>
<li>代码段（.text）</li>
<li>全局变量和堆空间</li>
<li>文件描述符</li>
<li>当前工作目录、用户 ID 等<br>
而每个线程有自己独立的：</li>
<li>栈（stack）</li>
<li>程序计数器（PC）</li>
<li>寄存器上下文</li>
<li>线程 ID</li>
</ul>
</li>
<li>一个线程崩溃可能导致整个进程崩溃</li>
<li>使用共享内存，通信简单高效</li>
<li>线程并发性较高 （切换开销小）</li>
</ul>
</li>
</ul>
<h2 id="2-线程进程通讯及切换原理">2. 线程/进程通讯及切换原理</h2>
<ul>
<li>
<p>进程间通信需依赖内核机制（如管道、消息队列、共享内存），线程间通信则通过共享内存 + 同步机制实现；</p>
</li>
<li>
<p>进程切换涉及地址空间与页表切换，开销大；线程切换无需切换地址空间，开销较小，调度更高效。</p>
</li>
<li>
<p>进程通信（Inter-Process Communication, IPC）</p>
<p>由于进程之间<strong>地址空间隔离</strong>，所以通信必须通过<strong>内核中介</strong>进行，常见方式包括：</p>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>原理简述</th>
<th>特点与用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道（pipe）</td>
<td>内核维护一段缓存区，单向传输数据</td>
<td>父子进程通信，简单，但不支持命名</td>
</tr>
<tr>
<td>命名管道（FIFO）</td>
<td>支持非亲缘进程间通信</td>
<td>基于文件系统</td>
</tr>
<tr>
<td>消息队列</td>
<td>内核维护一个消息链表，进程可发送/接收消息</td>
<td>支持异步通信，效率高</td>
</tr>
<tr>
<td>共享内存</td>
<td>多个进程映射同一物理内存段</td>
<td>最快，但需加锁处理同步</td>
</tr>
<tr>
<td>信号</td>
<td>内核向进程发送中断通知</td>
<td>适合处理控制类事件</td>
</tr>
<tr>
<td>套接字（socket）</td>
<td>基于网络协议，支持跨主机通信</td>
<td>网络服务程序或本地全双工通信</td>
</tr>
</tbody>
</table>
<p>这些方式都是由操作系统内核提供的数据结构或系统调用支持实现的。</p>
</li>
<li>
<p>线程通信（Intra-Process Communication）</p>
<p>线程之间共享同一地址空间，通信方式比进程更轻量：</p>
<ul>
<li>共享全局变量、堆对象</li>
<li>不需要内核参与，通信开销小</li>
<li>但需要手动<strong>加锁同步</strong>，如使用：</li>
</ul>
<table>
<thead>
<tr>
<th>同步机制</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥锁（mutex）</td>
<td>保证同一时刻只有一个线程访问资源</td>
</tr>
<tr>
<td>条件变量</td>
<td>用于线程间通知与等待</td>
</tr>
<tr>
<td>读写锁</td>
<td>允许多个读者或一个写者</td>
</tr>
<tr>
<td>信号量</td>
<td>计数同步机制</td>
</tr>
<tr>
<td>原子操作（atomic）</td>
<td>硬件层面无锁同步</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>上下文切换</p>
<p>上下文切换（Context Switching）是操作系统<strong>在不同任务之间切换</strong>的一种机制，用于使<strong>多个任务（如进程或线程）之间共享处理器资源</strong>，以便实现多任务处理和资源的高效利用。</p>
<ul>
<li>
<p>上下文切换的过程</p>
</li>
<li>
<p><strong>保存当前任务的上下文</strong> ：当操作系统决定将处理器从一个任务切换到另一个任务时，会首先保存当前正在运行任务的状态。这包括程序计数器（PC）、寄存器、堆栈指针和其他相关状态信息。这些信息被称为任务的 “上下文”。</p>
</li>
<li>
<p><strong>恢复目标任务的上下文</strong> ：操作系统然后加载目标任务的上下文，包括恢复其程序计数器、寄存器和堆栈指针等。这样，目标任务就可以从上次被中断的地方继续执行。</p>
</li>
<li>
<p><strong>切换任务</strong> ：完成上下文保存和加载后，处理器开始执行目标任务。</p>
</li>
<li>
<p>上下文切换的作用</p>
<ul>
<li><strong>多任务处理</strong> ：允许计算机同时运行多个任务，通过在任务之间快速切换，使用户感觉多个任务在同时进行。</li>
<li><strong>资源分配</strong> ：操作系统可以根据任务的优先级和需求，合理分配处理器时间，确保重要任务能够及时得到处理。</li>
<li><strong>响应能力</strong> ：通过上下文切换，操作系统可以在不同任务之间快速切换，确保系统对用户输入和外部事件的响应能力。</li>
</ul>
</li>
<li>
<p>上下文切换的开销</p>
<ul>
<li><strong>时间开销</strong> ：保存和恢复任务的上下文需要一定的时间，这会增加系统的总体延迟。</li>
<li><strong>内存开销</strong> ：每个任务的上下文需要在内存中存储，这会占用一定的内存资源。</li>
<li><strong>缓存一致性维护</strong> ：在多核处理器中，上下文切换可能导致缓存不一致问题，需要额外的处理来确保数据的一致性。</li>
</ul>
</li>
<li>
<p>进程切换步骤</p>
<ul>
<li>保存当前进程的<strong>上下文信息</strong>（寄存器、PC、栈指针、页表信息等）</li>
<li>更新内核调度器的数据结构（如就绪队列）</li>
<li>切换页目录（地址空间切换）</li>
<li>恢复目标进程上下文</li>
<li>切换内核栈、用户栈，加载目标程序继续执行</li>
</ul>
</li>
</ul>
<p>由于地址空间、页表和资源都要切换，<strong>进程切换开销大</strong>。</p>
<ul>
<li>线程切换步骤（同进程内）
<ul>
<li>不需要切换页表（地址空间不变）</li>
<li>只切换寄存器、程序计数器、栈指针等</li>
<li>若是内核线程，则仍需陷入内核调度；若是用户线程（如协程），可在用户空间调度</li>
</ul>
</li>
</ul>
<p>相比进程切换，<strong>线程切换开销更小、更快</strong>。</p>
</li>
</ul>
<h2 id="3-协程">3. 协程</h2>
<p>协程：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RctE_ApJnLHnmEtnrT7OEw">https://mp.weixin.qq.com/s/RctE_ApJnLHnmEtnrT7OEw</a></p>
<ol start="4">
<li>
<p>两个函数同一个地址执行问题</p>
</li>
<li>
<p>内存中堆栈，数据区哪里读取快</p>
</li>
</ol>
<h2 id="6-虚拟内存">6. 虚拟内存</h2>
<h3 id="1-什么是虚拟内存">(1) 什么是虚拟内存</h3>
<p>虚拟内存是操作系统提供的一种<em>内存管理技术</em>。它为每个正在运行的<strong>进程</strong>（程序）创建了一个<strong>假象</strong>，即该进程拥有一个<strong>巨大的、连续的、私有/独立的内存空间</strong>，这个空间被称为虚拟地址空间 (Virtual Address Space)。实际上，这个虚拟地址空间可能<strong>远大于</strong>计算机实际拥有的物理内存（RAM）。</p>
<p>核心思想是：</p>
<ul>
<li>地址分离：程序使用的是虚拟地址，而实际的硬件内存（RAM）使用的是物理地址。</li>
<li>按需映射：操作系统和 CPU 中的硬件单元（主要是内存管理单元 - MMU (Memory Management Unit)）负责将程序使用的虚拟地址动态地映射到物理内存中的实际物理地址。</li>
<li>部分加载：并非程序的所有部分都需要同时驻留在物理内存中。只有当前活跃的部分（例如，正在执行的代码、正在访问的数据）才需要加载到 RAM 中。不常用的部分可以存放在速度较慢但容量更大的二级存储设备上（如硬盘或 SSD）。</li>
<li>分页机制：
<ul>
<li>虚拟地址空间被划分为<strong>固定大小的块，称为页</strong> (Page)。</li>
<li>物理内存也被划分为相同大小的块，称为页框 (Page Frame) 或物理页。</li>
<li>操作系统<strong>为每个进程维护一个页表</strong> (Page Table)，用于<strong>记录虚拟页到物理页框的映射关系</strong>，或者标记某个虚拟页当前存储在磁盘上的位置。</li>
</ul>
</li>
</ul>
<h3 id="2-为什么需要虚拟内存">(2) 为什么需要虚拟内存</h3>
<ul>
<li>允许运行大于物理内存的程序：这是最直接的好处。如果一个程序需要的内存超过了可用的 RAM，虚拟内存系统可以将程序中暂时不用的部分（页）存储在磁盘上（这个过程称为换出 (swapping out) 或分页到磁盘 (paging to disk)）。当需要这些数据时，再将其从磁盘调入内存（换入 (swapping in) 或缺页调入 (demand paging)）。这使得用户可以运行非常大的应用程序，或者同时运行更多的应用程序，而不会因为物理内存不足而受限。</li>
<li>内存保护和隔离：<strong>每个进程都有自己独立的虚拟地址空间</strong>。这意味着一个进程看到的地址 0x1000 和另一个进程看到的地址 0x1000 映射到的是物理内存中完全不同的位置（或者一个在内存，一个在磁盘）。这种隔离机制可以<strong>防止一个进程意外或恶意地访问或修改另一个进程的内存数据</strong>，或者操作系统的核心数据。这极大地提高了系统的稳定性和安全性。如果一个程序崩溃，它通常不会影响到其他正在运行的程序或操作系统本身。</li>
<li>简化程序员的内存管理：<strong>物理内存往往是不连续的</strong>，因为硬件设备可能占用部分物理内存地址空间，或者由于内存碎片等原因。在没有虚拟内存时，程序员需要考虑物理内存的不连续性，这使得程序的编写和内存分配变得复杂。虚拟内存可以将物理内存中的不连续存储空间映射为虚拟内存中的连续地址空间。程序员在编写程序时，可以假设自己拥有一个巨大且连续的地址空间，而不必关心物理内存的实际大小、碎片情况，或者其他程序正在使用哪些内存。链接器和加载器也因此变得简单，因为程序可以在编译时假设一个标准的起始地址，实际加载到物理内存的哪个位置由操作系统在运行时决定和映射。例如，一个程序可能需要 100MB 的连续内存来存储一个大型数组。在物理内存中，可能没有 100MB 的连续空间，但通过虚拟内存，系统可以将分散在物理内存中的多个小块内存空间组合起来，映射成一个连续的虚拟内存区域提供给程序使用。这样程序员就可以像操作连续内存一样来操作这个虚拟内存区域，而无需关心物理内存的实际情况。</li>
<li>高效、公平地共享物理内存：多个进程可以并发运行，它们的虚拟页根据需要映射到可用的物理页框。操作系统可以只将每个进程当前“工作集”（最活跃的页）保留在 RAM 中，从而让有限的物理内存得到高效利用。操作系统可以使用各种页面替换算法（如 LRU - 最近最少使用）来决定当内存不足时哪些页应该被换出到磁盘，以优化整体系统性能。</li>
<li>支持共享内存：虽然默认情况下进程的地址空间是隔离的，但虚拟内存机制也允许不同进程的虚拟地址空间中的某些页映射到相同的物理内存页框。这使得进程间可以高效地共享数据和代码。例如，动态链接库 (DLLs 或 .so 文件) 的代码段可以在物理内存中只存储一份，然后被映射到多个使用该库的进程的虚拟地址空间中，节省了内存。</li>
<li>高效的文件 I/O：虚拟内存允许将文件或文件的一部分直接映射到进程的虚拟地址空间中。当程序访问这些映射的内存区域时，操作系统会自动处理从磁盘读取数据到内存，或将修改写回磁盘。这简化了文件操作，并且在某些情况下比传统的读写操作更高效。</li>
<li>程序重定位：由于程序使用的是虚拟地址，并且这些虚拟地址是通过页表动态映射到物理地址的，所以程序可以被加载到物理内存的任何可用位置，而无需修改程序代码中的地址引用。</li>
</ul>
<h3 id="3-虚拟内存工作流程">(3) 虚拟内存工作流程</h3>
<p>当 CPU 执行一条指令需要访问某个虚拟地址时：</p>
<p>MMU 会查找页表，尝试将该虚拟地址转换为物理地址；</p>
<ul>
<li>如果页表中对应的虚拟页当前就在物理内存中（即映射有效），MMU 就完成地址转换，CPU 继续访问物理内存。</li>
<li>如果页表中指示该虚拟页不在物理内存中（可能它从未被加载，或者已被换出到磁盘），就会发生一个缺页异常 (Page Fault)。<br>
操作系统接管缺页异常处理：<br>
找到一个空闲的物理页框。如果找不到，就根据页面替换算法选择一个当前在内存中的页将其换出到磁盘；<br>
将目标虚拟页从磁盘加载到选定的物理页框中；<br>
更新页表，建立新的虚拟页到物理页框的映射；<br>
重新执行导致缺页的指令。此时，由于页已在内存中，访问会成功。</li>
</ul>
<h3 id="4-malloc-出来的内存">(4) malloc 出来的内存</h3>
<ul>
<li>位置 ：malloc 出来的内存是在虚拟内存中分配的。</li>
<li>映射到物理内存 ：虽然虚拟内存提供了逻辑上的连续地址空间，但这些虚拟地址需要映射到物理内存或磁盘上的实际存储位置。当程序访问通过 malloc 分配的内存时，操作系统会通过内存管理单元（MMU）将虚拟地址转换为物理地址。如果物理内存不足，操作系统可能会将部分数据交换到磁盘上的交换空间（swap space）。</li>
<li>内存分配机制 ：malloc 是 C/C++ 中的一个内存分配函数，它从程序的堆（heap）中分配内存。堆是虚拟地址空间的一部分，由操作系统管理，用于动态内存分配。</li>
</ul>
<h3 id="5-虚拟内存的分配机制">(5) 虚拟内存的分配机制</h3>
<ul>
<li>
<p><strong>进程虚拟地址空间 (VAS) 的初始化与布局</strong></p>
<ul>
<li>当一个进程被创建时，操作系统会为其分配一个巨大且独立的<strong>虚拟地址空间</strong>。这个空间的大小通常由 CPU 架构决定（例如，32 位系统上是 4GB，64 位系统上则大得多，如 256TB 或更大，尽管实际可用的会受操作系统限制）。</li>
<li>这个虚拟地址空间并不是一块“空白”的区域，操作系统会预先设定其大致的布局结构，通常包括：
<ul>
<li><strong>代码段 (Text Segment)</strong>：存放程序的可执行指令，通常是<strong>只读</strong>的。</li>
<li><strong>全局区（Global Area）/静态存储区</strong>：存放全局变量和静态变量，程序运行结束操作系统自动释放（生命周期：从程序开始到结束）。
<ul>
<li>已初始化的全局/静态变量（Data Segment）</li>
<li>未初始化的全局/静态变量（Block Started by Symbol, BSS 段）,这些变量在程序加载时会被初始化为零</li>
</ul>
</li>
<li><strong>常量存储区</strong>：存放的是<strong>常量</strong>（const），不允许修改，程序运行结束自动释放。全局常量、字符串常量（.rodata 常量区）（虚函数表存储在这里）</li>
<li><strong>堆 (Heap)</strong>：用于动态内存分配（例如，通过 C++ 的 <code>new</code> 或 C 的 <code>malloc</code> 分配的内存）。堆通常<strong>从低地址向高地址增长</strong>。</li>
<li><strong>栈 (Stack)</strong>：用于存储<strong>函数调用的局部变量、返回地址和函数参数</strong>。<strong>每个线程都有自己的栈，通常从高地址向低地址增长</strong>。</li>
<li><strong>内存映射区域 (Memory-Mapped Region)</strong>：用于加载动态链接库 (共享库)、内存映射文件等。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>虚拟地址范围的“预留”与“提交”</strong><br>
当程序请求分配内存时（例如，<code>new</code> 一个对象，或者 <code>malloc</code> 一块内存），通常发生的是以下情况：</p>
<ul>
<li><strong>预留 (Reserve) 虚拟地址</strong> (开销较小)：
<ul>
<li>首先，操作系统（或用户态内存管理器）会在进程的虚拟地址空间中找到一块足够大的、未被占用的连续虚拟地址范围，并将这个范围<strong>标记</strong>为“已预留”给该次分配。</li>
<li>这个阶段<strong>通常不涉及物理内存的实际分配</strong>。仅仅是在进程的虚拟内存布局图中“画了一块地”，说明这块虚拟地址以后可能会被使用。这个操作相对轻量，主要是更新操作系统内核中管理进程虚拟内存的数据结构（如 Linux 中的 <code>vm_area_struct</code> 或 Windows 中的 Virtual Address Descriptors - VADs）。</li>
</ul>
</li>
<li><strong>提交 (Commit) 内存</strong>（开销较大）：
<ul>
<li>当程序<strong>实际访问</strong>（通常是写入）预留的虚拟地址范围中的某个页面时，如果该虚拟页面尚未映射到物理内存，就会触发一个<strong>缺页异常 (Page Fault)</strong>。</li>
<li>此时，操作系统才会介入，执行以下操作：
<ul>
<li>分配一个<strong>物理内存页框 (Physical Page Frame)</strong>。</li>
<li>如果需要（例如，对于 BSS 段或堆上的新页面），将该物理页框清零。</li>
<li>更新进程的<strong>页表 (Page Table)</strong>，建立该虚拟页面到新分配的物理页框的映射关系。</li>
<li>重新执行导致缺页的指令。</li>
</ul>
</li>
</ul>
<ul>
<li>这个将虚拟页面与物理存储（RAM 或磁盘上的页面文件/交换空间）关联起来的过程称为“提交内存”。操作系统会跟踪已提交内存的总量（Commit Charge），确保不超过系统（物理内存 + 页面文件总大小）的承载能力。只有提交的内存才真正占用了物理资源。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>按需分配物理资源</strong></p>
<p>物理内存页框和磁盘上的交换空间（用于存储被换出的页面）<strong>只有在虚拟页面被实际访问时</strong>才会被分配和映射。</p>
<ul>
<li><strong>节省物理内存</strong>：程序可以预留大量虚拟地址空间，但只有实际用到的部分才会消耗物理内存。</li>
<li><strong>启动速度快</strong>：程序启动时不需要将所有代码和数据都加载到内存中。</li>
</ul>
</li>
<li>
<p><strong>不同区域的分配特点</strong></p>
<ul>
<li><strong>堆分配</strong>：
<ul>
<li><strong>用户态</strong>的内存分配器（如 <code>glibc</code> 中的 <code>ptmalloc</code>，C++ 的 <code>new</code> 操作符底层通常也依赖这类分配器）负责管理堆区域。</li>
<li>当应用程序通过 <code>malloc</code> 或 <code>new</code> 请求内存时，分配器首先尝试从已经向操作系统申请并管理的一块或多块大的<strong>虚拟内存</strong>区域（称为 arenas 或 heaps）中分配一小块。</li>
<li>如果现有区域不足，分配器会通过系统调用（如 <code>brk</code>/<code>sbrk</code>（较旧）或 <code>mmap</code>（更现代、更灵活））向操作系统申请扩大堆的虚拟地址范围（预留更多虚拟地址）。</li>
<li>实际的物理内存分配仍然遵循按需分页的原则。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>栈分配</strong>：</p>
<ul>
<li>栈空间通常在线程创建时分配一个初始的虚拟地址范围。</li>
<li>栈的增长通常是自动的（由 CPU 在函数调用时压栈实现）。如果超出了已分配（并提交）的栈区域，会触发一个特殊的缺页（栈溢出保护页），操作系统可能会尝试扩展栈的虚拟地址范围（如果未达到上限），或者终止程序。</li>
</ul>
</li>
<li>
<p><strong>内存映射文件和共享内存</strong>：</p>
<ul>
<li>使用 <code>mmap</code> (Linux/Unix) 或 <code>CreateFileMapping</code>/<code>MapViewOfFile</code> (Windows) 这类系统调用时，操作系统会在进程的虚拟地址空间中预留一段地址范围，并将其与文件或共享内存对象关联起来。</li>
<li>当访问这些虚拟地址时，数据会按需从文件或共享内存对象中加载到物理内存页框。</li>
</ul>
</li>
<li>
<p><strong>内存的释放</strong></p>
<ul>
<li>当程序通过 <code>free</code> 或 <code>delete</code> 释放堆内存时：
<ul>
<li>用户态内存分配器会将这块内存<strong>标记为可用</strong>，并可能在内部进行合并，以供后续分配。</li>
<li>分配器<strong>不一定会立即将这块虚拟地址范围归还给操作系统</strong>，除非积累了足够大的连续空闲块。</li>
</ul>
</li>
<li>当通过 <code>munmap</code> (Linux/Unix) 或 <code>UnmapViewOfFile</code> (Windows) 解除内存映射，或者进程终止时：
<ul>
<li>操作系统会回收相应的虚拟地址范围，使其在进程的虚拟地址空间中变为未分配状态。</li>
<li>相关的页表项会被清除。</li>
<li>这些虚拟页面之前占用的物理页框会根据情况被释放：
<ul>
<li>如果页面是“脏”的（被修改过）并且是匿名页面（如堆、栈），其内容可能需要先被写入到磁盘的交换空间。</li>
</ul>
</li>
<li>如果页面是干净的，或者映射自文件且未被私有修改，则物理页框可以直接被回收利用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-共享内存的实现">(6) 共享内存的实现</h3>
<p>共享内存是一种允许两个或多个<strong>进程</strong>访问同一块物理内存区域的进程间通信 (IPC) 机制。这使得不同进程可以非常高效地交换数据，因为数据不需要在进程的地址空间之间进行复制。其实现主要依赖于操作系统内核以及 CPU 的内存管理单元 (MMU) 对虚拟内存系统的支持。正常情况下，每个进程都有其自己独立的、私有的虚拟地址空间。操作系统通过为每个进程维护不同的页表，将这些虚拟地址映射到物理内存中的不同物理页框。这种隔离是出于保护和安全的目的，防止一个进程干扰另一个进程。共享内存的目标是打破这种完全的隔离，允许某些物理内存被多个进程共同访问。操作系统在物理内存中分配一块区域作为共享段，对于每一个希望共享该内存段的进程，操作系统会在该进程的<strong>虚拟地址空间</strong>中分配一个区域，然后操作系统修改这些进程的<strong>页表</strong>，使得它们各自虚拟地址空间中的这个区域（这些虚拟地址可能各不相同）都映射到<strong>同一块共享的物理内存页框</strong>。共享内存的创建、管理和销毁完全由操作系统内核控制。进程不能自行指定或访问其他进程的私有内存。它们必须通过操作系统提供的系统调用来请求或参与共享内存。</p>
<h1 id="设计模式">设计模式</h1>
<h2 id="1-工厂模式">1. 工厂模式</h2>
<h2 id="2-单例模式">2. 单例模式</h2>
<h3 id="1-概念">(1) 概念</h3>
<ul>
<li>定义：一个类在程序运行过程中只能存在一个实例，并提供全局访问。常用于资源管理类（如日志、数据库连接池、配置管理器等）。它通过将构造函数私有化，并提供一个公共的静态方法来获取唯一实例。</li>
<li>懒汉模式 vs. 饿汉模式
<table>
<thead>
<tr>
<th>对比项</th>
<th>懒汉模式（Lazy）</th>
<th>饿汉模式（Eager）</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例创建时机</td>
<td><strong>第一次调用 <code>getInstance()</code> 时</strong> 创建</td>
<td>程序启动时（类加载时）创建</td>
</tr>
<tr>
<td>是否延迟加载</td>
<td>是（节省资源）</td>
<td>否（占资源，但初始化快）</td>
</tr>
<tr>
<td>实现难度</td>
<td>稍高，需要考虑线程安全问题</td>
<td>简单，但无条件创建实例</td>
</tr>
<tr>
<td>线程安全处理</td>
<td>需要手动加锁或使用现代 C++ 特性</td>
<td>靠静态变量初始化，天然线程安全</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="2-实现">(2) 实现</h3>
<ul>
<li>
<p>实现时需要：</p>
<ul>
<li>将构造函数和析构函数私有化（private）</li>
<li>定义一个 public 的函数用于获取唯一实例</li>
<li>手动禁用拷贝构造函数（Singleton(const Singleton&amp;)）和赋值操作符（Singleton&amp; operator=(const Singleton&amp;)）
<ul>
<li>如果没有禁用，则可以在程序运行中获得多个实例，打破了唯一性。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Singleton&amp; a = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton b = a;              <span class="hljs-comment">// 调用拷贝构造，复制一份</span><br>Singleton c;<br>c = Singleton::<span class="hljs-built_in">getInstance</span>(); <span class="hljs-comment">// 调用赋值操作符，复制一份</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>懒汉 + C++11 局部静态变量（线程安全）（Meyers Singleton - 《Effective C++》）<br>
在 C++11 及以后标准中，局部静态变量（function-local static）的初始化是线程安全的。编译器会确保<strong>只会有一个线程执行初始化代码</strong>，其它线程等待初始化完成后再访问，从而保证了懒汉式单例的线程安全性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// C++11: 线程安全的懒汉初始化</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Singleton working!\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>()  &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Constructor called\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Destructor called\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 赋值操作符</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Singleton::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">doSomething</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>饿汉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called (Eager)\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Destructor called (Eager)\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 赋值操作符</span><br>    <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// 初始化时就创建</span><br>&#125;;<br><br>Singleton Singleton::instance;  <span class="hljs-comment">// 全局初始化</span><br></code></pre></td></tr></table></figure>
<p>值得注意的是，这里类内的<code>instance</code>是静态成员变量，static 成员变量是属于类本身，不属于某个对象，所以必须 在类外部再定义一次，编译器才会真正为它分配内存。<code>static Singleton instance;</code> 是在类中声明（没有构造发生）,<code>Singleton Singleton::instance;</code> 是定义 + 初始化（调用默认构造函数）。</p>
<p>从 C++17 开始，可以在类内直接定义并初始化静态成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> Singleton instance&#123;&#125;;  <span class="hljs-comment">// 定义 + 初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>不用再写类外那行 <code>Singleton Singleton::instance;</code>，也不会再产生“看起来初始化了两次”的疑问。</p>
<p>另：懒汉模式的实现方式不同，它没有用类的 static 成员变量，而是用了<strong>函数内的 static 局部变量</strong>（生命周期和可见性都在函数内，因此不需要类外定义），两者机制完全不同。</p>
<p>另 2：饿汉模式是线程安全的，但可能存在初始化顺序问题（static initialization order fiasco）。如果 Singleton::instance 在多个翻译单元（.cpp 文件）中都被引用，可能使用还未构造的静态对象，出现未定义行为或崩溃。</p>
</li>
</ul>
<h1 id="resources">Resources:</h1>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30556448622">https://zhuanlan.zhihu.com/p/30556448622</a><br>
<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/353159115046330368">https://www.nowcoder.com/discuss/353159115046330368</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/" class="category-chain-item">Graphics</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/Interview/" class="category-chain-item">Interview</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/graphics/" class="print-no-link">#graphics</a>
      
        <a href="/tags/interview/" class="print-no-link">#interview</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Graphics Interview Review 2</div>
      <div>http://example.com/2025/04/06/interview-review2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 6, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/20/mini-ray-tracer/" title="Resources to review projects">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Resources to review projects</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/03/view-mat/" title="Understanding view matrix">
                        <span class="hidden-mobile">Understanding view matrix</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
