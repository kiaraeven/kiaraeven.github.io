

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="I initially decided to put all reviews in one blog, but as I added more and more contents, it seemd to become too long for a single blog. Therefore, I sperate the cpp part (maybe also the computer net">
<meta property="og:type" content="article">
<meta property="og:title" content="Graphics Interview Review 2">
<meta property="og:url" content="http://example.com/2025/04/05/interview-review2/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="I initially decided to put all reviews in one blog, but as I added more and more contents, it seemd to become too long for a single blog. Therefore, I sperate the cpp part (maybe also the computer net">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-05T21:07:22.060Z">
<meta property="article:modified_time" content="2025-04-14T05:39:02.434Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="graphics">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Graphics Interview Review 2 - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Graphics Interview Review 2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-05 17:07" pubdate>
          April 5, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Graphics Interview Review 2</h1>
            
            
              <div class="markdown-body">
                
                <p>I initially decided to put all reviews in one blog, but as I added more and more contents, it seemd to become too long for a single blog. Therefore, I sperate the cpp part (maybe also the computer network and os part? Let’s see if we have enough room for these two parts in this blog, or we need another new blog for them …). Anyway, let’s review cpp basics. Again, this is for interviews in Chinese, so I’ll use English only when it’s necessary.</p>
<h1 id="c-basics">C++ Basics</h1>
<h2 id="1-多态虚函数">1. 多态/虚函数</h2>
<p>虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p>
<h3 id="1-多态的定义-原理-实现">(1) 多态的定义、原理、实现</h3>
<h3 id="2-多态虚函数原理">(2) 多态虚函数原理</h3>
<h3 id="3-虚表指针什么时候产生虚函数表如何生成是和类还是对象绑定创建-10-个实例有几个虚函数表">(3) 虚表指针什么时候产生？虚函数表如何生成？是和类还是对象绑定？创建 10 个实例有几个虚函数表？</h3>
<p>1 个，虚函数表数量与实例的对象数量无关</p>
<h3 id="4-不实现虚函数会报错吗什么错">(4) 不实现虚函数会报错吗？什么错？</h3>
<h3 id="5-构建空间是否连续">(5) 构建空间是否连续</h3>
<h3 id="6-纯虚函数">(6) 纯虚函数</h3>
<h3 id="7-哪些函数不能是虚函数">(7) 哪些函数不能是虚函数</h3>
<p>构造、内联、静态成员、lamda 函数</p>
<h3 id="8-重载重写覆盖的区别子类重写了虚函数会对虚函数表有什么影响">(8) 重载重写覆盖的区别？子类重写了虚函数会对虚函数表有什么影响？</h3>
<h3 id="9-菱形继承下的类大小">(9) 菱形继承下的类大小</h3>
<h3 id="10-构造函数和析构函数能不能为虚函数">(10) 构造函数和析构函数能不能为虚函数？</h3>
<ul>
<li>构造函数不能声明为虚函数：虚函数的调用依赖于对象的虚表（vtable），而虚表的初始化是在构造函数中完成的。在构造函数执行时，对象尚未完全初始化，虚表也未完全构建。如果构造函数是虚函数，就会形成逻辑上的矛盾：虚表尚未初始化，虚函数机制无法正常工作。</li>
<li>析构函数一般声明为虚函数：析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数 或 子类析构函数未实现，则会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li>
</ul>
<h3 id="11-一个类既不继承也不是子类内部也没有虚函数那它的析构函数需要声明为虚函数吗">(11) 一个类既不继承也不是子类，内部也没有虚函数，那它的析构函数需要声明为虚函数吗？</h3>
<ul>
<li>虚析构函数是为了解决“通过基类指针删除派生类对象”时，能正确调用派生类的析构函数。</li>
<li>题述没有多态行为，也就不会通过基类指针删除派生类对象</li>
<li>使用虚析构函数的代价
<ul>
<li>虚函数会增加 vtable（虚函数表）和 vptr（虚函数指针），增加内存开销</li>
<li>调用析构函数时，会有额外的虚表查找开销。</li>
</ul>
</li>
<li>保持非虚析构函数可以减少对象大小和函数调用开销</li>
</ul>
<h2 id="2-智能指针">2. 智能指针</h2>
<h3 id="1-智能指针类型及各自原理">(1) 智能指针类型及各自原理</h3>
<h3 id="2-shared_ptr-线程安全">(2) shared_ptr 线程安全</h3>
<h3 id="3-shared_ptr-怎么实现多指针指向同一个地址">(3) shared_ptr 怎么实现多指针指向同一个地址</h3>
<h3 id="4-引用计数如何保证不同类实例的指针之间共享同步">(4) 引用计数如何保证不同类实例的指针之间共享同步</h3>
<h3 id="5-循环引用会在什么情况下产生如何解决解决的原理">(5) 循环引用会在什么情况下产生，如何解决，解决的原理</h3>
<h3 id="6-shared_ptr-的代码实现主要是构造-赋值和析构">(6) shared_ptr 的代码实现（主要是构造、赋值和析构）</h3>
<p>PS: weak_ptr 的实现？</p>
<h3 id="7-智能指针构造与析构时间">(7) 智能指针构造与析构时间</h3>
<h3 id="8-野指针的产生原因解决方法">(8) 野指针的产生原因，解决方法</h3>
<h2 id="3-类型转换static_cast-dynamic_cast-const_cast-reinterpret_cast">3. 类型转换：static_cast / dynamic_cast / const_cast / reinterpret_cast</h2>
<h3 id="1-static_castlttgtexpr">(1) <code>static_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>编译时静态类型转换，主要用于：
<ul>
<li>已知安全的类型转换（如基本数据类型的转换，例如 int 转为 float）。它比 C 风格 (T)value 更加安全，具有更明确的语义，并在编译时进行类型检查。</li>
<li>子类转换为父类（向上转换）。这是因为子类中继承父类所有的成员，转换时只需要切割掉不需要的部分。</li>
<li>void 指针与其他类型指针转换</li>
<li>禁止转换 const 属性</li>
</ul>
</li>
<li>不推荐将父类转为子类（向下转换）。如果子类中有父类中没有的成员，后续使用时将无法正常访问成员。</li>
<li>编译期转换，不做运行时检查，转换成功与否完全靠人负责。</li>
</ul>
<h3 id="2-dynamic_castlttgtexpr">(2) <code>dynamic_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>运行时安全类型转换（<strong>仅适用于有虚函数的多态类型</strong>），用于多态继承体系中 安全地将基类指针/引用转换为派生类类型。向下转换时，会做 RTTI（运行时类型信息）检查。</li>
<li>要求：
<ul>
<li>类型必须是多态类型（即基类有至少一个虚函数）</li>
<li>失败时返回 nullptr（指针）或抛出 std::bad_cast（引用）</li>
</ul>
</li>
<li>特点：
<ul>
<li>安全但慢，有运行时开销</li>
<li>适用于运行时需要判断类型的场景（如事件系统、脚本接口）</li>
</ul>
</li>
</ul>
<h3 id="3-const_castlttgtexpr">(3) <code>const_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>
<p>不涉及类型变换，只是对类型的修饰属性进行调整，用于添加或移除 const/volatile 限定符。</p>
</li>
<li>
<p>用于移除 const 进行非常量操作（<strong>要保证源对象非 const</strong>否则是未定义行为）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确示例：原变量非const（https://mp.weixin.qq.com/s/F8DOLpP6oaZE0V5ay-84jA）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> </span>&#123;    <span class="hljs-comment">// 修改非 const 字符数组是安全的    </span><br>  <span class="hljs-type">char</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(str);   <br>  p[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>  <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;    <br>  <span class="hljs-built_in">modify</span>(str);   <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Modified string: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：Hello    </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-reinterpret_castlttgtexpr">(4) <code>reinterpret_cast&lt;T&gt;(expr)</code></h3>
<ul>
<li>底层位级别强制转换（最危险）。</li>
<li>在不同类型的指针/整数间强制转换。
<ul>
<li>正确用法如把<code>int*</code>转为<code>char*</code></li>
<li>错误用法如把<code>int*</code>转为<code>double*</code>(以<code>double*</code>方式访问内存，可能破坏内存布局)</li>
</ul>
</li>
<li>不安全，可能破坏类型系统。避免在普通程序中滥用，通常用于特殊用途（内存布局、设备驱动等）。</li>
</ul>
<h2 id="4-move">4. move</h2>
<h3 id="1-左值右值">(1) 左值右值</h3>
<h3 id="2-move-原理-移动语义的概念和优势">(2) move 原理 / 移动语义的概念和优势</h3>
<h3 id="3-引用折叠">(3) 引用折叠</h3>
<h3 id="4-完美转发-使用场景">(4) 完美转发 (使用场景)</h3>
<h3 id="5-类中默认的构造函数有哪些拷贝构造函数和移动构造函数的区别">(5) 类中默认的构造函数有哪些？拷贝构造函数和移动构造函数的区别？</h3>
<h2 id="5-stl-是什么-内部容器的原理和时间复杂度">5. stl 是什么 内部容器的原理和时间复杂度</h2>
<h2 id="6-如何设计一个内存池">6. 如何设计一个内存池</h2>
<h2 id="7-lamda-函数">7. lamda 函数</h2>
<p>（1）lambda 引用陷阱</p>
<h2 id="8-类">8. 类</h2>
<h3 id="1-空类中默认的成员函数">(1) 空类中默认的成员函数</h3>
<ul>
<li>空类默认有 6 个函数（构造、析构、拷贝/移动构造、拷贝/移动赋值）。
<ul>
<li>默认构造函数：Empty::Empty()，创建空对象</li>
<li>拷贝构造函数：Empty::Empty(const Empty&amp;)，用另一个对象初始化</li>
<li>拷贝赋值运算符：Empty&amp; operator=(const Empty&amp;)，拷贝对象</li>
<li>移动构造函数：Empty::Empty(Empty&amp;&amp;)，从另一个临时对象移动（C++11）</li>
<li>移动赋值运算符：Empty&amp; operator=(Empty&amp;&amp;)，移动赋值（C++11）</li>
<li>析构函数：Empty::~Empty()，对象销毁时调用</li>
</ul>
</li>
<li>C++11 之后，如果显式定义了任意构造/赋值/析构函数，有些默认函数不会再自动生成。例如假如手写了析构函数，那么编译器就不会自动生成移动构造和移动赋值函数（需要自己定义）。</li>
<li>用 = default 显式让编译器生成默认版本，例如：<code>Empty() = default;</code></li>
</ul>
<h3 id="2-类的大小决定因素">(2) 类的大小决定因素</h3>
<p>总览：</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>是否影响类的大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>非静态成员变量</td>
<td>是</td>
<td>实际参与对象内存布局</td>
</tr>
<tr>
<td>内存对齐 / 填充</td>
<td>是</td>
<td>编译器会插入 padding</td>
</tr>
<tr>
<td>虚函数表指针（vptr）</td>
<td>是</td>
<td>有虚函数的类，每个对象需一个 vptr</td>
</tr>
<tr>
<td>静态成员变量</td>
<td>否</td>
<td><strong>属于类，不属于对象</strong>，不计入对象大小</td>
</tr>
<tr>
<td>成员函数（非虚）</td>
<td>否</td>
<td>属于类代码段，不影响对象内存布局</td>
</tr>
<tr>
<td>继承层级本身</td>
<td>取决于是否虚继承</td>
<td>普通继承只把父类数据拷进子类布局，虚继承产生虚基表指针</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>其他的都很直观，这里给出一个虚表指针和一个多继承和虚继承的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// sizeof(C) = 8（64 位系统下），因为多了一个虚函数表指针 vptr</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base1</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base2</span> &#123; <span class="hljs-type">int</span> b; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : Base1, Base2 &#123; <span class="hljs-type">int</span> c; &#125;;<br><span class="hljs-comment">// size = 12（3个int），可能是 16 due to alignment</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">virtual</span> Base1 &#123; <span class="hljs-type">int</span> x; &#125;;<br><span class="hljs-comment">// size = 16+（2个int+虚表指针），因为要存虚基表指针（vbptr）</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>空类的大小是 1 字节（尽管有 6 个默认函数也不是 6，尽管什么成员变量都没有也不是 0），因为 C++ 标准规定<strong>每个对象必须有唯一地址</strong>，哪怕没有成员也必须至少占 1 字节，<strong>避免多个对象占用同一地址</strong>。</p>
</li>
<li>
<p><code>sizeof()</code>查看类的大小，或者用 <code>alignof()</code> 查看对齐情况，使用 <code>std::is_empty&lt;T&gt;</code> 检查是否为空类。</p>
</li>
</ul>
<h2 id="9-c内存对齐机制">9. c++内存对齐机制</h2>
<ul>
<li>内存对齐是指 编译器在给结构体或变量分配内存时，按照特定规则将变量放在特定地址上的过程，通常这个地址是变量大小或平台对齐要求的整数倍。</li>
<li>例如，下面结构体分配内存时，不是紧凑排布成 5 字节，而是 a 占用第 0 字节，b 会被放到第 4 字节（从第 4 字节开始）对齐地址（地址 % 4 == 0），所以总大小是 8 字节。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-type">char</span> a;   <span class="hljs-comment">// 1 byte</span><br>  <span class="hljs-type">int</span> b;    <span class="hljs-comment">// 4 bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>为什么要内存对齐？
<ul>
<li>硬件访问效率：大部分硬件架构（x86, ARM）要求变量必须对齐访问，否则性能下降甚至抛异常</li>
<li>避免硬件异常：某些 CPU 不支持非对齐内存访问，比如 <code>int*</code> 不能从奇地址读取</li>
<li>提高缓存效率：对齐能提高 cache line 命中率</li>
<li>满足 ABI 要求：编译器/链接器/系统 ABI 规定数据结构布局方式，必须对齐</li>
</ul>
</li>
<li>编译器如何处理对齐？
<ul>
<li>编译器会自动插入 padding 字节（填充），确保每个成员的地址满足它的对齐需求</li>
</ul>
</li>
<li>如何查看结构体对齐信息？
<ul>
<li>使用 <strong>sizeof()</strong> 观察结构体大小。如上例中 sizeof(A)的结果是 8。</li>
</ul>
</li>
<li>C++11 起可用 alignas 强制让 S 的实例按 16 字节对齐（常用于 SIMD 优化、AVX）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">16</span>) S &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="10-struct-大小">10. struct 大小</h2>
<h3 id="1-定义一个-struct有-int-xchar-c-两个成员这个结构体的大小">(1) 定义一个 struct，有 int x，char c 两个成员，这个结构体的大小？</h3>
<h3 id="2-如果增加一个-static-int-这个结构体大小怎么变化">(2) 如果增加一个 static int 这个结构体大小怎么变化？</h3>
<h3 id="3-如果在结构体里定义一个虚函数结构体大小怎么变化">(3) 如果在结构体里定义一个虚函数，结构体大小怎么变化？</h3>
<h2 id="11-c的动态链接静态链接">11. c++的动态链接静态链接</h2>
<ul>
<li>C++ 程序编译过程分为三步：预处理、编译、链接</li>
<li>链接的目的：将多个 目标文件 (.o) 和 库文件 合成最终的可执行文件</li>
<li>链接分为两种：静态链接 和 动态链接</li>
</ul>
<h3 id="1-静态库static-library">(1) 静态库（Static Library）</h3>
<ul>
<li>编译时直接把 .lib(windows)/.a(linux) 库的代码（对象文件内容）链接进目标程序</li>
<li>最终生成的 .exe 或 .out 文件中包含所有库代码，不再依赖外部 .lib / .a</li>
<li>优点：
<ul>
<li>程序部署方便（无额外依赖）</li>
<li>启动时加载快</li>
</ul>
</li>
<li>缺点：
<ul>
<li>可执行文件体积大</li>
<li>多个程序使用同一库会重复占用空间</li>
<li>更新库需重新编译所有依赖它的程序</li>
</ul>
</li>
</ul>
<h3 id="2-动态库shared-dynamic-library">(2) 动态库（Shared / Dynamic Library）</h3>
<ul>
<li>程序运行时再加载 .dll / .so 文件</li>
<li>二进制可执行文件中只保留符号引用，不包含实际实现</li>
<li>优点：
<ul>
<li>可执行文件体积小</li>
<li>多个程序共享同一份库文件</li>
<li>可热更新（替换库不需重新编译）</li>
</ul>
</li>
<li>缺点：
<ul>
<li>程序运行时必须找到正确的库（需要安装配置）</li>
<li>加载稍慢，部署略复杂</li>
</ul>
</li>
</ul>
<h3 id="3-cmake">(3) cmake</h3>
<p>笼统地说，cmake 通过 add_library 创建库（static/shared），target_link_libraries() 链接。</p>
<h2 id="12-c的运行内存分区">12. c++的运行内存分区</h2>
<ul>
<li>
<p>栈：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的<strong>局部变量、函数参数、返回地址</strong>等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。</p>
</li>
<li>
<p>堆：动态申请的内存空间，就是由 malloc / new 分配的内存块，由 delete / free 手动控制释放，可以在程序运行周期内随时进行申请和释放（生命周期由开发者管理），如果进程结束后还没有释放，操作系统会自动回收。</p>
</li>
<li>
<p>全局区（Global Area）/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放（生命周期：从程序开始到结束）。虚函数表存储在这里。</p>
<ul>
<li>已初始化的全局/静态变量（Data 段）</li>
<li>未初始化的全局/静态变量（BSS 段）</li>
</ul>
</li>
<li>
<p>常量存储区：存放的是<strong>常量</strong>（const），不允许修改，程序运行结束自动释放。</p>
<ul>
<li>全局常量、字符串常量（.rodata 常量区）</li>
</ul>
</li>
<li>
<p>代码区：存放程序的机器指令，<strong>只读</strong>不允许修改，但可以执行。编译后的二进制文件存放在这里。</p>
</li>
</ul>
<h3 id="1-如何在栈上分配一定的内存会有什么问题">(1) 如何在栈上分配一定的内存？会有什么问题？</h3>
<ul>
<li>直接使用局部变量/数组。</li>
<li>问题：
<ul>
<li>栈空间大小有限（一般几百 KB 到几 MB），分配太大可能引发栈溢出（stack overflow）。例如递归中误分配过多栈内存会 crash。</li>
<li>作用域结束就被释放，不能跨函数或返回出去使用局部数组（指针悬空）。</li>
</ul>
</li>
<li>解决：
<ul>
<li>使用<code>std::vector</code>：自动管理内存（默认分配在堆上）</li>
<li>使用<code>std::array&lt;T, N&gt;</code>：固定长度数组，标准安全的栈上分配</li>
</ul>
</li>
</ul>
<h3 id="2-常见内存泄漏的情况">(2) 常见内存泄漏的情况</h3>
<p>内存泄漏：程序中<em>申请了内存但没有释放</em>，导致内存长期占用，最终消耗完系统资源。</p>
<ul>
<li>
<p>使用 new / malloc 后没有调用 delete / free （堆内存泄露）</p>
</li>
<li>
<p>类的析构函数中没有释放</p>
</li>
<li>
<p>函数内多路径提前 return / 抛出异常，因此没有跑后面清理资源的部分（使用智能指针解决）</p>
</li>
<li>
<p>指针被重新赋值，导致原内存无法访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">50</span>];     <span class="hljs-comment">// 原来的 100 个 int 泄漏</span><br><span class="hljs-keyword">delete</span>[] p;          <span class="hljs-comment">// 只释放了新分配的 50 个</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>容器中的裸指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>*&gt; vec;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>));<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">// 容器析构不会自动释放指针元素，泄漏</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>数组泄漏原因，使用  new[]  分配数组但未使用  delete[]  释放</p>
</li>
<li>
<p>循环引用，shared_ptr 之间相互引用，引用计数无法归零，无法释放（解决：将其中一方改成 std::weak_ptr）</p>
</li>
<li>
<p>未释放系统资源（文件句柄、网络连接、线程）导致资源泄漏，如 fopen() / fclose() 未配对（解决：使用 RAII 封装资源，例如  std::ifstream  自动管理文件资源）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(threadFunc)</span></span>;<br>    <span class="hljs-comment">// t.join(); // 若不调用 join 或 detach，会导致线程泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>多线程中资源释放时机混乱 一个线程 new，另一个线程未 delete</p>
</li>
</ul>
<h3 id="3-如何检查和处理内存泄露的问题">(3) 如何检查和处理内存泄露的问题？</h3>
<ul>
<li>
<p>使用智能指针</p>
</li>
<li>
<p>Windows：Visual Studio 自带检测</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRTDBG_MAP_ALLOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    _CrtDumpMemoryLeaks();  <span class="hljs-comment">// 程序结束时输出泄漏信息</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Linux：Valgrind</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">valgrind --leak-check=full ./your_program<br></code></pre></td></tr></table></figure>
<p>输出所有内存分配和未释放位置</p>
</li>
</ul>
<h2 id="13-如何构造一个只能在堆上创建对象的类如何构造一个只能在栈上创建对象的类">13. 如何构造一个只能在堆上创建对象的类？如何构造一个只能在栈上创建对象的类？</h2>
<h2 id="14-简单解释一下-c异常处理机制try-catch的工作原理">14. 简单解释一下 C++异常处理机制（try-catch）的工作原理。</h2>
<h2 id="15-自动类型推断auto-decltype">15. 自动类型推断：auto / decltype</h2>
<h3 id="1-auto">(1) auto</h3>
<ul>
<li>
<p>编译器在编译期根据变量的初始值自动确定其数据类型。</p>
</li>
<li>
<p>只能用于变量声明、函数返回类型（C++14 起）</p>
<ul>
<li>
<p>最常用：遍历容器、for 循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;   <br>  std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : vec) &#123;   <br>  std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>不支持无初始化的变量声明</p>
</li>
<li>
<p>会移除顶层 const 和引用</p>
<ul>
<li>
<p>但可以使用<code>auto&amp;</code>推导引用，使用<code>const auto</code>保留常量性。值得注意的是，<code>auto</code>推导的是值类型，而 <strong><code>auto&amp;</code>推导的是引用类型</strong>。引用的目的是提供对原始变量的直接访问，因此它需要保留原始变量的所有类型信息。因此，引用的类型必须与原始变量的类型完全匹配，包括 const 修饰符。这也就是说如果原始变量是 const 的，auto&amp; 推导出的类型会是 const T&amp;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span>&amp; y = a;   <span class="hljs-comment">// y: const int&amp;</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span>&amp; z = b;   <span class="hljs-comment">// z: int&amp;</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">auto</span> c = x;       <span class="hljs-comment">// c 的类型是 int，不是 const int</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> c = x; <span class="hljs-comment">// c 的类型是 const int</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>auto&amp;&amp;</code>万能引用：会根据初始化表达式的值类别，折叠成适当的引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span>&amp;&amp; a = x;       <span class="hljs-comment">// int&amp; 初始值为左值，推断为 T&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; b = <span class="hljs-number">5</span>;       <span class="hljs-comment">// int&amp;&amp; 初始值为右值，推断为 T&amp;&amp;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-decltype">(2) decltype</h3>
<ul>
<li>
<p><code>decltype(expr)</code> 返回 表达式 <code>expr</code> 的类型，不求值、不构造、不执行</p>
</li>
<li>
<p>可用于函数返回类型推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 a, T2 b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span> </span>&#123;   <br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>可获取表达式的完整类型（包括 const、引用等）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-keyword">decltype</span>(b) x = a;     <span class="hljs-comment">// x 是 int&amp;</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-keyword">decltype</span>(b) c = <span class="hljs-number">3</span>; <span class="hljs-comment">// c 是 const int &amp; (可以去 https://cppinsights.io/ 验证)</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>decltype(auto)</code>：<code>decltype(auto)</code> 是 <code>decltype(expr)</code> 的语法糖，但只能用于变量和函数返回值的类型自动推导。<br>
这样就可以“像 auto 一样写代码”，但保留 decltype 的完整类型语义（包括引用和 const）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getRef</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRef</span>(); <span class="hljs-comment">// 返回 int（拷贝）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRef</span>(); <span class="hljs-comment">// 返回 int&amp;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里用 auto 推断返回类型会丢失引用，用 decltype(auto)，则无需显式写出 decltype(getRef())，还能保留其完整类型（引用）。</p>
</li>
</ul>
<h3 id="3-为什么不鼓励使用-auto">(3) 为什么不鼓励使用 auto？</h3>
<ul>
<li>
<p>可读性下降</p>
</li>
<li>
<p>容易忽略引用和 const 修饰符：auto 会移除顶层 const 和引用修饰，如果忘记加 auto&amp; 或 const auto&amp;，可能导致拷贝开销或逻辑错误。</p>
</li>
<li>
<p>隐式类型错误：某些情况下 auto 推导出的类型并不是理想的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> x = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">auto</span> i = x / <span class="hljs-number">2</span>;  <span class="hljs-comment">// i 是 double，但可能本来想截断取整得到int</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>降低 API 明确性（特别是公共接口）</p>
</li>
</ul>
<h2 id="16-c-11-新特性">16. c++ 11 新特性</h2>
<h2 id="17-是否了解函数的调用约定">17. 是否了解函数的调用约定？</h2>
<ul>
<li>调用函数与被调用函数之间堆栈的平衡是如何实现的？</li>
<li>函数调用的堆栈平衡具体如何实现？</li>
<li>栈帧是调用函数生成还是被调用函数生成？</li>
</ul>
<h2 id="18-new-和-malloc-的区别-delete-和-free-有什么区别">18. new 和 malloc 的区别 / delete 和 free 有什么区别</h2>
<ul>
<li>
<p>new 和 malloc 的区别</p>
<ul>
<li>new 在申请内存的同时，会调用对象的构造函数，对象会进行初始化，malloc 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。</li>
<li>new 是 c++ 中的一个操作符，而 malloc 是 C 中的一个函数。</li>
<li>new 作为一个运算符可以进行重载，而 malloc 作为一个函数不支持重载。</li>
<li>new 内存分配成功，返回该对象类型的指针，分配失败，抛出 bad_alloc 异常；而 malloc 成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。</li>
<li>new 的空间大小由编译器会自动计算，而 malloc 则需要指定空间大小。</li>
</ul>
</li>
<li>
<p>delete 和 free 有什么区别</p>
<ul>
<li>delete 是 C++ 中的一个操作符，可以进行重载；而 free 是 C 中的一个函数，不能进行重载。</li>
<li>free 只会释放指向的内存，不会执行对象的析构函数；delete 则可以执行对象的析构函数。</li>
</ul>
</li>
</ul>
<h2 id="19-lambda-函数">19. Lambda 函数</h2>
<h2 id="20-指针和引用的区别">20. 指针和引用的区别</h2>
<ul>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是一个东西，只不过是原变量的一个别名而已。</li>
<li>可以有 const 指针，但是没有 const 引用；</li>
<li>指针可以有多级，但是引用只能是一级；</li>
<li>指针的值可以为空，但是引用的值不能为 NULL，并且引用在定义的时候必须初始化；</li>
<li>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变。</li>
</ul>
<h2 id="21-指针常量-和-常量指针">21. 指针常量 和 常量指针</h2>
<ul>
<li>
<p>记忆方法</p>
<ul>
<li>指针常量：指针本身是一个常量。<code>const</code> <strong>靠近指针名</strong>，说明指针本身是常量，地址不能变。</li>
<li>常量指针：常量的指针。<code>const</code> <strong>靠近数据类型</strong>，说明指针指向的内容是常量，内容不能变。</li>
</ul>
</li>
<li>
<p>指针常量</p>
<ul>
<li>定义：指针本身是一个常量，它的地址不能改变，但可以改变它指向的内容。</li>
<li>语法：<code>数据类型 *const 指针名;</code></li>
<li><code>const</code> 关键字修饰的是指针本身。</li>
<li>特点：
<ul>
<li>指针的地址在初始化后不能更改。</li>
<li>指针指向的内容可以修改。</li>
</ul>
</li>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> ptr = &amp;a;  <span class="hljs-comment">// ptr 是一个指针常量，指向 a</span><br>*ptr = <span class="hljs-number">30</span>;            <span class="hljs-comment">// 允许修改 a 的值为 30</span><br><span class="hljs-comment">// ptr = &amp;b;          // 错误：不能改变 ptr 的地址</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>常量指针</p>
<ul>
<li>定义：指针指向的内容是常量，不能修改，但指针本身的地址可以改变。</li>
<li>语法：<code>const 数据类型 *指针名;</code> 或 <code>数据类型 const *指针名;</code></li>
<li><code>const</code> 关键字修饰的是指针指向的内容。</li>
<li>特点：
<ul>
<li>指针的地址可以更改。</li>
<li>指针指向的内容不能修改。</li>
</ul>
</li>
<li>例子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr = &amp;a;  <span class="hljs-comment">// ptr 是一个常量指针，指向 a</span><br><span class="hljs-comment">// *ptr = 30;         // 错误：不能修改 a 的值</span><br>ptr = &amp;b;             <span class="hljs-comment">// 允许：可以改变 ptr 的地址，指向 b</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>应用场景</p>
<ul>
<li>指针常量：当需要一个固定指向某个地址的指针时，比如硬件寄存器的地址。</li>
<li>常量指针：当需要保护数据不被意外修改时，比如传递给函数的参数。</li>
</ul>
</li>
</ul>
<h2 id="22-extern-关键字">22. extern 关键字</h2>
<h3 id="1-extern">(1) extern</h3>
<ul>
<li>
<p>用于声明一个变量或函数是在其他文件中定义的，告知编译器“这个符号的定义在别处”，当前只作声明，不要在当前文件重新分配内存或生成代码。</p>
<ul>
<li>用于跨源文件共享变量/函数</li>
<li>避免重复定义（multiple definition）错误</li>
<li>控制链接属性（external linkage）</li>
</ul>
</li>
<li>
<p>示例 1：假设有两个 cpp 文件。<br>
config.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> globalValue = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure>
<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalValue; <span class="hljs-comment">// 在 main.cpp 中用 extern 声明它，避免重复定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, globalValue); <span class="hljs-comment">// 输出 42</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果在 .h 中定义 const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> CONST_VALUE = <span class="hljs-number">5</span>; <span class="hljs-comment">// 每个翻译单元都会生成一个副本</span><br><span class="hljs-comment">// 改成这样：</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> CONST_VALUE;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-extern-c">(2) extern “C”</h3>
<ul>
<li><code>extern &quot;C&quot;</code>是 cpp 提供的关键字，用于告诉编译器按照 C 语言方式<strong>编译和链接</strong>函数或变量，已解决 C++ <strong>名称修饰</strong>（name mangling）带来的兼容性问题。</li>
<li>为什么需要 extern “C”?
<ul>
<li>C++ <strong>支持函数重载</strong>，所以编译器会在<strong>编译时修改函数名</strong>，加入参数类型信息；C 语言不支持重载，其函数名在编译后不会被修饰。如果 C++ 直接调用 C 语言函数（没有  extern “C”），链接时找不到匹配的名称，会报  undefined reference  错误。</li>
<li>PS：VS2022 可以打开 Tools-Command line-Developer command prompt，cd 进入.obj（.o）文件所在的文件夹来分析编译的结果，例如查看符号表。</li>
</ul>
</li>
<li>使用（代码实例见：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/oJDsfqiVLdWTLtcnHKL_tQ%EF%BC%89%EF%BC%9A">https://mp.weixin.qq.com/s/oJDsfqiVLdWTLtcnHKL_tQ）：</a>
<ul>
<li>C++调用 C 函数</li>
<li>C 语言调用 C++ 代码</li>
<li>适用于：（多个）函数、变量、整个头文件。</li>
<li>不适用于：C++ 类（C 语言不支持类）、函数重载（C 语言不支持重载）</li>
<li>C++ 调用 C 库、封装 C 接口给其他语言</li>
<li>extern “C”  只能用于全局作用域，不能嵌套到局部变量或函数内部。</li>
<li>用  #ifdef __cplusplus （#endif）确保头文件可在 C 和 C++ 两端兼容。</li>
<li>适用于 函数和变量，但不能用于 类和重载函数</li>
</ul>
</li>
</ul>
<h3 id="3-inline-和-extern">(3) inline 和 extern</h3>
<p>由前述可知，extern 修饰某个函数/变量，可以表明该函数/变量的定义在其他文件中，从而避免重复定义。<br>
如下面的例子，假设有 test.h, test.cpp, and main.cpp 三个文件。test.h 中定义（实现）一个 func1，test.cpp 和 main.cpp 中都 include 了 test.h，并使用 func1。此时编译 main.cpp 会出现错误。</p>
<p>由前可知，此错误可以用 extern 或 inline 解决，在 test.cpp 中用 extern 声明外部函数 func1。</p>
<p>而新特性下的 inline 已经不在表明是否内联，是否内联现在完全由编译器决定。新特性下的 inline inline  允许函数在多个文件中定义，编译时合并为一份，避免多重定义错误。每个文件中出现的定义都被认为是“同一个函数的多次定义”，链接器不会报错。这样用法主要用于函数，也可用于变量（C++17 起）。在上述例子中，可以在头文件里用 inline 修饰 func1。值得注意的是，不同文件里的多个定义应该完全一样，因为如果定义不同不同编译器可能随机使用某个定义。</p>
<p>extern 和 inline 的对比：</p>
<ul>
<li>编译器行为：extern 是声明符号，定义在别处；inline 允许多次定义（每个 翻译单元 TU 都有）</li>
<li>是否生成多次拷贝：extern 只在定义处生成；inline 则每个 .cpp 中可能各自展开。</li>
<li>使用场景：extern 用于声明全局变量（跨多个文件共享一个全局变量）/ 外部接口；inline 定义 header-only 工具函数 / 模板函数</li>
</ul>
<p>PS: 用 static 修饰函数也可以解决重复定义问题，但其原理和使用场景与 extern 和 inline 完全不同。用 static 修饰函数的本质是表明该函数具有内部链接，即该函数<strong>只在当前翻译单元（.cpp 文件）中可见</strong>，不会导出到外部。即使多个 .cpp 文件中有相同名字的 static 函数，它们在编译期也不会冲突，因为它们在链接器眼中是不同的、局部的符号。但是不推荐在头文件中用 static 修饰函数，因为这样会在每个.cpp 都生成一个副本。因此，static 函数的典型用途是：定义仅供当前 .cpp 文件内部使用的辅助函数；避免函数被导出给其他模块使用（隐藏实现细节）；提升封装性、限制可见性。</p>
<h2 id="23-vector">23. vector</h2>
<h3 id="1-vector-底层实现">(1) vector 底层实现</h3>
<p>基类<code>_Vector_base</code><br>
内部有一个 struct，其中有三个重要的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_impl</span><br>: <span class="hljs-keyword">public</span> _Tp_alloc_type<br>&#123;<br>  pointer _M_start; <span class="hljs-comment">// 指向数据起始位置</span><br>  pointer _M_finish; <span class="hljs-comment">// 指向当前元素末尾（size）</span><br>  pointer _M_end_of_storage; <span class="hljs-comment">// 指向当前可用容量的末尾（capacity）</span><br><span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过 <code>_M_start</code> 到 <code>_M_finish</code> 管理已有元素，<code>_M_end_of_storage - _M_start</code> 就是容量。</p>
<ul>
<li>
<p>内存管理（动态数组）</p>
<ul>
<li>所有元素存储在<strong>连续的堆内存块</strong>中</li>
<li>初始容量通常为 0，插入时自动扩容</li>
</ul>
</li>
<li>
<p>插入元素</p>
<ul>
<li>插入在最后的位置 (<code>push_back()</code>/<code>emplace_back()</code>)：
<ul>
<li>均摊 O(1)</li>
</ul>
</li>
<li>插入不是最后的位置 (<code>insert(pos, x)</code>)：
<ul>
<li>把待插入位置之后的元素全部向后平移一位，再插入元素</li>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除元素</p>
<ul>
<li>删除最后位置的元素 (<code>pop_back()</code>)：
<ul>
<li><code>_M_finish</code> 往前移动一位</li>
<li>调用析构删除元素，不释放现有已经申请的内存</li>
<li>O(1)</li>
</ul>
</li>
<li>删除不是最后 (<code>erase(pos)</code>)：
<ul>
<li>待删除后面所有元素均向前平移一位</li>
<li>删除元素，不释放现有已经申请的内存</li>
<li>O(n)</li>
</ul>
</li>
<li>删除所有 (<code>clear()</code>):
<ul>
<li>对所有元素调用析构，但不释放内存</li>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>读取元素</p>
<ul>
<li>操作符<code>[]</code></li>
<li>.at({index}) (比<code>[]</code>多了一个检查界的越界动作，如果越界了直接返回一个无效的位置)<br>
以上两种都是返回具体元素的引用，可以帮助修改元素</li>
</ul>
</li>
<li>
<p>修改元素</p>
<ul>
<li>vector 不支持直接修改某个位置的元素，只能通过读取元素获取引用再修改，或者删除之后再加入（效率低）</li>
</ul>
</li>
</ul>
<h3 id="2-vector-扩容机制">(2) vector 扩容机制</h3>
<ul>
<li>当使用 push_back/emplace_back 添加元素时，如果容量 capacity() 已满，就会触发自动扩容，将容量扩展为当前容量的 1.5 到 2 倍（具体实现依编译器而异）。</li>
<li>扩容会：
<ul>
<li>分配新内存（当前内存的 1.5 到 2 倍）(<code>allocator&lt;T&gt;</code>（默认是 std::allocator）)</li>
<li>拷贝（或移动）旧元素到新内存</li>
<li>释放旧内存</li>
</ul>
</li>
<li>优化：如果已知需要存储大量数据，可使用<code>vec.reserve(n)</code>预分配 n 个元素的空间，避免多次扩容。</li>
</ul>
<h3 id="3-emplace_back-vs-push_back-区别与性能">(3) emplace_back() vs push_back() 区别与性能</h3>
<ul>
<li>push_back() 接收对象实例，也就是说先构造临时对象，再拷贝/移动进 vector</li>
<li>emplace_back() 接收构造参数，直接在 vector 的尾部<strong>就地构造</strong>对象</li>
<li>emplace_back(args…)  原地构造对象，<strong>避免了不必要的拷贝/移动</strong>，相比  push_back(a)  更高效，特别适用于存储复杂对象。</li>
<li>对于简单数据类型，push_back()和 emplace_back()差别不大；对于复杂对象（如 string、自定义类等），优先使用  emplace_back()  以提升性能。</li>
</ul>
<h3 id="4-vector-里加入-10-万数据游戏中有对象的指针指向这些数据这可能有什么问题">(4) vector 里加入 10 万数据，游戏中有对象的指针指向这些数据，这可能有什么问题？</h3>
<p>vector 发生扩容时会分配更大的内存，将原内存数据拷贝过来，然后释放之前的内存，如果有指针指向此前的地址，释放之后，指针将不能正常访问到此前的数据。</p>
<h3 id="5-clear-后-capacity-是否改变如何释放多余内存">(5) clear() 后 capacity() 是否改变？如何释放多余内存？</h3>
<ul>
<li><code>vec.clear()</code> 只销毁所有元素（调用析构），即 size() 变为 0，但不会释放容量，即 capacity() 不变</li>
<li>如何释放多余内存：
<ul>
<li><strong>shrink_to_fit()</strong> 释放多余内存（C++11 起）。但注意<strong>不是强制释放</strong>，只是建议行为，不同 STL 实现可能不生效（如某些 libc++ 实现中）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">capacity</span>() &gt; vec.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>) &#123;   <br>  vec.<span class="hljs-built_in">shrink_to_fit</span>(); <span class="hljs-comment">// 仅在容量远大于实际使用时调用</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>交换清空法（最稳妥）:创建一个临时空 vector，与 v 交换，原内存立即释放，100% 生效，用来释放大容量 vector 内存 （临时 vector 在语句结束后立即被销毁，释放了内存）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">swap</span>(v);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="6-vector-如何快速删除内部某个元素-要求-o1时间复杂度">(6) vector 如何快速删除内部某个元素。（要求 O(1)时间复杂度）</h3>
<p>将要删除的对象和尾部对象 swap，然后直接 pop_back 即可。</p>
<h2 id="24-多线程的锁有哪些分别有什么区别">24. 多线程的锁有哪些？分别有什么区别？</h2>
<h2 id="25-从-cpp-源代码到-exe-经过了哪些过程">25. 从 cpp 源代码到 exe 经过了哪些过程？</h2>
<ul>
<li>预处理：处理所有以 # 开头的指令。包括：
<ul>
<li>展开 #include</li>
<li>替换 #define 宏</li>
<li>判断 #ifdef/#endif</li>
<li>删除注释等</li>
</ul>
</li>
<li>编译：将预处理后的源码编译成 汇编代码
<ul>
<li>语法检查</li>
<li>变量和函数作用域检查</li>
<li>类型检查</li>
<li>优化（如 inline 展开、常量折叠）</li>
<li>生成 .s 汇编文件（人类可读）</li>
</ul>
</li>
<li>汇编（Assembly）：汇编器把 .s 汇编代码变成 机器码（二进制目标文件 .obj 或 .o）
<ul>
<li>一个 .cpp 文件生成一个 .obj</li>
<li>每个 .obj 文件是单独编译的</li>
<li>含有未解析的符号（函数、全局变量等）</li>
</ul>
</li>
<li>链接：链接器将多个 .obj 文件（以及库文件 .lib/.a）组合为一个 .exe/.out 可执行程序
<ul>
<li>解析符号引用（函数调用、变量地址等）</li>
<li>分配内存地址</li>
<li>合并多个代码段（data/text/bss）</li>
<li>加入启动代码（如 main 的入口 _start）</li>
</ul>
</li>
</ul>
<h2 id="26-const-constexpr-mutable">26. const / constexpr / mutable</h2>
<h3 id="1-const">(1) const</h3>
<ul>
<li>const 表示“值不能修改”，是运行时常量（编译时无法保证是常量），可用于常量指针、常量函数等。</li>
<li>可用于任意可赋值表达式。</li>
<li>不能用于静态数组大小</li>
<li>性能较低，需运行时计算。</li>
</ul>
<h3 id="2-constexpr">(2) constexpr</h3>
<ul>
<li>constexpr 表示“在编译期就已知的常量”，是编译时常量（必须在编译期间求值）。</li>
<li>表达式必须是编译期可求值。</li>
<li>可用于静态数组大小。</li>
<li>性能较高，计算结果直接嵌入到编译后的代码中。</li>
<li>不能使用 constexpr 的情况（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O2FPCCBlGUckXjfjcwzryA%EF%BC%89%EF%BC%9A">https://mp.weixin.qq.com/s/O2FPCCBlGUckXjfjcwzryA）：</a>
<ul>
<li>如果函数的返回值不是编译期常量，则其类型不能是 constexpr。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;  <span class="hljs-comment">// 运行时返回</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">()</span> </span>&#123;    <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">getValue</span>() * <span class="hljs-built_in">getValue</span>();  <span class="hljs-comment">// 编译错误：getValue() 不是常量表达式</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>如果函数里包含动态内存的分配（new），则其返回值不能是 constexpr</li>
<li>表达式里包含运行时输入的变量</li>
</ul>
</li>
</ul>
<h3 id="3-mutable">(3) mutable</h3>
<ul>
<li>
<p>在 const 成员函数中，编译器默认阻止修改任何成员变量。但有些成员变量实际上是缓存、标记、日志开关等行为上的“非状态性成员”，这时就需要 mutable。</p>
</li>
<li>
<p>mutable 用于允许某个类成员变量在 const 成员函数中被修改 和 修饰 lambda 表达式捕获的变量。注意，mutable 是专为此设计的，即除了用于修饰 lambda 捕获的变量，mutable 只能用于类的非静态成员变量，<em>不能用于普通局部变量或全局变量</em>。同时，mutable  也不能用于静态成员变量，因为  static  变量是全局共享的，不受  const  限制。</p>
</li>
<li>
<p>绕过 const 修饰的唯一合法方式，用于明确标记：这个成员变量不是逻辑上的 const。</p>
</li>
<li>
<p>使用场景：</p>
<ul>
<li>
<p>缓存机制 / 延迟计算（懒加载）（lazy evaluation）：等到真正需要某个值时才进行计算，否则就跳过这次计算。避免提前执行浪费资源，真正需要的时候再计算并缓存结果，避免重复计算（缓存机制）。如下例，getValue() 是 const，但缓存字段用 mutable 修饰，只有第一次调用才会执行计算，后续调用直接返回上次结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyValue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cached) &#123;<br>            value = <span class="hljs-built_in">expensiveCompute</span>();  <span class="hljs-comment">// 只执行一次</span><br>            cached = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">expensiveCompute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Computing...&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;  <span class="hljs-comment">// 假设这是一个复杂计算</span><br>    &#125;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> cached = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>访问计数/日志记录</p>
</li>
<li>
<p>lambda 表达式中修饰被捕获的变量。lambda 默认捕获的值是<strong>只读副本</strong>，加上 mutable 后可以修改 lambda 内部的副本（<strong>不影响外部</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> f = [x]() <span class="hljs-keyword">mutable</span> &#123;<br>    x++;         <span class="hljs-comment">// 合法：捕获值可修改副本</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="27-如何在-main-之前执行一个函数">27. 如何在 main 之前执行一个函数</h2>
<ul>
<li>
<p>方法一：全局/静态对象的构造函数。C++ 会在 main() 调用之前 自动调用全局/静态对象的构造函数。</p>
<ul>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitBeforeMain</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">InitBeforeMain</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;初始化代码在 main() 前执行！&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>InitBeforeMain run_before_main;  <span class="hljs-comment">// 全局对象</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="28-inline">28. inline</h2>
<h3 id="1-inline-与宏区别">(1) inline 与宏区别?</h3>
<h3 id="2-inline-函数与普通函数区别">(2) inline 函数与普通函数区别？</h3>
<h2 id="29-浅拷贝-和-深拷贝">29. 浅拷贝 和 深拷贝</h2>
<h3 id="1-浅拷贝shallow-copy">(1) 浅拷贝（Shallow Copy）</h3>
<p>浅拷贝是指在拷贝对象时，仅复制对象的成员变量的值，而不复制其指向的资源。对于指针成员变量，浅拷贝会复制指针的值（即地址），使得<strong>原对象和新对象指向同一块内存区域</strong>。这种方式在对象中没有指针或资源管理需求时是可行的，但在涉及动态内存分配时可能导致问题，如多个对象共享同一资源，进而在析构时出现重复释放(double free)的问题。</p>
<p>C++ 默认的拷贝构造函数是<strong>浅拷贝</strong>。</p>
<h3 id="2-深拷贝deep-copy">(2) 深拷贝（Deep Copy）</h3>
<p>深拷贝是在拷贝对象时，不仅复制对象的成员变量的值，还会<strong>为指针成员变量分配新的内存</strong>，并复制原指针指向的数据。这样，原对象和新对象拥有各自独立的资源，互不影响。深拷贝通常通过<strong>自定义拷贝构造函数和赋值运算符</strong>来实现，确保在对象复制时正确管理资源，避免资源共享带来的问题。</p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShallowCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 默认拷贝构造函数（浅拷贝）</span><br>    <span class="hljs-comment">// ShallowCopy(const ShallowCopy&amp; other) = default;</span><br><br>    ~<span class="hljs-built_in">ShallowCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义拷贝构造函数（深拷贝）</span><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> DeepCopy&amp; other) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载赋值运算符（https://mp.weixin.qq.com/s/8-ov2PxY91k2YhCxqqezRQ）</span><br>    DeepCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DeepCopy&amp; other) &#123;    <br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123;        <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <br>      &#125;   <br>      <span class="hljs-keyword">delete</span> data;  <span class="hljs-comment">// 释放已有内存，防止内存泄漏。如果不释放直接new，会导致原来的 data 指针被覆盖，之前指向的内存失去控制，从而导致内存泄漏。    </span><br>      data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));  <span class="hljs-comment">// 深拷贝</span><br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">DeepCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ShallowCopy <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    ShallowCopy obj2 = obj1; <span class="hljs-comment">// 浅拷贝，obj1.data 和 obj2.data 指向同一内存</span><br><br>    <span class="hljs-function">DeepCopy <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    DeepCopy obj4 = obj3; <span class="hljs-comment">// 深拷贝，obj3.data 和 obj4.data 指向不同内存</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述示例中，<code>ShallowCopy</code> 类使用默认的拷贝构造函数，导致 <code>obj1</code> 和 <code>obj2</code> 共享同一块内存，这样 obj2  析构时会释放  data，obj1  访问  data  可能出现   悬垂指针（dangling pointer）；而 <code>DeepCopy</code> 类通过自定义拷贝构造函数，实现了对指针成员的深拷贝，使得 <code>obj3</code> 和 <code>obj4</code> 拥有独立的内存.</p>
<h3 id="智能指针解决问题">智能指针解决问题</h3>
<p>C++11 提供了  std::shared_ptr  和  std::unique_ptr  以管理资源，避免手动拷贝管理。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartCopy</span> &#123;<br>  <span class="hljs-keyword">public</span>:   <br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; data;    <br>    <span class="hljs-built_in">SmartCopy</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(val)) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="30-模板">30. 模板</h2>
<h3 id="1-模板声明与实现如何能不在同一个头文件">(1) 模板声明与实现如何能不在同一个头文件</h3>
<h1 id="计算机网络">计算机网络</h1>
<h2 id="1-osi-七层协议模型">1. OSI 七层协议模型</h2>
<h2 id="2-tcp-udp-原理和区别">2. TCP UDP 原理和区别</h2>
<ul>
<li>
<p>UDP 是无连接的，TCP 是面向连接的；</p>
</li>
<li>
<p>UDP 是不可靠传输，TCP 是可靠传输；</p>
</li>
<li>
<p>UDP 是面向报文传输，TCP 是面向字节流传输。</p>
</li>
</ul>
<h2 id="3-moba-设计-udp-tcp-的选择">3. moba 设计 UDP TCP 的选择</h2>
<h2 id="4-tcp-粘包">4. TCP 粘包</h2>
<h2 id="5-可靠-udp-的实现思路">5. 可靠 UDP 的实现思路</h2>
<h1 id="操作系统">操作系统</h1>
<ol>
<li>
<p>虚拟内存的分配机制</p>
</li>
<li>
<p>线程和进程区别，协程（重点关注下）</p>
</li>
<li>
<p>线程/进程通讯及切换原理</p>
</li>
</ol>
<p>进程间通讯的方式？</p>
<p>管道通信，消息队列，共享内存，socket，串口都可以实现。</p>
<ol start="4">
<li>
<p>两个函数同一个地址执行问题</p>
</li>
<li>
<p>内存中堆栈，数据区哪里读取快</p>
</li>
<li>
<p>共享内存的实现</p>
</li>
</ol>
<h1 id="设计模式">设计模式</h1>
<h2 id="1-工厂模式">1. 工厂模式</h2>
<h2 id="2-单例模式">2. 单例模式</h2>
<h3 id="1-概念">(1) 概念</h3>
<ul>
<li>定义：一个类在程序运行过程中只能存在一个实例，并提供全局访问。常用于资源管理类（如日志、数据库连接池、配置管理器等）。它通过将构造函数私有化，并提供一个公共的静态方法来获取唯一实例。</li>
<li>懒汉模式 vs. 饿汉模式
<table>
<thead>
<tr>
<th>对比项</th>
<th>懒汉模式（Lazy）</th>
<th>饿汉模式（Eager）</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例创建时机</td>
<td><strong>第一次调用 <code>getInstance()</code> 时</strong> 创建</td>
<td>程序启动时（类加载时）创建</td>
</tr>
<tr>
<td>是否延迟加载</td>
<td>是（节省资源）</td>
<td>否（占资源，但初始化快）</td>
</tr>
<tr>
<td>实现难度</td>
<td>稍高，需要考虑线程安全问题</td>
<td>简单，但无条件创建实例</td>
</tr>
<tr>
<td>线程安全处理</td>
<td>需要手动加锁或使用现代 C++ 特性</td>
<td>靠静态变量初始化，天然线程安全</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="2-实现">(2) 实现</h3>
<ul>
<li>
<p>实现时需要：</p>
<ul>
<li>将构造函数和析构函数私有化（private）</li>
<li>定义一个 public 的函数用于获取唯一实例</li>
<li>手动禁用拷贝构造函数（Singleton(const Singleton&amp;)）和赋值操作符（Singleton&amp; operator=(const Singleton&amp;)）
<ul>
<li>如果没有禁用，则可以在程序运行中获得多个实例，打破了唯一性。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Singleton&amp; a = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton b = a;              <span class="hljs-comment">// 调用拷贝构造，复制一份</span><br>Singleton c;<br>c = Singleton::<span class="hljs-built_in">getInstance</span>(); <span class="hljs-comment">// 调用赋值操作符，复制一份</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>懒汉 + C++11 局部静态变量（线程安全）（Meyers Singleton - 《Effective C++》）<br>
在 C++11 及以后标准中，局部静态变量（function-local static）的初始化是线程安全的。编译器会确保<strong>只会有一个线程执行初始化代码</strong>，其它线程等待初始化完成后再访问，从而保证了懒汉式单例的线程安全性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// C++11: 线程安全的懒汉初始化</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Singleton working!\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>()  &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Constructor called\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Destructor called\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 赋值操作符</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Singleton::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">doSomething</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>饿汉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called (Eager)\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Destructor called (Eager)\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 赋值操作符</span><br>    <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// 初始化时就创建</span><br>&#125;;<br><br>Singleton Singleton::instance;  <span class="hljs-comment">// 全局初始化</span><br></code></pre></td></tr></table></figure>
<p>值得注意的是，这里类内的<code>instance</code>是静态成员变量，static 成员变量是属于类本身，不属于某个对象，所以必须 在类外部再定义一次，编译器才会真正为它分配内存。<code>static Singleton instance;</code> 是在类中声明（没有构造发生）,<code>Singleton Singleton::instance;</code> 是定义 + 初始化（调用默认构造函数）。</p>
<p>从 C++17 开始，可以在类内直接定义并初始化静态成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> Singleton instance&#123;&#125;;  <span class="hljs-comment">// 定义 + 初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>不用再写类外那行 <code>Singleton Singleton::instance;</code>，也不会再产生“看起来初始化了两次”的疑问。</p>
<p>另：懒汉模式的实现方式不同，它没有用类的 static 成员变量，而是用了<strong>函数内的 static 局部变量</strong>（生命周期和可见性都在函数内，因此不需要类外定义），两者机制完全不同。</p>
<p>另 2：饿汉模式是线程安全的，但可能存在初始化顺序问题（static initialization order fiasco）。如果 Singleton::instance 在多个翻译单元（.cpp 文件）中都被引用，可能使用还未构造的静态对象，出现未定义行为或崩溃。</p>
</li>
</ul>
<h1 id="resources">Resources:</h1>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30556448622">https://zhuanlan.zhihu.com/p/30556448622</a><br>
<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/353159115046330368">https://www.nowcoder.com/discuss/353159115046330368</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/" class="category-chain-item">Graphics</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Graphics/Interview/" class="category-chain-item">Interview</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/graphics/" class="print-no-link">#graphics</a>
      
        <a href="/tags/interview/" class="print-no-link">#interview</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Graphics Interview Review 2</div>
      <div>http://example.com/2025/04/05/interview-review2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 5, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/02/view-mat/" title="Understanding view matrix">
                        <span class="hidden-mobile">Understanding view matrix</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
