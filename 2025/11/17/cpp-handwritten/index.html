

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. Singleton (1) 概念  定义：一个类在程序运行过程中只能存在一个实例，并提供全局访问。常用于资源管理类（如日志、数据库连接池、配置管理器等）。它通过将构造函数私有化，并提供一个公共的静态方法来获取唯一实例。 懒汉模式 vs. 饿汉模式    对比项 懒汉模式（Lazy） 饿汉模式（Eager）     实例创建时机 第一次调用 getInstance() 时 创建 程序启动时（类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ handwritten cases for interviews">
<meta property="og:url" content="http://example.com/2025/11/17/cpp-handwritten/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="1. Singleton (1) 概念  定义：一个类在程序运行过程中只能存在一个实例，并提供全局访问。常用于资源管理类（如日志、数据库连接池、配置管理器等）。它通过将构造函数私有化，并提供一个公共的静态方法来获取唯一实例。 懒汉模式 vs. 饿汉模式    对比项 懒汉模式（Lazy） 饿汉模式（Eager）     实例创建时机 第一次调用 getInstance() 时 创建 程序启动时（类">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-11-18T03:47:16.008Z">
<meta property="article:modified_time" content="2025-11-20T17:36:13.321Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++ handwritten cases for interviews - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ handwritten cases for interviews"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-17 19:47" pubdate>
          November 17, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          88 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ handwritten cases for interviews</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-singleton">1. Singleton</h1>
<h3 id="1-概念">(1) 概念</h3>
<ul>
<li>定义：一个类在程序运行过程中只能存在一个实例，并提供全局访问。常用于资源管理类（如日志、数据库连接池、配置管理器等）。它通过将构造函数私有化，并提供一个公共的静态方法来获取唯一实例。</li>
<li>懒汉模式 vs. 饿汉模式
<table>
<thead>
<tr>
<th>对比项</th>
<th>懒汉模式（Lazy）</th>
<th>饿汉模式（Eager）</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例创建时机</td>
<td><strong>第一次调用 <code>getInstance()</code> 时</strong> 创建</td>
<td>程序启动时（类加载时）创建</td>
</tr>
<tr>
<td>是否延迟加载</td>
<td>是（节省资源）</td>
<td>否（占资源，但初始化快）</td>
</tr>
<tr>
<td>实现难度</td>
<td>稍高，需要考虑线程安全问题</td>
<td>简单，但无条件创建实例</td>
</tr>
<tr>
<td>线程安全处理</td>
<td>需要手动加锁或使用现代 C++ 特性</td>
<td>靠静态变量初始化，天然线程安全</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="2-实现">(2) 实现</h3>
<ul>
<li>
<p>实现时需要：</p>
<ul>
<li>将构造函数和析构函数私有化（private）</li>
<li>定义一个 public 的函数用于获取唯一实例</li>
<li><strong>手动禁用拷贝构造函数（Singleton(const Singleton&amp;)）和赋值操作符（Singleton&amp; operator=(const Singleton&amp;)）</strong>
<ul>
<li>如果没有禁用，则可以在程序运行中获得多个实例，打破了唯一性。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Singleton&amp; a = Singleton::<span class="hljs-built_in">getInstance</span>();<br>Singleton b = a;              <span class="hljs-comment">// 调用拷贝构造，复制一份</span><br>Singleton c;<br>c = Singleton::<span class="hljs-built_in">getInstance</span>(); <span class="hljs-comment">// 调用赋值操作符，复制一份</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>懒汉 + C++11 局部静态变量（线程安全）（Meyers Singleton - 《Effective C++》）<br>
在 C++11 及以后标准中，局部静态变量（function-local static）的初始化是线程安全的。编译器会确保<strong>只会有一个线程执行初始化代码</strong>，其它线程等待初始化完成后再访问，从而保证了懒汉式单例的线程安全性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 注意这里是一个返回引用的静态成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 仅在第一次函数调用时执行一次初始化</span><br>        <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// C++11: 线程安全的懒汉初始化</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Singleton working!\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Singleton()&#123;&#125;; 是正确的，只有Singleton()是错的，必须要有定义。</span><br>    <span class="hljs-built_in">Singleton</span>()  &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Constructor called\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Destructor called\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; other) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp; other) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 赋值操作符</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Singleton::getInstance().doSomething(); // correct</span><br>  Singleton&amp; single = Singleton::<span class="hljs-built_in">getInstance</span>(); <span class="hljs-comment">// correct because it&#x27;s just a alias not calling copy constructor</span><br>  <span class="hljs-comment">// MyManager m1; (没有 &amp;)：这行代码会创建一个名为 m1 的新 MyManager 对象，并调用其默认构造函数。</span><br>  <span class="hljs-comment">// MyManager&amp; m1 (有 &amp;)：这行代码声明了一个名为 m1 的引用。它不会创建新对象。它只是一个“别名”，它必须绑定到一个已经存在的 MyManager 对象上。</span><br>  <span class="hljs-comment">// auto single = Singleton::getInstance(); // wrong because in this case it will call copy constructor (auto -&gt; Singleton)</span><br>  <span class="hljs-comment">// 不能用auto的原因是默认情况下，auto 会“抛弃”初始值中的引用 (&amp;) 和 const 修饰符。</span><br>  <span class="hljs-comment">// 正确的是使用 auto&amp; m1 = MyManager::getInstance();</span><br>  single.<span class="hljs-built_in">doSomething</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>饿汉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 注意这里是一个返回引用的静态成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called (Eager)\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot; Destructor called (Eager)\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 赋值操作符</span><br>    <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// 初始化时就创建</span><br>&#125;;<br><br>Singleton Singleton::instance;  <span class="hljs-comment">// 全局初始化</span><br></code></pre></td></tr></table></figure>
<p>值得注意的是，这里<code>static Singleton instance;</code> 是在类中声明（没有构造发生，不会分配内存），这个声明会出现在包含该头文件的每一个编译单元（.cpp 文件）中。<code>Singleton Singleton::instance;</code> 是定义 + 初始化（调用默认构造函数）。根据 C++的<strong>单一定义规则 (One Definition Rule, ODR)，一个变量在整个程序中只能被定义一次</strong>。因此，这个定义必须放在一个 .cpp 文件中，而不能放在 .h 头文件中（否则会被多重定义）。</p>
<p>从 C++17 开始，可以在类内直接定义并初始化静态成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> Singleton instance&#123;&#125;;  <span class="hljs-comment">// 定义 + 初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>inline</code> 告诉编译器和链接器这个变量可以在头文件中定义，即使它被包含多次，也保证最后只链接一个唯一的实例。不用再写类外那行 <code>Singleton Singleton::instance;</code>，也不会再产生“看起来初始化了两次”的疑问。</p>
<p>另：懒汉模式的实现方式不同，它没有用类的 static 成员变量，而是用了<strong>函数内的 static 局部变量</strong>（生命周期和可见性都在函数内，因此不需要类外定义），两者机制完全不同。</p>
<p>另 2：饿汉模式是线程安全的，但可能存在初始化顺序问题（static initialization order fiasco）。不用 inline 的情况下，如果 Singleton::instance 在多个翻译单元（.cpp 文件）中都被引用，可能使用还未构造的静态对象，出现未定义行为或崩溃。</p>
</li>
</ul>
<h1 id="2-stringchar">2. String/Char</h1>
<h2 id="1char-vs-stdstring-vs-char">（1）<code>char*</code> vs <code>std:string</code> vs <code>char[]</code></h2>
<h3 id="char-c-风格的字符数组"><code>char[]</code> (C 风格的字符数组)</h3>
<p><code>char[]</code> 是一个<strong>缓冲区</strong>。它是在编译时分配的<strong>一块固定大小的内存</strong>。</p>
<ul>
<li><strong>定义与内存</strong>：<code>char my_buffer[100];</code>
<ul>
<li>这会在<strong>栈</strong> 上（如果在函数内）或静态数据区（如果在全局）分配 <strong>100 字节</strong>。</li>
<li>这块内存的“所有权”属于声明它的作用域。当函数返回时，栈上的 <code>my_buffer</code> 会被自动销毁。</li>
<li><strong>用法</strong>：
<ul>
<li>用作接收 C 风格字符串的缓冲区。<br>
<code>strcpy(my_buffer, &quot;Hello&quot;);</code> (必须确保 “Hello” 不会溢出 <code>my_buffer</code>)<br>
<code>std::cin.getline(my_buffer, 100);</code> (从控制台读取一行，最多 99 个字符)</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>内存分配在栈上（如果局部），非常快，没有动态分配开销。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>大小固定</strong>：不能在运行时改变大小。</li>
<li><strong>危险</strong>：极易发生<strong>缓冲区溢出</strong>。<code>strcpy(my_buffer, &quot;一个非常长的字符串&quot;);</code>。</li>
<li><strong>值语义弱</strong>：不能用 <code>==</code> 比较内容，不能用 <code>=</code> 复制内容（数组名不能被赋值）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="char-c-风格的字符指针"><code>char*</code> (C 风格的字符指针)</h3>
<p><code>char*</code> 是一个<strong>指针</strong>。它本身只占用 4 或 8 字节（用于存储一个内存地址）。它<strong>不包含</strong>任何字符串数据，它只<strong>指向</strong>数据。</p>
<p><code>char*</code> 指向的内存有三种主要来源：</p>
<ul>
<li>
<p><strong>A. 指向一个 <code>char[]</code> (数组)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> my_buffer[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span>* ptr = my_buffer; <span class="hljs-comment">// ptr &quot;指向&quot; my_buffer 的第一个字符 &#x27;H&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>sizeof(my_buffer)</code> 是 100 (数组的总大小)。</li>
<li><code>sizeof(ptr)</code> 是 8 (64 位系统上指针的大小)。</li>
<li><code>ptr</code> 和 <code>my_buffer</code> 都可以用于 <code>strcpy</code> 等函数。</li>
</ul>
</li>
<li>
<p><strong>B. 指向一个字符串字面量</strong><br>
字符串字面量是写在代码中的、用双引号括起来的常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* literal = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 必须是 const char*</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>&quot;Hello&quot;</code> 被存储在程序的<strong>只读数据区</strong>。</li>
<li><code>literal</code> 指针指向 ‘H’。</li>
<li><strong>极其重要</strong>：<strong>绝对不能</strong>尝试修改这个内存（例如 <code>literal[0] = 'h';</code>），这会导致程序崩溃。这就是为什么现代 C++ <strong>强制要求使用 <code>const char*</code></strong>。</li>
</ul>
</li>
<li>
<p><strong>C. 指向堆内存</strong><br>
这是 C 语言中用于动态字符串的唯一方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* heap_string = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 在堆上分配100字节</span><br><span class="hljs-built_in">strcpy</span>(heap_string, <span class="hljs-string">&quot;Dynamic&quot;</span>);<br><span class="hljs-comment">// ... 使用 ...</span><br><span class="hljs-keyword">delete</span>[] heap_string; <span class="hljs-comment">// !!! 必须手动释放内存 !!!</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>优点</strong>：大小可以在运行时决定。</li>
<li><strong>缺点</strong>：<strong>手动内存管理</strong>。你必须自己负责 <code>delete[]</code>。如果忘记了，就会<strong>内存泄漏</strong>。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：形如<code>char s[100] = &quot;hello&quot;;</code> 会自动在末尾生成一个 <code>&quot;\0&quot;</code>，但用 strlen 是看不出来的，因为 strlen 会忽略<code>&quot;\0&quot;</code>。因此数组大小必须至少比字符串字面量长度大 1（用于存放 <code>&quot;\0&quot;</code>），剩余未初始化的元素会被自动设置为 0。形如<code>char s3[] = &quot;auto size&quot;;</code>，会自动计算大小，包括 <code>&quot;\0&quot;</code>。又如下方例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 危险：没有终止符，不是合法的 C 字符串。长度不够无法自动补全。</span><br><span class="hljs-type">char</span> s4[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-comment">// 正确：手动添加终止符</span><br><span class="hljs-type">char</span> s5[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-comment">// 正确：部分初始化，剩余自动补 0（包括 &#x27;\0&#x27;）</span><br><span class="hljs-type">char</span> s6[<span class="hljs-number">100</span>] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;  <span class="hljs-comment">// s6[5] 是 &#x27;\0&#x27;</span><br><span class="hljs-comment">// 危险：没有终止符</span><br><span class="hljs-type">char</span> arr1[] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-comment">// 正确：字符串字面量初始化</span><br><span class="hljs-type">char</span> arr3[] = <span class="hljs-string">&quot;hello&quot;</span>;              <span class="hljs-comment">// 自动包含 &#x27;\0&#x27;</span><br><span class="hljs-comment">// 正确：字符串字面量 &quot;hello&quot; 在内存中实际上是 &quot;hello\0&quot;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>另外字符数组是在栈上分配内存，可以修改内容，但字符指针指向只读内存，不能修改内容。</p>
<h3 id="stdstring-c标准字符串"><code>std::string</code> (C++标准字符串)</h3>
<p><code>std::string</code> 是 C++标准库中的一个<strong>类</strong>，封装了所有 C 风格字符串的复杂性。</p>
<ul>
<li>
<p><strong>定义与内存</strong>：<code>std::string s = &quot;Hello&quot;;</code></p>
<ul>
<li><code>std::string</code> 对象 <code>s</code> 本身在栈上（大小固定，如 <code>sizeof(std::string)</code>）。</li>
<li>它<strong>内部</strong>持有一个指针，指向在<strong>堆</strong>上分配的内存，用于存储 “Hello” 及其 <code>\0</code>。</li>
<li>这一切都是<strong>自动</strong>的。</li>
</ul>
</li>
<li>
<p><strong>RAII (资源获取即初始化)</strong>：</p>
<ul>
<li>当 <code>s</code> 被创建时，它自动在堆上分配内存 (构造函数)。</li>
<li>当 <code>s</code> 离开作用域时 (例如函数返回)，它的<strong>析构函数</strong>会自动被调用，<strong>自动释放</strong>堆上的内存。</li>
</ul>
</li>
<li>
<p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string s2 = <span class="hljs-string">&quot;World&quot;</span>;<br>std::string s3 = s1 + <span class="hljs-string">&quot; &quot;</span> + s2; <span class="hljs-comment">// 拼接: &quot;Hello World&quot;</span><br><br><span class="hljs-keyword">if</span> (s1 == <span class="hljs-string">&quot;Hello&quot;</span>) &#123; ... &#125;       <span class="hljs-comment">// 比较: true</span><br><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;, C++&quot;</span>);              <span class="hljs-comment">// 修改: &quot;Hello, C++&quot;</span><br><br>std::cout &lt;&lt; s<span class="hljs-number">1.l</span>ength();        <span class="hljs-comment">// 获取长度 (不含 \0)</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>安全</strong>：自动管理内存，<strong>没有内存泄漏</strong>，<strong>没有缓冲区溢出</strong>。</li>
<li><strong>动态大小</strong>：可以按需增长。</li>
<li><strong>功能丰富</strong>：内置了拼接、比较、查找 (<code>.find()</code>)、截取 (<code>.substr()</code>) 等无数便捷功能。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>相比栈上的 <code>char[]</code>，有微小的堆分配开销（在现代 C++中，短字符串优化(SSO)甚至避免了小字符串的堆分配）。</li>
</ul>
</li>
</ul>
<h3 id="如何在它们之间转换-交互">如何在它们之间转换 (交互)</h3>
<ul>
<li>
<p><strong><code>char*</code> 或 <code>char[]</code> 转换为 <code>std::string</code>：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> buffer[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(buffer)</span></span>; <span class="hljs-comment">// 使用构造函数</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>std::string</code> 转换为 <code>const char*</code>：</strong> (最常用)<br>
当你需要将 <code>std::string</code> 传递给一个只接受 <code>const char*</code> 的 C 函数（如 <code>fopen</code>）时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string filename = <span class="hljs-string">&quot;config.txt&quot;</span>;<br><span class="hljs-comment">// .c_str() 返回一个指向 string 内部数据的 const char* 指针</span><br>FILE* f = <span class="hljs-built_in">fopen</span>(filename.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;r&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2字符串操作函数ltcstringgt">（2）字符串操作函数（<code>&lt;cstring&gt;</code>）</h2>
<h3 id="strcpy">strcpy()</h3>
<p>把从 src 地址开始且含有&quot;0’结束符的字符串复制到以 dst 开始的地址空间，返回值的类型为 char*</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span>&#123; <span class="hljs-comment">//[1]</span><br>  <span class="hljs-built_in">assert</span>(dst != <span class="hljs-literal">nullptr</span> &amp;&amp; src != <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//[2]</span><br>  <span class="hljs-type">char</span> *ret = dst; <span class="hljs-comment">//[3]</span><br>  <span class="hljs-keyword">while</span>((*dst++ = *src++) != <span class="hljs-string">&#x27;\0&#x27;</span>); <span class="hljs-comment">//[4]</span><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="strlen">strlen()</h3>
<p>计算给定字符串的长度（不包括<code>\0</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(str != <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(str[len] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    len += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="strcat">strcat()</h3>
<p>作用是把 src 所指字符串添加到 dst 结尾处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(dest != <span class="hljs-literal">nullptr</span> &amp;&amp; src != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">char</span>* ret = dest;<br>  <span class="hljs-keyword">while</span>((*dest) != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    dest++;<br>  <span class="hljs-keyword">while</span>(*dest++ = *src++)&#123;&#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="strcmp">strcmp()</h3>
<p>按照字典序比较两个字符串。设这两个字符串为 str1，str2,</p>
<ul>
<li>若 str1 == str2，则返回零</li>
<li>若 str1 &lt; str2，则返回负数</li>
<li>若 str1 &gt; str2，则返回正数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str2)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(str1 != <span class="hljs-literal">nullptr</span> &amp;&amp; str2 != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">while</span>(*str1 &amp;&amp; *str2 &amp;&amp; (*str1 == *str2))&#123;<br>    str1++;<br>    str2++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> *str1 - *str2;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3实现-strcpy">（3）实现 strcpy</h2>
<p>strcpy 是 C 语言标准库 (在 C++中通过 <code>&lt;cstring&gt;</code> 头文件可用) 中的一个函数。核心功能：复制 C 风格字符串，即将一个 C 风格字符串（以 <code>\0</code> 结尾的字符数组）从一个“源”地址复制到另一个“目标”地址。这是一个很危险的函数，主要是因为 strcpy 不会检查边界。strcpy 函数对 destination 缓冲区的大小一无所知。它唯一的停止条件是 source 字符串中的 <code>\0</code>。如果 source 字符串的长度（加上 <code>\0</code>）大于 destination 缓冲区的容量，strcpy 会“溢出”：它会继续在 destination 缓冲区之后的内存中写入数据，覆盖掉其他可能存在的变量、返回地址或程序关键数据。</p>
<p>替代方法是使用<code>std::string</code>。<code>std::string</code> 会自动管理内存，完全避免了缓冲区溢出的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string s2;<br>s2 = s1; <span class="hljs-comment">// 安全、简单、正确</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span>&#123; <span class="hljs-comment">//[1]</span><br>  <span class="hljs-built_in">assert</span>(dst != <span class="hljs-literal">nullptr</span> &amp;&amp; src != <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//[2]</span><br>  <span class="hljs-type">char</span> *ret = dst; <span class="hljs-comment">//[3]</span><br>  <span class="hljs-keyword">while</span>((*dst++ = *src++) != <span class="hljs-string">&#x27;\0&#x27;</span>); <span class="hljs-comment">//[4]</span><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>[1] const 修饰<br>
源字符串参数用 const 修饰，防止修改源字符串.</p>
</li>
<li>
<p>[2] 空指针检查</p>
<ul>
<li><code>char *</code>转换为 <code>bool</code> 是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。</li>
<li>检查指针的有效性时使用 <code>assert(dst!= 0 &amp;&amp; src != 0);</code>会减少程序的可维护性。而使用 NULL 代替 0，如果出现拼写错误，编译器就会检查出来。</li>
</ul>
</li>
<li>
<p>[3] “备份”目标的起始地址，以便在 while（会移动 destination）完成后，能够返回字符串的起始地址。</p>
</li>
<li>
<p>[4] <code>&quot;\0&quot;</code>:</p>
<ul>
<li>循环写成 <code>while(*dst++=*src++);</code>明显是错误的。</li>
<li>循环写成 <code>while(*src!='\0') *dst++= *src++</code>会导致循环体结束后，dst 字符串的末尾没有正确地加上&quot;0’。</li>
</ul>
</li>
<li>
<p>为什么要返回 <code>char *</code>? - 返回 dst 的原始值使函数能够支持链式表达式。链式表达式的形式如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">strcpy</span>(strA, strB));<br></code></pre></td></tr></table></figure>
<p>又如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *strA = <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>],strB);<br></code></pre></td></tr></table></figure>
<p>返回 strSrc 的原始值是错误的。因为首先源字符串肯定是已知的，返回它没有意义；其次不能支持形如第二例的表达式；最后把 <code>const char *</code>作为 <code>char *</code>返回，类型不符，编译报错。</p>
</li>
<li>
<p>假如考虑 dst 和 src 内存重叠的情况，strcpy 该怎么实现？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> s[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">strcpy</span>(s, s<span class="hljs-number">+1</span>); <span class="hljs-comment">//应返回 e11o</span><br><span class="hljs-built_in">strcpy</span>(s<span class="hljs-number">+1</span>, s); <span class="hljs-comment">//应返回 he11o 但实际会无结果/报错，因为 dst 与 src 重叠了，把&#x27;\0&#x27;覆盖了</span><br></code></pre></td></tr></table></figure>
<p>所谓重叠，就是 src 未处理的部分已经被 dst 给覆盖了，只有一种情况: src &lt;= dst &lt;= src+strlen(src)<br>
dst &lt; src 即使 dst 的起始位置相较于 src 的起始位置在低地址，即<code>dst[...]src[...]</code>，相当于<code>strcpy(s, s+1);</code>；<br>
src &lt;= dst &lt;= src+strlen(src) 即 dst 的起始位置相较于 src 的起始位置在高地址，且在 src 字符串的第 n 位之前，相当于<code>strcpy(s+1, s);</code>。</p>
<p>解决方法：C 函数 memmove 自带内存重叠检测功能。</p>
<ul>
<li>
<p>memcpy 是 C/C++中 (在 <code>&lt;cstring&gt;</code> 或 <code>&lt;string.h&gt;</code> 中) 用于原始内存复制的标准库函数。memcpy 的功能是从一个内存位置复制指定数量的字节到另一个内存位置。它不关心它正在复制的是什么数据类型（可以是任何数据：int, float, 结构体, 原始数据），只知道移动字节，即使数据中有 <code>\0</code> 也会继续复制 (因为它不检查)。</p>
<ul>
<li>对于 std::vector 等容器：永远不要使用 memcpy。直接使用容器的拷贝构造函数或赋值运算符 (<code>std::vector&lt;int&gt; v2 = v1;</code>)。</li>
<li>对于普通数组：优先使用 std::copy (在 <code>&lt;algorithm&gt;</code> 中)。std::copy 是类型安全的，并且对于简单类型 (POD, Plain Old Data)，编译器通常会将其优化为与 memcpy 一样快的代码。</li>
<li>当需要处理原始字节流（例如，网络数据包、文件 I/O）/ 性能极其敏感 / 与 C 语言库交互时使用 memcpy。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// void* memcpy(void* destination, const void* source, size_t num);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> source_array[] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br>    <span class="hljs-type">int</span> dest_array[<span class="hljs-number">4</span>]; <span class="hljs-comment">// 确保目标有足够的空间</span><br><br>    <span class="hljs-type">size_t</span> bytes_to_copy = <span class="hljs-built_in">sizeof</span>(source_array); <span class="hljs-comment">// sizeof 数组会返回总字节数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;要复制 &quot;</span> &lt;&lt; bytes_to_copy &lt;&lt; <span class="hljs-string">&quot; 字节\n&quot;</span>;<br>    <span class="hljs-built_in">memcpy</span>(dest_array, source_array, bytes_to_copy);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;目标数组的第二个元素: &quot;</span> &lt;&lt; dest_array[<span class="hljs-number">1</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题在于，C/C++标准明确规定：如果 source 和 destination 的内存区域有任何重叠，memcpy 的行为是“未定义的” (Undefined Behavior)。因为 memcpy 的实现为了追求极致的速度，通常会假设内存是不重叠的。它可能从前向后复制。如果不能保证内存不重叠，则必须使用 memmove。memmove 做了和 memcpy 完全相同的事情，但它保证在内存重叠的情况下也能正确工作。memmove 在内部会检查 source 和 destination 的地址，如果发现重叠，它会智能地选择是从后向前复制（解决上述问题）还是从前向后复制，以确保数据在被覆盖前被正确读取。</p>
</li>
<li>
<p>memmove</p>
<p>下面是 memmove 的实现 mymemmove。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(dst != <span class="hljs-literal">nullptr</span> &amp;&amp; src != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">char</span> *rat = dst;<br>  <span class="hljs-built_in">mymemmove</span>(dst, src, <span class="hljs-built_in">strlen</span>(src) + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">mymemmove</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> cnt)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(dst != <span class="hljs-literal">nullptr</span> &amp;&amp; src != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">char</span> *ret = dst;<br>  <span class="hljs-comment">// 内存重叠，从高地址开始复制</span><br>  <span class="hljs-keyword">if</span>(dst &gt;= src &amp;&amp; dst &lt;= src+cnt<span class="hljs-number">-1</span>) &#123;<br>    dst = dst + cnt - <span class="hljs-number">1</span>;<br>    src = src + cnt - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cnt--)<br>      *dst-- = *src--;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 正常情况，从低地址开始复制</span><br>    <span class="hljs-keyword">while</span>(cnt--)<br>      *dst++ = *src++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="4实现-string">（4）实现 string</h2>
<p>已知 String 的原型如下，据此编写下面四个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">String</span>();<br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-literal">nullptr</span>);<br>  ~<span class="hljs-built_in">String</span>();<br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;other);<br>  String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;other);<br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br>  String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br>  String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String &amp;other) <span class="hljs-type">const</span>;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; other) <span class="hljs-type">const</span>;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> String&amp; other) <span class="hljs-type">const</span>;<br>  <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index);<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span>;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// 友元函数 (用于 std::cout &lt;&lt; s1)</span><br>  <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> String&amp; str); <span class="hljs-comment">// 友元函数既可以类内声明类内定义（函数体小）也可以类内声明类外定义。记得在类外声明友元函数（如果需要在类外调用）。</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *m_data;<br>  <span class="hljs-type">size_t</span> m_size; <span class="hljs-comment">// 字符串的长度 (不包括末尾的 &#x27;\0&#x27;)</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(String &amp;other)</span></span>;<br>&#125;; <span class="hljs-comment">// 类的声明是完整的语句所以需要加分号。C++中，所有以花括号 &#123;&#125; 结束的声明（class、struct、union、enum）后面都必须加分号 ;。友元函数在类外定义时不需要加 MyClass::（作用域解析），因为友元函数不是类的成员函数，它只是一个被授予访问私有成员权限的普通函数。</span><br></code></pre></td></tr></table></figure>
<p>实现如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>   <span class="hljs-comment">// 用于 strlen, strcpy, strcmp, strcat</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 用于 std::swap</span></span><br><br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 默认构造函数 (创建空字符串)</span><br>String::<span class="hljs-built_in">String</span>() : <span class="hljs-built_in">m_size</span>(<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 分配1个字节用于存放空终止符 &#x27;\0&#x27;</span><br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>    m_data[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 从C风格字符串构造</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *c_str) &#123;<br>  <span class="hljs-keyword">if</span>(c_str == <span class="hljs-literal">nullptr</span>) &#123;<br>    m_size = <span class="hljs-number">0</span>;<br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>    *m_data=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    m_size = <span class="hljs-built_in">strlen</span>(c_str);<br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_size + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 长度 + 1 个字节给 &#x27;\0&#x27;</span><br>    <span class="hljs-built_in">strcpy</span>(m_data, c_str);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br>  <span class="hljs-keyword">delete</span>[] m_data; <span class="hljs-comment">// m_data = new char[m_size + 1]; &lt;-- 使用了 new[] 所以要用delete[]</span><br>&#125;<br><br><span class="hljs-comment">//拷贝构造函数</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;other) &#123;<br>  <span class="hljs-comment">// 因为在拷贝构造函数被调用时，“自己”(this) 还是一个正在被创建的、全新的对象，它不可能与一个“已经存在的”other 对象是同一个。</span><br>  m_size = other.m_size;<br>  m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_size + l]; <span class="hljs-comment">// 注意这里开辟了新空间而不是直接像移动构造那样转移所有权</span><br>  <span class="hljs-built_in">strcpy</span>(m_data, other.m_data);<br>&#125;<br><br><span class="hljs-comment">//拷贝赋值函数</span><br>String&amp; String::operate=(<span class="hljs-type">const</span> String &amp;other) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 检查自赋值</span><br>  <span class="hljs-comment">// delete []m data; // 释放原有的内存资源</span><br>  <span class="hljs-comment">// int length = strlen(other.m_data);</span><br>  <span class="hljs-comment">// m_data = new char[length + l]; // 对m_data加NULL判断strcpy(m_data, other.m_data);</span><br>  <span class="hljs-comment">// return *this; // 返回本对象的引用</span><br><br>  <span class="hljs-comment">// Copy-and-Swap ，保证异常安全</span><br>  <span class="hljs-function">String <span class="hljs-title">temp</span><span class="hljs-params">(other)</span></span>; <span class="hljs-comment">// 使用拷贝构造函数创建一个临时副本</span><br>  <span class="hljs-built_in">swap</span>(temp);           <span class="hljs-comment">// 与临时副本交换内部数据</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// 临时副本 temp 在此处被析构，从而释放了旧内存</span><br>&#125;<br><br><span class="hljs-comment">// 移动构造函数</span><br><span class="hljs-comment">// 当从一个临时对象(rvalue)构造时调用, 例如 s1 = std::move(s2) 或来自函数返回</span><br>String::<span class="hljs-built_in">String</span>(String&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br> : <span class="hljs-built_in">m_data</span>(other.m_data), <span class="hljs-built_in">m_size</span>(other.m_size)<br>&#123;<br>    other.m_data = <span class="hljs-literal">nullptr</span>;<br>    other.m_size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 移动赋值运算符</span><br><span class="hljs-comment">// 当从一个临时对象赋值时调用</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(String&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span>[] m_data; <span class="hljs-comment">// 不同于移动构造（this还没被创建），这里需要删掉原本的m_data</span><br>    m_data = other.m_data;<br>    m_size = other.m_size;<br>    other.m_data = <span class="hljs-literal">nullptr</span>;<br>    other.m_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::swap</span><span class="hljs-params">(String&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    std::<span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    std::<span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">String::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_size; &#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">String::c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125; <span class="hljs-comment">// 用于与C函数(如printf)交互</span><br><br><span class="hljs-comment">// 拼接 (s1 + s2)</span><br><span class="hljs-comment">// 这里把加号重载放在成员函数其实不合适，因为这样的话当前指针只能作为左操作数，但实际上类似+/==/!=这些操作需要对称性，实际写成非成员函数更好。又因为需要访问private成员，所以可以写成友元函数。</span><br><span class="hljs-comment">// 算术运算符（如 +, -, *, /）和 关系运算符（如 ==, &lt;, !=）：通常建议实现为非成员函数。</span><br><span class="hljs-comment">// 复合赋值运算符（如 +=, -=, *=, /=）：必须实现为类成员函数。</span><br>String String::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-type">size_t</span> new_size = m_size + other.m_size;<br>    <span class="hljs-type">char</span>* new_buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[new_size + <span class="hljs-number">1</span>];<br><br>    std::<span class="hljs-built_in">strcpy</span>(new_buffer, m_data); <span class="hljs-comment">// 复制第一个字符串</span><br>    std::<span class="hljs-built_in">strcat</span>(new_buffer, other.m_data); <span class="hljs-comment">// 拼接第二个字符串</span><br>    <span class="hljs-function">String <span class="hljs-title">result</span><span class="hljs-params">(new_buffer)</span></span>; <span class="hljs-comment">// 调用构造函数从新 buffer 创建一个 String</span><br>    <span class="hljs-keyword">delete</span>[] new_buffer; <span class="hljs-comment">// 释放临时 buffer</span><br><br>    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回结果 (编译器会使用 RVO/NRVO 或移动构造, 避免再次复制)</span><br>&#125;<br><br><span class="hljs-comment">// 比较</span><br><span class="hljs-type">bool</span> String::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">// 如果两个字符串相等，strcmp 返回0；如果str1 &lt; str2，strcmp返回负数；如果str1 &gt; str2，strcmp返回正数</span><br>    <span class="hljs-comment">// strncmp(str1, str2, n)	比较前n个字符</span><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">strcmp</span>(m_data, other.m_data) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> String::<span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> String&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<br>&#125;<br><br><span class="hljs-comment">// 元素访问 (未做边界检查)</span><br><span class="hljs-type">char</span>&amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>    <span class="hljs-keyword">return</span> m_data[index];<br>&#125;<br><br><span class="hljs-comment">// const 版本 (用于 const String 对象)</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> m_data[index];<br>&#125;<br><br><span class="hljs-comment">// -----------------------------------------------------------------------------</span><br><span class="hljs-comment">// 友元函数的实现</span><br><span class="hljs-comment">// -----------------------------------------------------------------------------</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> String&amp; str) &#123;<br>    <span class="hljs-comment">// String 是 os 的友元, 所以可以访问私有成员 m_data</span><br>    os &lt;&lt; str.m_data;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1. 构造函数:\n&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;World&quot;</span>)</span></span>;<br>    String s_empty;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s_empty: &#x27;&quot;</span> &lt;&lt; s_empty &lt;&lt; <span class="hljs-string">&quot;&#x27;\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;2. 拷贝构造:\n&quot;</span>;<br>    String s3 = s1; <span class="hljs-comment">// 调用拷贝构造</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s3 (s1的拷贝): &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    s3[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;修改 s3 后, s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="hljs-string">&quot; (s1 应该不变: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;)\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3. 拷贝赋值:\n&quot;</span>;<br>    String s4;<br>    s4 = s2; <span class="hljs-comment">// 调用拷贝赋值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s4 (s2的拷贝): &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;4. 拼接 (operator+):\n&quot;</span>;<br>    String s5 = s1 + <span class="hljs-string">&quot; &quot;</span> + s2 + <span class="hljs-string">&quot;!&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s5: &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;5. 比较 (operator==):\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 == s3? &quot;</span> &lt;&lt; (s1 == s3) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s2 == s4? &quot;</span> &lt;&lt; (s2 == s4) &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;6. 移动构造 (Move):\n&quot;</span>;<br>    <span class="hljs-comment">// createString(&quot;Temporary&quot;) 返回一个临时对象 (rvalue)</span><br>    <span class="hljs-comment">// s6 通过移动构造函数&quot;窃取&quot;该临时对象的内容</span><br>    String s6 = <span class="hljs-built_in">createString</span>(<span class="hljs-string">&quot;Temporary&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s6 (移动而来): &quot;</span> &lt;&lt; s6 &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;7. 移动赋值 (Move):\n&quot;</span>;<br>    s_empty = <span class="hljs-built_in">createString</span>(<span class="hljs-string">&quot;Another one&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s_empty (移动而来): &quot;</span> &lt;&lt; s_empty &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;8. 访问器:\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s5 的长度: &quot;</span> &lt;&lt; s<span class="hljs-number">5.l</span>ength() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s5 的 C-String: %s\n\n&quot;</span>, s<span class="hljs-number">5.</span><span class="hljs-built_in">c_str</span>());<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;程序结束, 析构函数将被自动调用。\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="3-list">3. List</h1>
<h1 id="4-vector">4. vector</h1>
<h1 id="5-thread-pool">5. Thread pool</h1>
<h1 id="6-mulit-thread-examples">6. Mulit-thread examples</h1>
<h2 id="1-print-odd-and-even-numbers-alternately-1~10">(1) Print odd and even numbers alternately (1~10)</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>std::mutex mtx; <span class="hljs-comment">// 全局互斥锁</span><br>std::condition_variable cv; <span class="hljs-comment">// 条件变量</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前打印的数字</span><br><br><span class="hljs-comment">// 打印奇数的函数。只要 count 是奇数，就打印；如果是偶数，就睡觉。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_odd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-comment">// 第二个参数（Lambda表达式）就是谓词 (Predicate)，也就是“条件”。如果条件不满足，线程就睡去。</span><br>        <span class="hljs-comment">// 要传入 lock是因为线程在睡眠前必须释放锁，否则别的线程（比如 print_even）永远拿不到锁，也就无法修改 count，程序就会死锁。wait 自动完成了“释放锁-睡眠”和“唤醒-加锁”的过程。</span><br>        cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || count &gt; <span class="hljs-number">10</span>; &#125;);<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread A: &quot;</span> &lt;&lt; count++ &lt;&lt; std::endl;<br>        cv.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 唤醒所有在cv上等待线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印偶数的函数。只要 count 是偶数，就打印；如果是奇数，我就睡觉。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_even</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || count &gt; <span class="hljs-number">10</span>; &#125;);<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread B: &quot;</span> &lt;&lt; count++ &lt;&lt; std::endl;<br>        cv.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 唤醒所有等待线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_odd)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_even)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>第一轮：Count = 1
<ul>
<li>竞争锁：t1（奇数线程）和 t2（偶数线程）启动。假设 t2 先抢到了锁 mtx。</li>
<li>t2 检查条件：t2 执行 cv.wait，它的条件是 count % 2 == 0（是否为偶数）。当前 count 是 1（奇数），条件为 false。</li>
<li>动作：t2 释放锁，进入睡眠状态（阻塞）。</li>
<li>t1 获得锁：因为 t2 释放了锁，t1 抢到了锁。</li>
<li>t1 检查条件：t1 执行 cv.wait，条件是 count % 2 == 1（是否为奇数）。当前 count 是 1，条件为 true。</li>
<li>动作：cv.wait 直接返回，t1 继续执行。</li>
<li>t1 打印：输出 Thread A: 1。</li>
<li>t1 修改状态：count 变为 2。</li>
<li>t1 唤醒别人：执行 cv.notify_all()。这就像大喊一声：“醒醒！状态变了！”此时睡眠中的 t2 被唤醒，但它还在等待锁。</li>
<li>t1 释放锁：t1 的循环结束，或者下一次 wait 时，锁被释放。</li>
</ul>
</li>
<li>第二轮：Count = 2
<ul>
<li>t1 再次检查：假设 t1 运行极快，又抢到了锁。它进入 cv.wait，检查 count % 2 == 1。当前 count 是 2，条件为 false。</li>
<li>动作：t1 释放锁，乖乖去睡眠。</li>
<li>t2 获得锁：t2 刚才被唤醒了，现在终于抢到了锁。t2 重新检查：t2 从沉睡中醒来（wait 内部），它做的第一件事是检查条件 count % 2 == 0。当前 count 是 2，条件为 true。</li>
<li>动作：t2 继续执行。</li>
<li>t2 打印：输出 Thread B: 2。</li>
<li>t2 修改状态：count 变为 3。</li>
<li>t2 唤醒别人：cv.notify_all() 唤醒 t1。<br>
这个过程一直重复，直到 count &gt; 10。</li>
</ul>
</li>
</ul>
<h2 id="2-print-abc-alternately">(2) Print A/B/C alternately</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-comment">// 共享资源</span><br>std::mutex mtx;<br>std::condition_variable cv;<br><span class="hljs-type">int</span> state = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0: A执行, 1: B执行, 2: C执行</span><br><br><span class="hljs-comment">// 打印次数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LOOP_COUNT = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用的打印函数</span><br><span class="hljs-comment"> * @param ch: 要打印的字符 (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="hljs-comment"> * @param target_state: 当前线程需要等待的目标状态 (0, 1, 2)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_char</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> target_state)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;<br>        <span class="hljs-comment">// 1. 加锁</span><br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br><br>        <span class="hljs-comment">// 2. 等待条件满足</span><br>        <span class="hljs-comment">// 谓词：只有当全局 state 等于我自己的 target_state 时，我才醒来干活</span><br>        <span class="hljs-comment">// 否则释放锁并睡眠</span><br>        cv.<span class="hljs-built_in">wait</span>(lock, [target_state] &#123;<br>            <span class="hljs-keyword">return</span> state == target_state;<br>        &#125;);<br><br>        <span class="hljs-comment">// 3. 执行任务</span><br>        std::cout &lt;&lt; ch &lt;&lt; std::flush; <span class="hljs-comment">// 使用 flush 确保立即输出而不是留在缓冲区</span><br><br>        <span class="hljs-comment">// 4. 修改状态，移交控制权</span><br>        <span class="hljs-comment">// 0 -&gt; 1, 1 -&gt; 2, 2 -&gt; 0</span><br>        state = (state + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br><br>        <span class="hljs-comment">// 5. 唤醒其他所有等待线程</span><br>        <span class="hljs-comment">// 必须用 notify_all，防止只唤醒了错误的那个线程（比如A唤醒了C，C发现不对又睡了，B没醒）</span><br>        cv.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 启动三个线程</span><br>    <span class="hljs-comment">// 线程A: 等待状态 0</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_char, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 线程B: 等待状态 1</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_char, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-comment">// 线程C: 等待状态 2</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(print_char, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">2</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-producer-consumer-pattern">(3) Producer-Consumer Pattern</h2>
<p>并发编程中最经典、最常用的设计模式之一。它用于解决两个或多个线程（或进程）之间如何安全、高效地交换数据的问题。</p>
<p>这个模式由三个主要部分组成：</p>
<ul>
<li>生产者 (Producer)：
<ul>
<li>负责生成数据（生产“任务”、“消息”或“产品”）。</li>
<li>它将数据放入缓冲区。</li>
</ul>
</li>
<li>消费者 (Consumer)：
<ul>
<li>负责处理数据。</li>
<li>它从缓冲区取出数据并执行相应的业务逻辑。</li>
</ul>
</li>
<li>缓冲区 (Buffer/Queue)：
<ul>
<li>这是两者之间的中介，通常是一个线程安全的队列（Queue）。</li>
<li>起到了解耦的作用。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-comment">// 共享缓冲区</span><br>std::queue&lt;<span class="hljs-type">int</span>&gt; buffer;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_BUFFER_SIZE = <span class="hljs-number">5</span>; <span class="hljs-comment">// 缓冲区最大容量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_PRODUCTION = <span class="hljs-number">10</span>; <span class="hljs-comment">// 最多生产出的产品总数</span><br><br><span class="hljs-comment">// 同步原语</span><br>std::mutex mtx;<br>std::condition_variable cv_not_full;  <span class="hljs-comment">// 条件：缓冲区不满 (生产者等待)</span><br>std::condition_variable cv_not_empty; <span class="hljs-comment">// 条件：缓冲区不空 (消费者等待)</span><br><br><span class="hljs-comment">// 生产者函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_PRODUCTION; ++i) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br><br>        <span class="hljs-comment">// 1. 等待缓冲区不满 (如果满了就睡)</span><br>        cv_not_full.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> buffer.<span class="hljs-built_in">size</span>() &lt; MAX_BUFFER_SIZE; &#125;);<br><br>        <span class="hljs-comment">// 2. 生产数据</span><br>        buffer.<span class="hljs-built_in">push</span>(i);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;生产者 &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; 生产了: &quot;</span> &lt;&lt; i<br>                  &lt;&lt; <span class="hljs-string">&quot; (当前库存: &quot;</span> &lt;&lt; buffer.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br><br>        <span class="hljs-comment">// 3. 唤醒消费者 (告诉他们有东西吃了)</span><br>        cv_not_empty.<span class="hljs-built_in">notify_one</span>();<br><br>        <span class="hljs-comment">// lock 析构，自动解锁</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br><br>        <span class="hljs-comment">// 1. 等待缓冲区不空 (如果空了就睡)</span><br>        cv_not_empty.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> !buffer.<span class="hljs-built_in">empty</span>(); &#125;);<br><br>        <span class="hljs-comment">// 2. 消费数据</span><br>        <span class="hljs-type">int</span> data = buffer.<span class="hljs-built_in">front</span>();<br>        buffer.<span class="hljs-built_in">pop</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;  消费者 &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; 消费了: &quot;</span> &lt;&lt; data<br>                  &lt;&lt; <span class="hljs-string">&quot; (当前库存: &quot;</span> &lt;&lt; buffer.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br><br>        <span class="hljs-comment">// 3. 唤醒生产者 (告诉他们有空位了)</span><br>        cv_not_full.<span class="hljs-built_in">notify_one</span>();<br><br>        <span class="hljs-comment">// 模拟退出条件 (实际业务中可能有专门的停止信号)</span><br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-number">9</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">p</span><span class="hljs-params">(producer, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">c</span><span class="hljs-params">(consumer, <span class="hljs-number">1</span>)</span></span>;<br><br>    p.<span class="hljs-built_in">join</span>();<br>    c.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="7-memory-pool">7. Memory Pool</h1>
<h1 id="8-smart-pointers">8. Smart Pointers</h1>
<h2 id="1-unique_ptr">(1) unique_ptr</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span>       <span class="hljs-comment">// 用于 std::tuple (实现 EBO)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>     <span class="hljs-comment">// 用于 std::move, std::forward</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>  <span class="hljs-comment">// 用于 std::function (测试用)</span></span><br><br><span class="hljs-comment">// 1. 默认删除器 (Default Deleter)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DefaultDelete</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. MyUniquePtr 实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> D = DefaultDelete&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> MyUniquePtr &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> pointer = T*;<br>    <span class="hljs-keyword">using</span> deleter_type = D;<br><br>    <span class="hljs-comment">// --- 构造函数 ---</span><br><br>    <span class="hljs-comment">// 默认构造 (nullptr)</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MyUniquePtr</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> : _data(nullptr, D()) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 这里的 nullptr_t 是为了支持 MyUniquePtr&lt;T&gt; p = nullptr; 因为在标准的 unique_ptr 设计中，为了安全起见，从裸指针构造必须是显式 (explicit) 的，也就是说不允许nullptr隐式转换为unique_ptr。</span><br>    <span class="hljs-comment">// 但注释掉下面这行执行MyUniquePtr&lt;int&gt; p(nullptr);不会报错。这是因为这一句中不涉及nullptr隐式转换为unique_ptr而是调用普通的构造函数，nullptr隐式转换为T*。</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MyUniquePtr</span><span class="hljs-params">(std::<span class="hljs-type">nullptr_t</span>)</span> <span class="hljs-keyword">noexcept</span> : _data(nullptr, D()) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 从裸指针构造</span><br>    <span class="hljs-comment">// 为什么这个函数不用constexpr修饰而上面那个函数需要？</span><br>    <span class="hljs-comment">// constexpr 的核心目的是告诉编译器：“这个函数或构造函数，有可能在编译期间就计算出结果。”如果一个对象被声明为 constexpr，它会被放入程序的 只读数据段 或 BSS段，在程序启动前就已经准备好了，没有任何运行时的 CPU 开销。</span><br>    <span class="hljs-comment">// nullptr 是编译期确定的，而 new 出来的指针地址通常是运行时才确定的。试想一种用法：MyUniquePtr&lt;Foo&gt; p1(new Foo(1));。</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyUniquePtr</span><span class="hljs-params">(pointer p)</span> <span class="hljs-keyword">noexcept</span> : _data(p, D()) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 从裸指针 + 删除器构造</span><br>    <span class="hljs-comment">// 使用 std::forward 实现完美转发，支持左值引用和右值引用的删除器。为了让编译器在初始化 tuple 内部的 D 对象时，能够正确地选择是调用 拷贝构造 还是 移动构造。</span><br>    <span class="hljs-comment">// 为什么不用explicit修饰？</span><br>    <span class="hljs-comment">// 1）双参数，不太容易出现隐式转换的问题</span><br>    <span class="hljs-comment">// 2）不加 explicit，可以使用 &#123;&#125; 初始化列表语法来进行赋值或返回。如：MyUniquePtr&lt;int, MyDel&gt; p = &#123;new int(1), MyDel()&#125;;</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-built_in">MyUniquePtr</span>(pointer p, U&amp;&amp; d) <span class="hljs-keyword">noexcept</span><br>        : _data(p, std::forward&lt;U&gt;(d)) &#123;&#125;<br><br>    <span class="hljs-comment">// --- 移动语义 (核心) ---</span><br><br>    <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-built_in">MyUniquePtr</span>(MyUniquePtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>        : _data(other.<span class="hljs-built_in">release</span>(), std::forward&lt;D&gt;(other.<span class="hljs-built_in">get_deleter</span>())) &#123;&#125;<br><br>    <span class="hljs-comment">// 移动赋值</span><br>    MyUniquePtr&amp; <span class="hljs-keyword">operator</span>=(MyUniquePtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">reset</span>(other.<span class="hljs-built_in">release</span>());<br>            <span class="hljs-comment">// 注意：通常也应该移动 deleter，虽然无状态 deleter 移动没意义</span><br>            <span class="hljs-built_in">get_deleter</span>() = std::forward&lt;D&gt;(other.<span class="hljs-built_in">get_deleter</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// --- 禁止拷贝 ---</span><br>    <span class="hljs-built_in">MyUniquePtr</span>(<span class="hljs-type">const</span> MyUniquePtr&amp;) = <span class="hljs-keyword">delete</span>;<br>    MyUniquePtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyUniquePtr&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// --- 析构函数 ---</span><br>    ~<span class="hljs-built_in">MyUniquePtr</span>() &#123;<br>        pointer ptr = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(_data);<br>        <span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">get_deleter</span>()(ptr); <span class="hljs-comment">// 调用删除器</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// --- 核心操作 ---</span><br><br>    <span class="hljs-comment">// 释放所有权，返回裸指针，内部置空 (不删除)</span><br>    <span class="hljs-function">pointer <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        pointer ptr = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(_data);<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(_data) = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 重置指针 (删除旧的，接管新的)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(pointer p = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        pointer old_ptr = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(_data);<br>        <span class="hljs-comment">// 只有新旧指针不同才操作，防止 reset(get()) 的自杀行为</span><br>        <span class="hljs-keyword">if</span> (old_ptr != p) &#123;<br>            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(_data) = p;<br>            <span class="hljs-keyword">if</span> (old_ptr) &#123;<br>                <span class="hljs-built_in">get_deleter</span>()(old_ptr);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 交换</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MyUniquePtr&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_data, other._data);<br>    &#125;<br><br>    <span class="hljs-comment">// --- 观察者 ---</span><br><br>    <span class="hljs-function">pointer <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(_data);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取删除器的引用 (支持修改有状态的删除器)</span><br>    <span class="hljs-function">D&amp; <span class="hljs-title">get_deleter</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(_data);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> D&amp; <span class="hljs-title">get_deleter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(_data);<br>    &#125;<br><br>    <span class="hljs-comment">// --- 运算符重载 ---</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>() != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">get</span>();<br>    &#125;<br><br>    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 使用 tuple 存储 &lt;指针, 删除器&gt;</span><br>    <span class="hljs-comment">// std::tuple 会利用 EBO (空基类优化)。</span><br>    <span class="hljs-comment">// 如果 D 是空类(如 DefaultDelete)，tuple 的大小通常等于 sizeof(T*)</span><br>    std::tuple&lt;T*, D&gt; _data;<br>&#125;;<br><br><span class="hljs-comment">// --- 测试类 ---</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Foo(&quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;) Constructed\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Foo(&quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;) Destructed\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// --- 测试代码 ---</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">custom_deleter_func</span><span class="hljs-params">(Foo* p)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Custom function deleter called for Foo(&quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;--- 1. Basic Usage ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-function">MyUniquePtr&lt;Foo&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">1</span>))</span></span>;<br>        p1-&gt;<span class="hljs-built_in">greet</span>();<br>    &#125; <span class="hljs-comment">// p1 析构</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 2. EBO Check (Size Optimization) ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-comment">// 默认删除器是空类，MyUniquePtr 应该只有 8 字节 (64位系统)</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Size of raw pointer: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Foo*) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Size of MyUniquePtr (Default Deleter): &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(MyUniquePtr&lt;Foo&gt;) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 3. Custom Deleter (Functor) ---\n&quot;</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VerboseDeleter</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Foo* p)</span> <span class="hljs-type">const</span> </span>&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;VerboseDeleter deleting Foo(&quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>            <span class="hljs-keyword">delete</span> p;<br>        &#125;<br>    &#125;;<br>    &#123;<br>        <span class="hljs-comment">// VerboseDeleter 也是空类，仍应享受 EBO</span><br>        <span class="hljs-function">MyUniquePtr&lt;Foo, VerboseDeleter&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">2</span>))</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Size of MyUniquePtr (Empty Functor): &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-comment">// p2 析构</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 4. Custom Deleter (Lambda) ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-keyword">auto</span> lambda_del = [](Foo* p) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Lambda deleter deleting Foo(&quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>            <span class="hljs-keyword">delete</span> p;<br>        &#125;;<br>        <span class="hljs-comment">// lambda 类型作为模板参数</span><br>        <span class="hljs-function">MyUniquePtr&lt;Foo, <span class="hljs-title">decltype</span><span class="hljs-params">(lambda_del)</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">3</span>), lambda_del)</span></span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 5. Custom Deleter (Function Pointer) ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-comment">// 函数指针占 8 字节，所以 MyUniquePtr 会变成 16 字节</span><br>        <span class="hljs-function">MyUniquePtr&lt;Foo, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(Foo*)</span>&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">4</span>), custom_deleter_func)</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Size of MyUniquePtr (Func Ptr): &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p4) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 6. Move Semantics ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-function">MyUniquePtr&lt;Foo&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">5</span>))</span></span>;<br>        MyUniquePtr&lt;Foo&gt; p6 = std::<span class="hljs-built_in">move</span>(p5); <span class="hljs-comment">// p5 被掏空</span><br>        <span class="hljs-keyword">if</span> (!p5) std::cout &lt;&lt; <span class="hljs-string">&quot;p5 is null now\n&quot;</span>;<br>        p6-&gt;<span class="hljs-built_in">greet</span>();<br>    &#125; <span class="hljs-comment">// p6 析构</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 tuple 存储裸指针和 deleter 实现 EBO (空基类优化)。如果删除器是空的（例如默认删除器或无状态的 Lambda），unique_ptr 的大小应该和裸指针一样（8 字节），而不是更大。</p>
<h2 id="2-shared_ptr-amp-weak_ptr">(2) shared_ptr &amp; weak_ptr</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::swap</span></span><br><br><span class="hljs-comment">// 前置声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span>;<br><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-comment">// 1. 控制块 (Control Block)</span><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-comment">// 它的生命周期独立于 T 对象。</span><br><span class="hljs-comment">// T 对象可能已经挂了，但只要有 WeakPtr 在，控制块就得活着。</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ControlBlock</span> &#123;<br>    <span class="hljs-type">size_t</span> shared_count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 强引用计数</span><br>    <span class="hljs-type">size_t</span> weak_count = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 弱引用计数</span><br>    T* ptr = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// 指向实际对象的指针</span><br><br>    <span class="hljs-built_in">ControlBlock</span>(T* p) : <span class="hljs-built_in">shared_count</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">weak_count</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br><br>    <span class="hljs-comment">// 只有当强引用和弱引用都为0时，控制块才自杀</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_delete_block</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (shared_count == <span class="hljs-number">0</span> &amp;&amp; weak_count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 自杀</span><br>            <span class="hljs-comment">// std::cout &lt;&lt; &quot;  (ControlBlock deleted)\n&quot;;</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-comment">// 2. Shared Ptr</span><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span> &#123;<br>    <span class="hljs-comment">// 让 WeakPtr 能访问私有成员 (主要是构造函数)</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span>&lt;T&gt;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// --- 构造函数 ---</span><br><br>    <span class="hljs-comment">// 默认构造</span><br>    <span class="hljs-built_in">MySharedPtr</span>() : _ptr(<span class="hljs-literal">nullptr</span>), _cb(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 从裸指针构造 (启动一个新的控制块)</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MySharedPtr</span><span class="hljs-params">(T* p)</span> : _ptr(p) &#123;</span><br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            _cb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ControlBlock</span>&lt;T&gt;(p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _cb = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造 (增加引用计数)</span><br>    <span class="hljs-built_in">MySharedPtr</span>(<span class="hljs-type">const</span> MySharedPtr&amp; other) : _ptr(other._ptr), _cb(other._cb) &#123;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            _cb-&gt;shared_count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MySharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放旧的</span><br>            _ptr = other._ptr;<br>            _cb = other._cb;<br>            <span class="hljs-keyword">if</span> (_cb) &#123;<br>                _cb-&gt;shared_count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造 (接管资源)</span><br>    <span class="hljs-built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : _ptr(other._ptr), _cb(other._cb) &#123;<br>        other._ptr = <span class="hljs-literal">nullptr</span>;<br>        other._cb = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值</span><br>    <span class="hljs-comment">// MySharedPtr&amp; operator=(MySharedPtr&amp;&amp; other) noexcept &#123;</span><br>    <span class="hljs-comment">//     if (this != &amp;other) &#123;</span><br>    <span class="hljs-comment">//         release();</span><br>    <span class="hljs-comment">//         _ptr = other._ptr;</span><br>    <span class="hljs-comment">//         _cb = other._cb;</span><br>    <span class="hljs-comment">//         other._ptr = nullptr;</span><br>    <span class="hljs-comment">//         other._cb = nullptr;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 移动赋值</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 构造一个临时对象接管 other，然后跟我交换</span><br>        <span class="hljs-built_in">MySharedPtr</span>(std::<span class="hljs-built_in">move</span>(other)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MySharedPtr</span>() &#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// --- 常用操作 ---</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _ptr; &#125;<br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *_ptr; &#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> _ptr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _cb ? _cb-&gt;shared_count : <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<span class="hljs-keyword">return</span> _ptr != <span class="hljs-literal">nullptr</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MySharedPtr&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_ptr, other._ptr);<br>        std::<span class="hljs-built_in">swap</span>(_cb, other._cb);<br>    &#125;<br>    <span class="hljs-comment">// reset 为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-comment">// 构造一个空的临时对象，和自己交换</span><br>        <span class="hljs-comment">// 交换后，临时对象持有我不想要的旧资源</span><br>        <span class="hljs-comment">// 函数结束，临时对象析构，自动释放旧资源</span><br>        <span class="hljs-built_in">MySharedPtr</span>().<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// reset 为新指针</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* p)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造一个管理新指针 p 的临时对象，和自己交换</span><br>        <span class="hljs-comment">// 1. 临时对象接管 p (创建新 ControlBlock)</span><br>        <span class="hljs-comment">// 2. 交换：我拿到了新资源，临时对象拿到了我的旧资源</span><br>        <span class="hljs-comment">// 3. 临时对象析构 -&gt; 释放旧资源</span><br>        <span class="hljs-built_in">MySharedPtr</span>(p).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T* _ptr;              <span class="hljs-comment">// 直接持有对象指针，为了效率 (operator-&gt;)</span><br>    ControlBlock&lt;T&gt;* _cb; <span class="hljs-comment">// 持有控制块</span><br><br>    <span class="hljs-comment">// 这是一个私有构造函数，专门给 WeakPtr::lock() 使用</span><br>    <span class="hljs-comment">// 这种情况下，我们需要从现有的控制块创建一个 SharedPtr，并增加计数</span><br>    <span class="hljs-built_in">MySharedPtr</span>(T* p, ControlBlock&lt;T&gt;* cb) : _ptr(p), _cb(cb) &#123;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            _cb-&gt;shared_count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            <span class="hljs-comment">// 1. 减少强引用计数</span><br>            _cb-&gt;shared_count--;<br><br>            <span class="hljs-comment">// 2. 如果强引用归零，释放实际对象</span><br>            <span class="hljs-keyword">if</span> (_cb-&gt;shared_count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> _ptr;<br>                _ptr = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-comment">// std::cout &lt;&lt; &quot;  (Object deleted)\n&quot;;</span><br>            &#125;<br><br>            <span class="hljs-comment">// 3. 检查是否需要释放控制块 (可能还有 WeakPtr 活着)</span><br>            _cb-&gt;<span class="hljs-built_in">check_delete_block</span>();<br>        &#125;<br>        _cb = <span class="hljs-literal">nullptr</span>;<br>        _ptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-comment">// 3. Weak Ptr</span><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// --- 构造函数 ---</span><br><br>    <span class="hljs-built_in">MyWeakPtr</span>() : _ptr(<span class="hljs-literal">nullptr</span>), _cb(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 从 SharedPtr 构造 (不增加 shared_count，只增加 weak_count)</span><br>    <span class="hljs-built_in">MyWeakPtr</span>(<span class="hljs-type">const</span> MySharedPtr&lt;T&gt;&amp; sp) : _ptr(sp._ptr), _cb(sp._cb) &#123;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            _cb-&gt;weak_count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-built_in">MyWeakPtr</span>(<span class="hljs-type">const</span> MyWeakPtr&amp; other) : _ptr(other._ptr), _cb(other._cb) &#123;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            _cb-&gt;weak_count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-built_in">MyWeakPtr</span>(MyWeakPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : _ptr(other._ptr), _cb(other._cb) &#123;<br>        other._ptr = <span class="hljs-literal">nullptr</span>;<br>        other._cb = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyWeakPtr</span>() &#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// --- 赋值 ---</span><br>    <span class="hljs-comment">// 拷贝赋值 (WeakPtr = WeakPtr)</span><br>    MyWeakPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyWeakPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">release</span>();<br>            _ptr = other._ptr;<br>            _cb = other._cb;<br>            <span class="hljs-keyword">if</span> (_cb) &#123;<br>                _cb-&gt;weak_count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 转换赋值 (WeakPtr = SharedPtr)</span><br>    MyWeakPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MySharedPtr&lt;T&gt;&amp; sp) &#123;<br>        <span class="hljs-built_in">release</span>();<br>        _ptr = sp._ptr;<br>        _cb = sp._cb;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            _cb-&gt;weak_count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值</span><br>    <span class="hljs-comment">// MyWeakPtr&amp; operator=(MyWeakPtr&amp;&amp; other) noexcept &#123;</span><br>    <span class="hljs-comment">//     if (this != &amp;other) &#123;</span><br>    <span class="hljs-comment">//         // 1. 释放自己当前的观测 (引用计数 -1)</span><br>    <span class="hljs-comment">//         release();</span><br><br>    <span class="hljs-comment">//         // 2. 窃取 other 的资源</span><br>    <span class="hljs-comment">//         _ptr = other._ptr;</span><br>    <span class="hljs-comment">//         _cb = other._cb;</span><br><br>    <span class="hljs-comment">//         // 3. 将 other 置空 (防止 other 析构时减少引用计数)</span><br>    <span class="hljs-comment">//         other._ptr = nullptr;</span><br>    <span class="hljs-comment">//         other._cb = nullptr;</span><br><br>    <span class="hljs-comment">//         // 关键点：这里不需要 _cb-&gt;weak_count++</span><br>    <span class="hljs-comment">//         // 因为我们是直接接管了 other 的计数份额</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 移动赋值 (Move-and-Swap)</span><br>    MyWeakPtr&amp; <span class="hljs-keyword">operator</span>=(MyWeakPtr&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 1. 利用移动构造，创建一个临时对象 temp 接管 other 的资源</span><br>        <span class="hljs-comment">// 2. temp 和 *this 交换</span><br>        <span class="hljs-comment">//    - *this 拿到了新资源</span><br>        <span class="hljs-comment">//    - temp 拿到了旧资源</span><br>        <span class="hljs-built_in">MyWeakPtr</span>(std::<span class="hljs-built_in">move</span>(other)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-comment">// 3. 函数结束，temp 析构</span><br>        <span class="hljs-comment">//    自动调用 release() 释放旧资源的弱引用计数</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// --- 核心功能 ---</span><br><br>    <span class="hljs-comment">// 检查对象是否已经不存在了</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !_cb || _cb-&gt;shared_count == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 提升为 SharedPtr</span><br>    <span class="hljs-function">MySharedPtr&lt;T&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">expired</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">MySharedPtr</span>&lt;T&gt;(); <span class="hljs-comment">// 返回空的 SharedPtr</span><br>        &#125;<br>        <span class="hljs-comment">// 使用 SharedPtr 的私有构造函数</span><br>        <span class="hljs-comment">// 注意：这里存在多线程竞争风险，真实实现需要原子操作 (CAS)</span><br>        <span class="hljs-comment">// 来确保在检查 expired 和增加引用计数之间，对象没有被其他线程删掉。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">MySharedPtr</span>&lt;T&gt;(_ptr, _cb);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 交换成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MyWeakPtr&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_ptr, other._ptr);<br>        std::<span class="hljs-built_in">swap</span>(_cb, other._cb);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T* _ptr;<br>    ControlBlock&lt;T&gt;* _cb;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_cb) &#123;<br>            _cb-&gt;weak_count--;<br>            <span class="hljs-comment">// WeakPtr 离开时，只检查是否需要删除控制块</span><br>            <span class="hljs-comment">// 它永远不会负责删除实际对象 T</span><br>            _cb-&gt;<span class="hljs-built_in">check_delete_block</span>();<br>        &#125;<br>        _cb = <span class="hljs-literal">nullptr</span>;<br>        _ptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ------------------------------------------------------</span><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-comment">// ------------------------------------------------------</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    MyWeakPtr&lt;Node&gt; neighbor; <span class="hljs-comment">// 使用 WeakPtr 防止循环引用</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node(&quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;) Constructed\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node(&quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;) Destructed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;--- 1. Basic SharedPtr ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-function">MySharedPtr&lt;Node&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>))</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 use_count: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 1</span><br><br>        MySharedPtr&lt;Node&gt; p2 = p1;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 use_count: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 2</span><br>    &#125; <span class="hljs-comment">// p2 析构(2-&gt;1), p1 析构(1-&gt;0) -&gt; Node(1) 删除</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 2. WeakPtr Lock ---\n&quot;</span>;<br>    MyWeakPtr&lt;Node&gt; wp;<br>    &#123;<br>        <span class="hljs-function">MySharedPtr&lt;Node&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">3</span>))</span></span>;<br>        wp = p3;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p3 use_count: &quot;</span> &lt;&lt; p<span class="hljs-number">3.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 1 (weak 不增加 use_count)</span><br><br>        <span class="hljs-comment">// 尝试 lock</span><br>        <span class="hljs-keyword">if</span> (MySharedPtr&lt;Node&gt; temp = wp.<span class="hljs-built_in">lock</span>()) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Lock success: Node(&quot;</span> &lt;&lt; temp-&gt;id &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Temp use_count: &quot;</span> &lt;&lt; temp.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 2</span><br>        &#125;<br>    &#125; <span class="hljs-comment">// p3 析构 -&gt; Node(3) 删除 (虽然 wp 还在，但强引用为0)</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Exited scope. checking wp...\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (wp.<span class="hljs-built_in">expired</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;wp is expired (Object is gone)\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (wp.<span class="hljs-built_in">lock</span>()) &#123;<br>        <span class="hljs-comment">// 不应该进这里</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Behavior unexpected.\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Lock failed as expected.\n&quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n--- 3. Cycle Reference Breaking ---\n&quot;</span>;<br>    &#123;<br>        <span class="hljs-function">MySharedPtr&lt;Node&gt; <span class="hljs-title">nodeA</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">100</span>))</span></span>;<br>        <span class="hljs-function">MySharedPtr&lt;Node&gt; <span class="hljs-title">nodeB</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">200</span>))</span></span>;<br><br>        <span class="hljs-comment">// 建立循环引用: A -&gt; B, B -&gt; A</span><br>        <span class="hljs-comment">// 如果 neighbor 是 SharedPtr，这里会内存泄漏</span><br>        <span class="hljs-comment">// 但因为 neighbor 是 WeakPtr，所以能正常析构</span><br>        nodeA-&gt;neighbor = nodeB;<br>        nodeB-&gt;neighbor = nodeA;<br>    &#125;<br>    <span class="hljs-comment">// 正常析构：</span><br>    <span class="hljs-comment">// NodeA 引用归零 -&gt; 析构 -&gt; 释放 NodeA 里的 WeakPtr(指向B) -&gt; WeakCnt(B)--</span><br>    <span class="hljs-comment">// NodeB 引用归零 -&gt; 析构 -&gt; 释放 NodeB 里的 WeakPtr(指向A) -&gt; WeakCnt(A)--</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="9">9.</h1>
<h2 id="1-lru">(1) LRU</h2>
<h2 id="2-lfu">(2) LFU</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Programming/" class="category-chain-item">Programming</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Programming/C/" class="category-chain-item">C++</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cpp/" class="print-no-link">#cpp</a>
      
        <a href="/tags/interview/" class="print-no-link">#interview</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ handwritten cases for interviews</div>
      <div>http://example.com/2025/11/17/cpp-handwritten/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>November 17, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/09/16/GAMES202-L1011-PBR/" title="GAMES 202 - Physically-Based Rendering">
                        <span class="hidden-mobile">GAMES 202 - Physically-Based Rendering</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
