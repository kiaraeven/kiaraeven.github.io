

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/browser_tab.svg">
  <link rel="icon" href="/img/icon/browser_tab.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Go7">
  <meta name="keywords" content="">
  
    <meta name="description" content="Processes &amp; Threads Definition: Process (进程): A program in execution. It has its own memory space. 进程是一个程序的执行过程，进程之间相互独立，每个进程有自己的栈、堆、存储以及数据。操作系统为每个进程分配一个进程控制块（PCB）来管理进程。 Thread: A smaller unit of">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 多线程">
<meta property="og:url" content="http://example.com/2024/12/29/multi-threads/index.html">
<meta property="og:site_name" content="Go7">
<meta property="og:description" content="Processes &amp; Threads Definition: Process (进程): A program in execution. It has its own memory space. 进程是一个程序的执行过程，进程之间相互独立，每个进程有自己的栈、堆、存储以及数据。操作系统为每个进程分配一个进程控制块（PCB）来管理进程。 Thread: A smaller unit of">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-30T04:06:22.217Z">
<meta property="article:modified_time" content="2025-05-21T14:01:10.342Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="threads">
<meta property="article:tag" content="mutex">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++ 多线程 - Go7</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Go7</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Dive in</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background/swim_from_above_2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ 多线程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-29 22:06" pubdate>
          December 29, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.7k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          56 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ 多线程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="processes-amp-threads">Processes &amp; Threads</h1>
<h2 id="definition">Definition:</h2>
<p>Process (进程): A program in execution. It has its own memory space. 进程是一个程序的执行过程，进程之间相互独立，每个进程有自己的栈、堆、存储以及数据。操作系统为每个进程分配一个进程控制块（PCB）来管理进程。</p>
<p>Thread: A smaller unit of a process that can run independently. Threads within a process share the same memory space. 操作系统为每个线程分配一个线程控制块和栈。<strong>线程之间共享全局和堆的数据，每个线程有自己的栈数据</strong>。</p>
<p>C++ Support: C++ supports multithreading through the <thread> library introduced in C++11.</thread></p>
<h2 id="key-differences">Key Differences:</h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Process</th>
<th>Thread</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory</td>
<td>Independent memory space</td>
<td>Shared memory space</td>
</tr>
<tr>
<td>Overhead</td>
<td>High (context switching)</td>
<td>Low (context switching)</td>
</tr>
<tr>
<td>Communication</td>
<td>Inter-process communication (IPC)</td>
<td>Shared memory within the process</td>
</tr>
<tr>
<td>Creation Speed</td>
<td>Slower</td>
<td>Faster</td>
</tr>
</tbody>
</table>
<h2 id="ltthreadgt"><code>&lt;thread&gt;</code></h2>
<p><code>thread(F&amp;&amp; f, Args&amp;&amp;... args);</code><br>
使用这个构造函数来创建线程，它的<em>第一个参数是线程要执行的函数</em>，也就是这个线程的入口函数（线程函数）。线程函数也可以是函数对象、Lambda 对象、类成员函数等可调用的对象。如果 f 是函数对象、Lambda 对象、静态类成员函数等可调用对象，那么<em>Args 中的所有参数是传递给可调用对象的实参</em>。如果第一个参数是类的非静态成员函数，那么<em>Args 中的第一个参数是用于调用这个成员函数的类对象地址，剩余的参数是传递给成员函数的实参</em>。</p>
<p>在线程中线程函数 f 的返回值会被忽略，所以<strong>要获得返回值，需要使用按引用传递的参数()；也可以将返回值存储在类对象的数据成员中或者使用 promise 对象</strong>。</p>
<p>当创建并执行了一个线程后，需要等待这个线程执行完毕才可以结束程序。这个<strong>等待</strong>过程可以通过调用线程对象的 <strong>join</strong> 函数来实现。调用这个函数就会<strong>等待这个线程执行完毕后在这里汇合</strong>。代码执行过程中进入的这种等待状态叫做阻塞。另一种情况，如果在调用 join 之前线程已经执行完毕，那么 join 函数会直接返回而不会进入等待状态。在调用 join 函数时，线程对象的状态必须是<strong>joinable</strong>。也就是说这个线程对象代表的是一个正在执行的线程，或者是执行完毕但是未被合并的线程。我们可以用 joinable 函数来判断一个线程对象是否是可以合并的。只有当 joinable 返回 True 时，调用 join 函数才不会抛出异常。</p>
<p>一个 thread 对象以下情况下是不能被合并的：</p>
<ol>
<li>使用默认构造函数初始化了线程对象。由于没有提供线程的函数，也没有创建可执行的线程，所以这种线程对象只是个空壳。这种对象的用途是通过移动赋值运算符从一个临时右值对象或者一个被移动的对象获得一个可执行的线程。（PS: std::thread() thread 线程对象只能移动赋值或者移动构造，而不能够拷贝构造和拷贝赋值。这样保证了每个 thread 的对象只能代表唯一的一个执行线程）</li>
<li>join()完成的线程。因为一个线程只能被合并一次。</li>
<li>detach()后的线程。调用 detach 函数后，被分离的线程自己在后台运行，主线程不再对它拥有控制权，因此也不能再合并。</li>
<li>被移动的线程对象。使用移动构造，或者移动赋值被移动过的对象不再有可执行的线程，因此也不能被合并。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread function executing\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(threadFunction)</span></span>;  <span class="hljs-comment">// Create a thread</span><br>    t.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// Wait for the thread to finish</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main function\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="线程间通信-inter-thread-communication-itc">线程间通信 (Inter-Thread Communication, ITC)</h1>
<p>C++ 进行线程间通信方法。</p>
<h2 id="共享内存与互斥锁-shared-memory-with-mutexes">共享内存与互斥锁 (Shared Memory with Mutexes)</h2>
<ul>
<li><strong>机制</strong>: 这是最基础的通信方式。线程通过读写共享的内存区域（例如，全局变量、堆上分配的对象）来交换信息。为了防止数据竞争和保证数据一致性，对共享内存的访问通常需要使用互斥锁 (<code>std::mutex</code>, <code>std::recursive_mutex</code>, <code>std::shared_mutex</code> 等) 进行同步。</li>
<li><strong>用途</strong>: 适用于线程间需要共享复杂数据结构或状态的场景。不过，它本身不提供“通知”机制，线程需要主动检查或配合其他同步原语。</li>
<li><strong>关键点</strong>: 必须非常小心地管理锁的粒度和生命周期，以避免死锁和性能瓶颈。</li>
</ul>
<h2 id="条件变量-condition-variables-stdcondition_variable-stdcondition_variable_any">条件变量 (Condition Variables - <code>std::condition_variable</code>, <code>std::condition_variable_any</code>)</h2>
<ul>
<li><strong>机制</strong>: 条件变量允许<strong>一个或多个线程等待某个条件变为真</strong>。它通常与互斥锁一起使用，以保护共享的条件状态。当一个线程<strong>改变了条件状态</strong>后，它可以通知 (<code>notify_one()</code> 或 <code>notify_all()</code>) 正在等待的线程。等待的线程在被唤醒后会重新检查条件。</li>
<li><strong>用途</strong>: 非常适合实现<strong>生产者-消费者模式、任务队列</strong>、或任何需要“等待某事发生”的场景。</li>
<li><strong>关键点</strong>: 等待条件变量时必须持有锁，并且通常在循环中检查条件以处理“伪唤醒”(spurious wakeups)。<code>std::condition_variable</code> 仅能与 <code>std::unique_lock&lt;std::mutex&gt;</code> 一起工作，而 <code>std::condition_variable_any</code> 可以与任何满足基本锁要求的锁类型一起工作。</li>
</ul>
<h2 id="promise-和-future-stdpromise-stdfuture">Promise 和 Future (<code>std::promise</code>, <code>std::future</code>)</h2>
<ul>
<li><strong>机制</strong>: 这对组合提供了一种<strong>单向的、一次性的</strong>通信方式，用于从一个线程（“生产者”或设置 promise 的一方）向另一个线程（“消费者”或持有 future 的一方）传递一个值或异常。<code>std::promise</code> 用于设置值，<code>std::future</code> 用于异步地获取该值（<code>get()</code> 方法会阻塞直到值可用）。</li>
<li><strong>用途</strong>: 非常适合获取异步任务的返回值，或者当一个线程需要等待另一个线程完成某个特定计算并返回结果时。</li>
<li><strong>关键点</strong>: <code>std::future::get()</code> 只能调用一次。如果任务抛出异常，该异常会被存储并在调用 <code>get()</code> 时重新抛出。</li>
</ul>
<h2 id="打包任务-stdpackaged_task">打包任务 (<code>std::packaged_task</code>)</h2>
<ul>
<li><strong>机制</strong>: <code>std::packaged_task</code> 包装一个<strong>可调用</strong>对象（如函数、lambda 表达式），并允许其结果通过 <code>std::future</code> 进行异步访问。可以将 <code>std::packaged_task</code> 看作是可调用对象与其未来结果之间的桥梁。</li>
<li><strong>用途</strong>: 当你需要将一个任务的执行与获取其结果解耦时，例如在线程池中执行任务并稍后获取结果。</li>
<li><strong>关键点</strong>: 创建 <code>packaged_task</code> 后，可以获取其 <code>future</code>，然后可以将任务本身传递给另一个线程执行。</li>
</ul>
<h2 id="异步调用-stdasync">异步调用 (<code>std::async</code>)</h2>
<ul>
<li><strong>机制</strong>: <code>std::async</code> 是一个更高级别的工具，用于<strong>异步地运行一个函数（或可调用对象），并返回一个 <code>std::future</code> 来获取其结果</strong>。它可以自动管理线程的创建和执行（根据启动策略，如 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>）。</li>
<li><strong>用途</strong>: 方便地启动后台任务并获取其结果，而无需手动管理线程和 promise/future 对。</li>
<li><strong>关键点</strong>: <code>std::async</code> 的行为（是否在新线程中立即执行）取决于启动策略。返回的 <code>std::future</code> 的析构函数可能会阻塞，直到异步操作完成（这取决于 <code>std::async</code> 的启动方式和 <code>future</code> 是否被引用）。</li>
</ul>
<h2 id="原子操作-stdatomiclttgt">原子操作 (<code>std::atomic&lt;T&gt;</code>)</h2>
<ul>
<li><strong>机制</strong>: <code>std::atomic</code> 模板类提供了对<strong>简单数据类型</strong>（如整数、布尔值、指针）的原子操作，这些操作是不可分割的，可以避免数据竞争，并且通常比使用互斥锁更轻量级。</li>
<li><strong>用途</strong>: 用于实现无锁数据结构、线程安全的计数器、标志位等。它们可以作为更复杂同步原语的构建块。</li>
<li><strong>关键点</strong>: 需要仔细考虑内存序 (<code>std::memory_order</code>) 以确保正确的同步行为和可见性，这比使用锁要复杂。</li>
</ul>
<h2 id="信号量-semaphores-stdcounting_semaphore-stdbinary_semaphore-c20">信号量 (Semaphores - <code>std::counting_semaphore</code>, <code>std::binary_semaphore</code> C++20)</h2>
<ul>
<li><strong>机制</strong>: 信号量维护一个内部计数器。<code>acquire()</code> (或 <code>P</code> 操作、<code>wait</code>) 会减少计数器（如果<strong>计数器为零则阻塞</strong>），<code>release()</code> (或 <code>V</code> 操作、<code>signal</code>) 会增加计数器（并可能唤醒等待的线程）。二元信号量计数器只能是 0 或 1，行为类似轻量级锁或事件。</li>
<li><strong>用途</strong>: <strong>控制对一组有限资源的访问</strong>（计数信号量），或者作为简单的线程间信号通知机制（二元信号量）。</li>
<li><strong>关键点</strong>: C++20 标准引入，提供了标准化的信号量实现。</li>
</ul>
<h2 id="闩锁-stdlatch-c20">闩锁 (<code>std::latch</code> - C++20)</h2>
<ul>
<li><strong>机制</strong>: 闩锁是一种同步原语，允许任意数量的线程阻塞，直到一个内部计数器减为零。一旦计数器达到零，它就不能被重置，所有等待的线程都会被释放。</li>
<li><strong>用途</strong>: 用于一次性的同步点，例如等待多个工作线程完成其初始化阶段，然后主线程或其他线程才能继续。</li>
<li><strong>关键点</strong>: 是一种“一次性”的屏障。</li>
</ul>
<h2 id="屏障-stdbarrier-c20">屏障 (<code>std::barrier</code> - C++20)</h2>
<ul>
<li><strong>机制</strong>: 屏障允许多个线程在某个执行点上互相等待，直到指定数量的线程都到达该屏障。到达后，屏障可能会执行一个可选的“完成阶段”函数，然后所有线程被释放以继续执行。屏障可以被重用。</li>
<li><strong>用途</strong>: 用于需要多个线程在算法的某个阶段同步的场景，例如在并行计算的迭代步骤之间。</li>
<li><strong>关键点</strong>: 与 latch 不同，屏障是<strong>可以重置和重用</strong>的。</li>
</ul>
<h1 id="promise-amp-future">Promise &amp; Future</h1>
<h2 id="definition">Definition:</h2>
<p>Promise: A provider of a value or exception for a shared state.<br>
Future: An object to retrieve the value of a shared state provided by a promise.</p>
<h2 id="use">Use:</h2>
<p>Synchronizing threads.<br>
Retrieving a result computed asynchronously.</p>
<h3 id="promise">promise</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span> &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">promise</span>;<br>(<span class="hljs-number">1</span>) (since C+<span class="hljs-number">+11</span>)<br><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span> &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">promise</span>&lt;R&amp;&gt;;<br>(<span class="hljs-number">2</span>) (since C+<span class="hljs-number">+11</span>)<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">promise</span>&lt;<span class="hljs-type">void</span>&gt;;<br>(<span class="hljs-number">3</span>) (since C+<span class="hljs-number">+11</span>)<br></code></pre></td></tr></table></figure>
<ol>
<li>Base template. 可以用于两个线程之间按照值传递结果。</li>
<li>Non-void specialization, used to communicate objects between threads. 引用模板可以用于两个线程之间<br>
按照引用来传递结果。</li>
<li>void specialization, used to communicate stateless events. 用于两个线程间发送任务完成的信号而不传递任何数据。</li>
</ol>
<p><strong>Constructor</strong><br>
<code>Promise()</code> promise 的默认构造函数，它会创建一个<strong>共享状态对象 Shared State</strong>。在实际的实现中，使用<code>shared_ptr</code>来封装这个 Shared State 对象，共享状态对象<strong>用于存放要设置的值或异常</strong>。<br>
<code>Promise(promise&amp;&amp; x)</code> 移动构造函数，可以在创建对象的时候将被移动对象 X 的共享状态转移过去。为了保证关联的共享状态的唯一性，promise 类删除了拷贝构造和拷贝复制。</p>
<p><strong>Getting the result</strong><br>
<code>get_future</code> | returns a future associated with the promised result (public member function). 用于创建一个 future 对象。创建时，使用 promise 对象中的共享状态对象作为初始化参数来构造 future 对象，这样<strong>新创建的 future 对象内部也会有一个指向共享状态对象的 shared_ptr 指针</strong>。<strong>future 对象和 promise 对象是一对一的关系，所以只能调用 get_future 函数一次。更确切的说是一个共享状态，只能用于创建一个 future 对象。</strong></p>
<p><strong>Setting the result</strong><br>
<code>set_value</code> | sets the result to specific value (public member function). 用来设置共享状态对象中的值并将其中的状态设置为就绪状态。<br>
<code>set_value_at_thread_exit</code> | sets the result to specific value while delivering the notification only at thread exit (public member function).<br>
<code>set_exception</code> | sets the result to indicate an exception (public member function).<br>
<code>set_exception_at_thread_exit</code> | sets the result to indicate an exception while delivering the notification only at thread exit (public member function)</p>
<h3 id="future">future</h3>
<p><strong>Member Function</strong><br>
<code>share</code> | transfers the shared state from <code>*this</code> to a <code>shared_future</code> and returns it (public member function)</p>
<p><strong>Getting the result</strong><br>
<code>get</code> | returns the result (public member function). 用于获得结果。如果与 future 关联的共享状态处于未就绪状态，那么这个调用就会阻塞。一直等到共享状态变为就绪这个函数才会返回结果值。</p>
<p><strong>State</strong><br>
<code>valid</code> | checks if the future has a shared state (public member function)<br>
<code>wait</code> | waits for the result to become available (public member function). wait 则是等待状态就绪。当共享状态变为就绪后这个函数返回，这时再调用 get 函数则会直接获得结果。<br>
<code>wait_for</code> | waits for the result, returns if it is not available for the specified timeout duration (public member function). 等待一定的时间。<br>
<code>wait_until</code> | waits for the result, returns if it is not available until specified time point has been reached<br>
(public member function). 等待到指定的时刻。</p>
<p>wait_for 和 wait_until 的返回值都是状态码，包括 ready, timeout，deferred 这三种枚举值。其中 ready 是共享状态就绪，timeout 是超时，而 deffered 是共享状态中含有延缓执行的函数，也就是只有在显式请求时才会执行的函数。</p>
<h2 id="mechanism">Mechanism:</h2>
<p>Promise sets a value (or exception).<br>
Future retrieves the value.</p>
<h2 id="explanation">Explanation</h2>
<p>在 C++中,promise 和 future 这两个类为线程之间提供了一种简单的通信机制。<em>一个线程可以通过 promise 设置值或者异常，而另一个线程可以通过 future 来获得这个值或者异常</em>。promise 和 future 实现通信的核心是类对象 Shared State，它提供的函数可以保证线程同步的情况下实现对状态和结果的设置和获取。一对 promise 和 future 对象共享了一个 Shared State 对象。promise 通过 Shared State 对象设置状态和结果，而 future 则通过 Shared State 对象获得状态和结果。promise 和 future 常用于生产者消费者模式或者发送接收模式的应用场景中，发送者提供结果而接收者等待并获得结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_pi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> num_steps, std::promise&lt;<span class="hljs-type">double</span>&gt;&amp;&amp; promise)</span> </span>&#123;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; num_steps; ++i) &#123;<br>        <span class="hljs-type">double</span> x = (i + <span class="hljs-number">0.5</span>) / num_steps;<br>        sum += <span class="hljs-number">4.0</span> / (<span class="hljs-number">1.0</span> + x * x);<br>    &#125;<br>    promise.<span class="hljs-built_in">set_value</span>(sum / num_steps);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">double</span>&gt;&amp;&amp; receiver)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Computed value of PI: &quot;</span> &lt;&lt; receiver.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N_STEPS = <span class="hljs-number">1000000000</span>;<br>    std::thread th1, th2;<br><br>    &#123;<br>        std::promise&lt;<span class="hljs-type">double</span>&gt; promise;<br>        <span class="hljs-keyword">auto</span> receiver = promise.<span class="hljs-built_in">get_future</span>();<br>        th1 = std::<span class="hljs-built_in">thread</span>(compute_pi, N_STEPS, std::<span class="hljs-built_in">move</span>(promise)); <span class="hljs-comment">// 使用移动语义，对象被销毁后不妨碍后续线程执行</span><br>        th2 = std::<span class="hljs-built_in">thread</span>(display, std::<span class="hljs-built_in">move</span>(receiver));<br>    &#125;<br><br>    th<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    th<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>**使用 future 对象获得结果只能使用一次，这样只能让一个线程获得结果。如果需要让多个线程获得结果，就要使用 shared_future。**shared_future 可以通过两种方式获得：第一种是直接定义一个 shared_future 对象，使用 promise.get_future 函数返回的 future 值作为初始化参数。另一种是通过 future 对象的 shared 函数，将其转换为 shared_future，这时原有的 future 对象不能再使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::shared_future&lt;<span class="hljs-type">double</span>&gt;;<br><span class="hljs-built_in">shared_future</span>(promise.<span class="hljs-built_in">get_future</span>());<br><br><span class="hljs-keyword">auto</span> shared_future = future.<span class="hljs-built_in">share</span>();<br></code></pre></td></tr></table></figure>
<p>shared_future 和 future 的不同：一个 future 对象只能与一个共享状态对象关联，所以必须通过移动或者引用的方式使用，而 shared_future 对象可以多个同时共享状态，所以它可以采用拷贝的方式使用</p>
<h1 id="mutex-amp-lock-互斥-amp-锁">Mutex &amp; Lock （互斥 &amp; 锁）</h1>
<h2 id="intro">Intro:</h2>
<p>在多线程程序中，当多个线程对同一个数据对象进行访问，并且至少有一个线程在写数据时，会产生数据竞争。但是多个线程同时读取同一个数据对象时没有数据竞争。C++中，所有的运算如果没有声明是原子操作，就默认为非原子操作。也就是在多线程的情况下这个操作对数据的访问可能会被中断，数据会被其他线程访问。因此当多个线程同时访问同一个对象，并进行非原子的写操作时，就可能因为产生数据竞争而导致错误的结果。互斥量 mutex 则是提供了一种同步机制，允许多个线程安全地访问共享对象。从 C++11 开始，提供了 std::mutex 来实现互斥。</p>
<h2 id="definition">Definition:</h2>
<p>Mutex (Mutual Exclusion): A synchronization primitive to protect shared data from concurrent access.<br>
Lock: Manages mutex locking and unlocking automatically.</p>
<h2 id="common-mutex-types">Common Mutex Types:</h2>
<p>std::mutex: Basic mutex.<br>
std::recursive_mutex: Allows the same thread to lock multiple times.<br>
std::timed_mutex: Allows timed lock attempts.</p>
<p><strong>Common functions</strong><br>
<code>lock</code> | locks the mutex, blocks if the mutex is not available (public member function). 用于锁定这个互斥量，也就是获得这个互斥量。如果互斥量已经被其他线程锁定，就会进入阻塞状态，直到被解锁、释放后才能够再次锁定。<br>
<code>try_lock</code> | tries to lock the mutex, returns if the mutex is not available (public member function). 试图锁定这个互斥量。该函数会立即返回。如果成功锁定这个互斥量则返回值为 true，否则为 false。注意,即使返回 false 值，也不保证互斥量正在被其他线程锁定。<br>
<code>unlock</code> | unlocks the mutex (public member function)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      在m_count++语句前调用counter_mutex.lock,在其后调用counter_mutex.unlock。对这条语句中要修改的资源进行保护，以保证同一时间只有一个线程可以修改m_count，也就是当一个线程执行了lock这条语句时要么获得这个互斥量执行后面的语句，要么进入阻塞状态等待互斥量的释放。被保护的这段代码叫做Critical Section, 临界区也就是多个线程或进程都会执行的一段代码这段代码会访问共享资源，例如内存、文件等。</span><br><span class="hljs-comment">      */</span><br>        counter_mutex.<span class="hljs-built_in">lock</span>();<br>        m_count++;<br>        counter_mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_count; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::mutex counter_mutex;<br>    <span class="hljs-type">int</span> m_count = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    Counter counter;<br>    <span class="hljs-keyword">auto</span> increase = [](Counter&amp; counter) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) counter.<span class="hljs-built_in">inc</span>();<br>    &#125;;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(increase, std::ref(counter))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">th2</span><span class="hljs-params">(increase, std::ref(counter))</span></span>;<br><br>    th<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    th<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Final count: &quot;</span> &lt;&lt; counter.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="lock-types">Lock Types:</h2>
<p>实际应用中，单独使用 mutex，在函数返回抛出异常等情况下容易出现未释放互斥量的问题。为了避免这种情况发生，通常将 mutex 结合 lock_guard, scoped_lock, unique_lock 来使用。</p>
<h3 id="stdlock_guard-c11">std::lock_guard (C++11)</h3>
<p>Automatically locks and unlocks a mutex. It’s a RAII (Resource Acquisition Is Initialization) wrapper to manage a single mutex lock within a scope.</p>
<ul>
<li>Automatically locks the provided mutex upon construction.</li>
<li>Automatically unlocks the mutex when the lock_guard object goes out of scope.</li>
</ul>
<p>lock_guard 简化后的代码如下。它的私有成员是一个 mutex 引用，构造函数在使用一个 mutex 对象初始化后直接调用它的 lock 函数，来试图获得这个互斥量。而在析构函数中会通过 unlock 函数来释放掉这个互斥量。lock_guard 中还有一个构造函数，用于接管一个已经被当前线程锁定的 mutex，也就是初始化时不再调用它的 lock 函数，而只是负责在析构时释放这个 mutex。另外拷贝构造和拷贝赋值都被删除了也就是 lock_guard 是不能被拷贝的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Mutex&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(Mutex&amp; m)</span> : m_mutex(m) &#123;</span><br>        m_mutex.<span class="hljs-built_in">lock</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">lock_guard</span>(Mutex&amp; m, <span class="hljs-type">adopt_lock_t</span>) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">m_mutex</span>(m) &#123;&#125;<br><br>    ~<span class="hljs-built_in">lock_guard</span>() &#123;<br>        m_mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>    lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>    Mutex&amp; m_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如下修改前面的代码例子加入 lock_guard，在 inc 函数中创建了 lock_guard 局部对象 lock，它的构造函数直接调用了 mutex 的 lock 函数。要么会获得这个互斥量继续执行，要么阻塞等待资源的释放。当 inc 函数执行完毕后（离开作用域），这个 lock_guard 对象会自动销毁，销毁时在析构函数中，调用 mutex 的 unlock 函数释放互斥量。通过这种 RAII 资源获取及初始化的方式来使用 mutex，一来简化了使用，避免多次调用 lock 函数产生死锁；更重要的是，当离开作用域出现异常，函数返回时 mutex 可以随着自动对象的销毁而自动解锁，不会有忘记解锁的情况发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(counter_mutex)</span></span>;<br>        m_count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(counter_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> m_count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::mutex counter_mutex;<br>    <span class="hljs-type">int</span> m_count = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="stdunique_lock-c11">std::unique_lock (C++11)</h3>
<p>Flexible locking mechanism with manual lock/unlock support. It’s a flexible RAII-style lock for single mutex. It offers additional features over std::lock_guard, such as deferred locking, timed locking, and the ability to transfer ownership.</p>
<ul>
<li>Can lock a mutex on construction or leave it unlocked (deferred lock).</li>
<li>Provides manual lock/unlock control.</li>
<li>Can adopt an already locked mutex (adopt lock).</li>
<li>Useful for complex locking scenarios or timed operations.</li>
</ul>
<p>lock | locks (i.e., takes ownership of) the associated mutex (public member function)<br>
try_lock | tries to lock (i.e., takes ownership of) the associated mutex without blocking (public member function)<br>
try_lock_for | attempts to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable for the specified time duration (public member function)<br>
try_lock_until | tries to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable until specified time point has been reached (public member function)<br>
unlock | unlocks (i.e., releases ownership of) the associated mutex (public member function)</p>
<p>Modify the previous code and use unique_lock instead.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increase</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(counter_mutex, std::defer_lock)</span></span>;<br>        <span class="hljs-keyword">while</span> (n--)<br>        &#123;<br>            lock.<span class="hljs-built_in">lock</span>();<br>            m_count++;<br>            lock.<span class="hljs-built_in">unlock</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(counter_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> m_count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::mutex counter_mutex;<br>    <span class="hljs-type">int</span> m_count = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Counter counter;<br>    <span class="hljs-keyword">auto</span> increase = [](Counter &amp;counter)<br>    &#123;<br>        counter.<span class="hljs-built_in">increase</span>(<span class="hljs-number">10000</span>);<br>    &#125;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(increase, std::ref(counter))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">th2</span><span class="hljs-params">(increase, std::ref(counter))</span></span>;<br><br>    th<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    th<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;counter=&quot;</span> &lt;&lt; counter.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>timed_mutex 比 mutex 类多了两个, try_lock_for 和 try_until。try_lock_for 是在指定时长内获得 mutex 的所有权，而 try_until 是在指定时刻前获得 mutex 的所有权。当这两个函数返回值为 true 时，表明获得 mutex 可以安全访问共享资源，否则获得 mutex 失败。与 try_lock 一样,返回 false 不意味着 mutex 当前被其他线程占有。</p>
<h3 id="stdlock-c11">std::lock (C++11)</h3>
<p>It’s a utility function used to acquire multiple locks simultaneously without the risk of deadlock.</p>
<ul>
<li>Ensures atomic locking of all mutexes provided as arguments.</li>
<li>Prevents deadlock by acquiring locks in a consistent order internally.</li>
<li>Does not manage the lifetime of the locks. You must manually unlock the mutexes.</li>
</ul>
<h3 id="stdscope_lock-c17">std::scope_lock (C++17)</h3>
<p>The class scoped_lock is a mutex wrapper that provides a convenient RAII-style mechanism for owning zero or more mutexes for the duration of a scoped block.</p>
<p>When a scoped_lock object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the scoped_lock object was created, the scoped_lock is destructed and the mutexes are released. If several mutexes are given, deadlock avoidance algorithm is used as if by std::lock.</p>
<p>The scoped_lock class is <strong>non-copyable</strong>.</p>
<ul>
<li>Locks multiple mutexes in a single call.</li>
<li>Uses std::lock internally to avoid deadlock.</li>
<li>Automatically unlocks all mutexes when the scoped_lock object goes out of scope.</li>
<li>Preferred over manually using std::lock and std::lock_guard for multiple mutexes.</li>
</ul>
<h3 id="stdshared_lock-c17">std::shared_lock (C++17)</h3>
<p>A RAII-style lock object used to manage shared (read) locks on a std::shared_mutex.<br>
Note:<br>
std::shared_mutex (C++17) is a synchronization primitive that allows multiple readers or one writer at a time:</p>
<ul>
<li>
<p>Multiple threads can simultaneously acquire a shared (read) lock.</p>
</li>
<li>
<p>Only one thread can acquire an exclusive (write) lock, and it blocks all shared locks while holding the mutex.<br>
Use Cases:</p>
<ul>
<li>Suitable when there’s frequent read access and infrequent write access to shared resources.</li>
<li>Example: Configurations, caches, or datasets that are often read but rarely modified</li>
</ul>
</li>
<li>
<p>Provides automatic locking of the std::shared_mutex on construction.</p>
</li>
<li>
<p>Automatically unlocks the mutex when the shared_lock object goes out of scope.</p>
</li>
<li>
<p>Can defer locking (std::defer_lock), adopt an already locked mutex (std::adopt_lock), or attempt a timed lock (std::try_to_lock).</p>
</li>
<li>
<p>std::unique_lock is for exclusive locks, while std::shared_lock is for shared(read) locks.</p>
</li>
</ul>
<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::shared_mutex sharedMutex; <span class="hljs-comment">// Shared mutex</span><br><span class="hljs-type">int</span> sharedResource = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(sharedMutex)</span></span>; <span class="hljs-comment">// Acquire shared (read) lock</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reader &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; reads value: &quot;</span> &lt;&lt; sharedResource &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// Lock is automatically released when `lock` goes out of scope</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(sharedMutex)</span></span>; <span class="hljs-comment">// Acquire exclusive (write) lock</span><br>    sharedResource += <span class="hljs-number">1</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Writer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; modifies value to: &quot;</span> &lt;&lt; sharedResource &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// Lock is automatically released when `lock` goes out of scope</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::thread&gt; threads;<br><br>    <span class="hljs-comment">// Spawn writer threads</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>(writer, i + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Spawn reader threads</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>(reader, i + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : threads) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="deadlock-and-livelock">Deadlock and Livelock</h2>
<h3 id="deadlock">Deadlock</h3>
<p>A deadlock occurs when two or more threads or processes are waiting for each other to release resources, and none of them can proceed.</p>
<p>In a single thread, locking the same mutex multiple times could lead to a deadlock (replace the mutex with std::recursive_mutex can solve the problem in this solution, unlock the same times to finally release it).</p>
<p>In the example below, thread 1 locks mutex1 and waits for mutex2, while thread 2 locks mutex2 and waits for mutex1. This causes a deadlock (use RAII methods, automatically manage the mutex with unique_lock, lock_guard, etc. When calling std::lock(), even though the order of input mutex is different, we can still avoid deadlocks because of the special algorithm inside std::lock.).</p>
<p>Another solution is that when we need to lock / unlock several mutex, lock / unlock them in different orders can also lead to deadlock.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mutex1, mutex2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(mutex1)</span></span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">50</span>));  <span class="hljs-comment">// Simulate work</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock2</span><span class="hljs-params">(mutex2)</span></span>;  <span class="hljs-comment">// Wait for mutex2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock2</span><span class="hljs-params">(mutex2)</span></span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">50</span>));  <span class="hljs-comment">// Simulate work</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(mutex1)</span></span>;  <span class="hljs-comment">// Wait for mutex1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(thread2)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="solutions-to-deadlocks">Solutions to deadlocks</h4>
<ol>
<li>Consistent Lock Ordering: Always acquire locks in the same order.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread1</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">lock</span>(mutex1, mutex2);  <span class="hljs-comment">// lock both mutexes without deadlock</span><br>    <span class="hljs-comment">// make sure both already-locked mutexes are unlocked at the end of scope</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(mutex1, std::adopt_lock)</span></span>;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock2</span><span class="hljs-params">(mutex2, std::adopt_lock)</span></span>;<br><br>    <span class="hljs-comment">// equivalent approach:</span><br>    <span class="hljs-comment">//  std::unique_lock&lt;std::mutex&gt; lock1&#123;from.m, std::defer_lock&#125;;</span><br>    <span class="hljs-comment">//  std::unique_lock&lt;std::mutex&gt; lock2&#123;to.m, std::defer_lock&#125;;</span><br>    <span class="hljs-comment">//  std::lock(lock1, lock2);</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>Use std::lock for Multiple Locks: std::lock locks all mutexes atomically, avoiding deadlock.</li>
<li>Timeout Mechanisms: Use std::timed_mutex or std::unique_lock to limit wait time for locks.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (mutex<span class="hljs-number">1.</span><span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>))) &#123;<br>    <span class="hljs-keyword">if</span> (mutex<span class="hljs-number">2.</span><span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>))) &#123;<br>        <span class="hljs-comment">// Critical section</span><br>        mutex<span class="hljs-number">2.</span><span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    mutex<span class="hljs-number">1.</span><span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>Avoid Nested Locks: Minimize locking multiple mutexes simultaneously.</li>
</ol>
<h4 id="solutions-to-deadlocks-based-on-coffman-conditions">Solutions to deadlocks based on Coffman Conditions</h4>
<p><strong>为什么会出现死锁？</strong></p>
<p>死锁的发生通常需要同时满足以下四个条件，也就是著名的“科夫曼条件”（Coffman conditions）：</p>
<ol>
<li><strong>互斥 (Mutual Exclusion)</strong>: 至少有一个资源必须以非共享模式持有。也就是说，一次只有一个线程可以使用该资源。如果其他线程请求该资源，则请求线程必须等待，直到资源被释放。这对于锁来说是基本特性。</li>
<li><strong>占有并等待 (Hold and Wait)</strong>: 一个线程必须至少持有一个资源，并且正在等待获取其他线程当前持有的额外资源。线程不会释放已持有的资源，直到它获得所有它需要的资源。</li>
<li><strong>不可抢占 (No Preemption)</strong>: 资源不能被强制从持有它的线程中抢占。资源只能由持有它的线程在完成任务后自愿释放。</li>
<li><strong>循环等待 (Circular Wait)</strong>: 必须存在一组等待线程 {T0, T1, …, Tn}，其中 T0 正在等待 T1 持有的资源，T1 正在等待 T2 持有的资源，…，Tn-1 正在等待 Tn 持有的资源，而 Tn 正在等待 T0 持有的资源。这就形成了一个等待环路。</li>
</ol>
<p>只有当这四个条件同时满足时，死锁才可能发生。</p>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁的策略通常是尝试破坏上述四个条件中的至少一个：</p>
<ol>
<li>
<p><strong>破坏互斥条件</strong>:</p>
<ul>
<li><strong>思路</strong>: 如果资源可以共享，那么就不会因为争抢而产生死锁。</li>
<li><strong>实践</strong>: 对于某些资源，这可能是可行的，例如，只读数据。可以使用读写锁 (<code>std::shared_mutex</code>) 允许多个线程同时读取。然而，许多资源本身就是互斥的（例如，对一个共享变量的写操作），所以这个条件往往不能轻易破坏。</li>
</ul>
</li>
<li>
<p><strong>破坏占有并等待条件</strong>:</p>
<ul>
<li><strong>思路</strong>: 不允许线程在持有一个或多个资源的同时，去请求其他资源。</li>
<li><strong>实践</strong>:
<ul>
<li><strong>一次性获取所有资源</strong>: 线程在开始执行前，一次性获取其所需的所有资源。如果无法一次性获取所有资源，则不获取任何资源，并等待。这在 C++ 中可以通过 <code>std::lock(mutex1, mutex2, ...)</code> 函数来实现，它会以避免死锁的方式尝试锁定所有给定的互斥体。</li>
<li><strong>释放已持有资源再请求</strong>: 如果线程已经持有某些资源，并且需要请求新的资源但无法立即获得，它可以先释放当前持有的所有资源，然后再重新尝试获取所有需要的资源。这种方式可能会导致活锁或性能问题。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>破坏不可抢占条件</strong>:</p>
<ul>
<li><strong>思路</strong>: 如果一个线程持有一些资源，并请求另一个不能立即分配给它的资源，则该线程可以释放其当前持有的所有资源。或者，操作系统可以从某个线程那里抢占资源分配给更高优先级的线程。</li>
<li><strong>实践</strong>:
<ul>
<li><strong>主动释放</strong>: 线程可以使用 <code>try_lock</code> 或带超时的锁 (<code>std::timed_mutex</code>)。如果无法获得所需的锁，它可以释放已有的锁，然后稍后重试。</li>
<li><strong>系统抢占</strong>: 在用户态 C++ 编程中，直接实现资源抢占比较困难，这更多是操作系统层面的机制。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>破坏循环等待条件</strong>:</p>
<ul>
<li><strong>思路</strong>: 通过对资源（通常是锁）的请求施加一个顺序，来避免形成等待环路。</li>
<li><strong>实践</strong>:
<ul>
<li><strong>锁序法 (Lock Ordering / Resource Hierarchy)</strong>: 这是最常用和最有效的避免死锁的方法之一。为所有锁分配一个唯一的全局顺序（或层级）。所有线程都必须按照这个预定义的顺序来获取锁。例如，如果有两个锁 L1 和 L2，规定所有线程必须先获取 L1 再获取 L2。这样就不会出现一个线程持有 L1 等待 L2，而另一个线程持有 L2 等待 L1 的情况。</li>
<li><strong><code>std::lock</code> 函数</strong>: 如前所述，<code>std::lock</code> 内部也采用了避免循环等待的策略（通常是基于尝试锁定和回退，或者内部排序）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>其他策略:</strong></p>
<ul>
<li><strong>死锁检测与恢复 (Deadlock Detection and Recovery)</strong>: 这种策略允许死锁发生，然后系统检测到死锁，并采取措施恢复（例如，终止一个或多个死锁的线程，或者回滚操作）。这在数据库系统中比较常见，但在通用的 C++ 应用中较少直接实现，因为恢复的代价可能很高。</li>
<li><strong>使用更高级别的并发抽象</strong>: 例如，使用任务、future、线程池等，它们内部可能已经处理了许多底层的同步问题。</li>
</ul>
<h3 id="livelock">Livelock</h3>
<p>A livelock occurs when threads or processes are not blocked but keep changing states in response to each other, without making progress. In contrast to deadlock, threads are actively running but stuck in a loop of retries.</p>
<p>In the example below, threads keep trying to acquire locks but back off and retry, never entering the critical section.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mutex1, mutex2;<br><span class="hljs-type">bool</span> thread1Failed = <span class="hljs-literal">false</span>, thread2Failed = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!thread1Failed) &#123;<br>        <span class="hljs-keyword">if</span> (mutex<span class="hljs-number">1.</span><span class="hljs-built_in">try_lock</span>()) &#123;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">50</span>));  <span class="hljs-comment">// Simulate work</span><br>            <span class="hljs-keyword">if</span> (mutex<span class="hljs-number">2.</span><span class="hljs-built_in">try_lock</span>()) &#123;<br>                <span class="hljs-comment">// Critical section</span><br>                mutex<span class="hljs-number">2.</span><span class="hljs-built_in">unlock</span>();<br>                mutex<span class="hljs-number">1.</span><span class="hljs-built_in">unlock</span>();<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mutex<span class="hljs-number">1.</span><span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// Release and retry</span><br>                thread1Failed = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// Simulate conflict resolution</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!thread2Failed) &#123;<br>        <span class="hljs-keyword">if</span> (mutex<span class="hljs-number">2.</span><span class="hljs-built_in">try_lock</span>()) &#123;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">50</span>));  <span class="hljs-comment">// Simulate work</span><br>            <span class="hljs-keyword">if</span> (mutex<span class="hljs-number">1.</span><span class="hljs-built_in">try_lock</span>()) &#123;<br>                <span class="hljs-comment">// Critical section</span><br>                mutex<span class="hljs-number">1.</span><span class="hljs-built_in">unlock</span>();<br>                mutex<span class="hljs-number">2.</span><span class="hljs-built_in">unlock</span>();<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mutex<span class="hljs-number">2.</span><span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// Release and retry</span><br>                thread2Failed = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// Simulate conflict resolution</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(thread2)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="solutions-to-livelocks">Solutions to livelocks</h4>
<ol>
<li>Exponential Backoff: Introduce randomized delays or exponential backoff to reduce collisions.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>Avoid Priority Inversion: Ensure fairness by avoiding situations where higher-priority tasks constantly preempt lower-priority ones.</li>
<li>Resource Allocation Algorithms: Implement algorithms like Banker’s Algorithm for resource allocation.</li>
<li>Detect and Break the Loop: Add a limit to retries or use a monitor thread to detect repeated retries and resolve the conflict.</li>
</ol>
<h1 id="reference">Reference</h1>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19tC3YvEAd/?spm_id_from=333.788.videopod.sections&amp;vd_source=33a663db754f5be8d9abe7f36a2c46bd">https://www.bilibili.com/video/BV19tC3YvEAd/?spm_id_from=333.788.videopod.sections&amp;vd_source=33a663db754f5be8d9abe7f36a2c46bd</a><br>
<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/thread">https://en.cppreference.com/w/cpp/thread/thread</a><br>
<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/future">https://en.cppreference.com/w/cpp/thread/future</a><br>
<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/promise">https://en.cppreference.com/w/cpp/thread/promise</a><br>
<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/mutex">https://en.cppreference.com/w/cpp/thread/mutex</a><br>
<a target="_blank" rel="noopener" href="https://www.cs.yale.edu/homes/aspnes/pinewiki/Deadlock.html">https://www.cs.yale.edu/homes/aspnes/pinewiki/Deadlock.html</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Learning/" class="category-chain-item">Learning</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Programming/" class="category-chain-item">Programming</a>
  
  
    <span>></span>
    
  <a href="/categories/Learning/Programming/C/" class="category-chain-item">C++</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cpp/" class="print-no-link">#cpp</a>
      
        <a href="/tags/threads/" class="print-no-link">#threads</a>
      
        <a href="/tags/mutex/" class="print-no-link">#mutex</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ 多线程</div>
      <div>http://example.com/2024/12/29/multi-threads/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Go7</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 29, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/12/30/GAMES101-L02-LinearAlgebra/" title="GAMES 101 L02-Review of Linear Algebra">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GAMES 101 L02-Review of Linear Algebra</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/28/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  




  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Go7 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
